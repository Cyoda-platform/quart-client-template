{
    "entity_models": [
        {
            "entity_model_name": "entity",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime",
                "content": "async def process_entity(entity: dict) -> dict:\n    # Initialize mandatory fields for new entity\n    if \"current_state\" not in entity:\n        entity[\"current_state\"] = \"Created\"\n    if \"created_at\" not in entity:\n        entity[\"created_at\"] = datetime.utcnow().isoformat()\n    # Ensure 'data' field exists as dict\n    if \"data\" not in entity or not isinstance(entity[\"data\"], dict):\n        entity[\"data\"] = {}\n    return entity",
                "name": "process_entity"
            }
        },
        {
            "entity_model_name": "entity",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import logging\nlogger = logging.getLogger(__name__)\n\nasync def fetch_external_data(name: str) -> dict:\n    import httpx\n    EXTERNAL_API_BASE = \"https://api.agify.io\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(EXTERNAL_API_BASE, params={\"name\": name})\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            logger.exception(f\"Failed to fetch external data for name={name}: {e}\")\n            return {\"error\": \"Failed to fetch external data\"}",
                "content": "async def process_entity_workflow_trigger(entity: dict) -> dict:\n    # Extract and remove workflow trigger info\n    trigger = entity.pop('_workflow_trigger', None)\n    if not trigger:\n        # No trigger, do nothing\n        return entity\n\n    event = trigger.get(\"event\")\n    payload = trigger.get(\"payload\", {})\n\n    # Use or initialize current_state\n    current_state = entity.get(\"current_state\", \"Created\")\n\n    try:\n        if event == \"predict_age\":\n            name = payload.get(\"name\")\n            if not name or not isinstance(name, str) or not name.strip():\n                entity[\"current_state\"] = \"Failed\"\n                entity[\"data\"] = {\"error\": \"Missing or invalid 'name' in payload for predict_age event\"}\n                return entity\n\n            entity[\"current_state\"] = \"Processing\"\n\n            # Fetch external data asynchronously\n            external_result = await fetch_external_data(name.strip())\n\n            if \"error\" in external_result:\n                entity[\"current_state\"] = \"Failed\"\n                entity[\"data\"] = external_result\n            else:\n                entity[\"current_state\"] = \"Completed\"\n                entity[\"data\"] = external_result\n\n        else:\n            # Unsupported event\n            entity[\"current_state\"] = \"Failed\"\n            entity[\"data\"] = {\"error\": f\"Unsupported event '{event}'\"}\n\n    except Exception as e:\n        logger.exception(f\"Error processing workflow event '{event}': {e}\")\n        entity[\"current_state\"] = \"Failed\"\n        entity[\"data\"] = {\"error\": str(e)}\n\n    return entity",
                "name": "process_entity_workflow_trigger"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Dict, Any\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass WorkflowTriggerRequest:\n    event: str\n    payload: dict\n\n@dataclass\nclass ListQuery:\n    state: str\n    limit: int\n    offset: int\n\n@dataclass\nclass NewEntityRequest:\n    data: dict\n\nentity_jobs: Dict[str, Dict[str, Any]] = {}\n\nEXTERNAL_API_BASE = \"https://api.agify.io\"\n\nasync def fetch_external_data(name: str) -> Dict[str, Any]:\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(EXTERNAL_API_BASE, params={\"name\": name})\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            logger.exception(f\"Failed to fetch external data for name={name}: {e}\")\n            return {\"error\": \"Failed to fetch external data\"}\n\nasync def process_entity(entity: dict) -> dict:\n    # Initialize mandatory fields for new entity\n    if \"current_state\" not in entity:\n        entity[\"current_state\"] = \"Created\"\n    if \"created_at\" not in entity:\n        entity[\"created_at\"] = datetime.utcnow().isoformat()\n    # Ensure 'data' field exists as dict\n    if \"data\" not in entity or not isinstance(entity[\"data\"], dict):\n        entity[\"data\"] = {}\n    return entity\n\nasync def process_entity_workflow_trigger(entity: dict) -> dict:\n    # Extract and remove workflow trigger info\n    trigger = entity.pop('_workflow_trigger', None)\n    if not trigger:\n        # No trigger, do nothing\n        return entity\n\n    event = trigger.get(\"event\")\n    payload = trigger.get(\"payload\", {})\n\n    # Use or initialize current_state\n    current_state = entity.get(\"current_state\", \"Created\")\n\n    try:\n        if event == \"predict_age\":\n            name = payload.get(\"name\")\n            if not name or not isinstance(name, str) or not name.strip():\n                entity[\"current_state\"] = \"Failed\"\n                entity[\"data\"] = {\"error\": \"Missing or invalid 'name' in payload for predict_age event\"}\n                return entity\n\n            entity[\"current_state\"] = \"Processing\"\n\n            # Fetch external data asynchronously\n            external_result = await fetch_external_data(name.strip())\n\n            if \"error\" in external_result:\n                entity[\"current_state\"] = \"Failed\"\n                entity[\"data\"] = external_result\n            else:\n                entity[\"current_state\"] = \"Completed\"\n                entity[\"data\"] = external_result\n\n        else:\n            # Unsupported event\n            entity[\"current_state\"] = \"Failed\"\n            entity[\"data\"] = {\"error\": f\"Unsupported event '{event}'\"}\n\n    except Exception as e:\n        logger.exception(f\"Error processing workflow event '{event}': {e}\")\n        entity[\"current_state\"] = \"Failed\"\n        entity[\"data\"] = {\"error\": str(e)}\n\n    return entity\n\n@app.route(\"/api/entity\", methods=[\"POST\"])\n@validate_request(NewEntityRequest)\nasync def add_entity(data: NewEntityRequest):\n    try:\n        entity_data = data.data\n        if not isinstance(entity_data, dict):\n            return jsonify({\"status\": \"error\", \"message\": \"Entity data must be a dict\"}), 400\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"entity\",\n            entity_version=ENTITY_VERSION,\n            entity=entity_data\n        )\n        return jsonify({\"status\": \"success\", \"entity_id\": entity_id}), 201\n    except Exception as e:\n        logger.exception(f\"Failed to add entity: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Internal server error\"}), 500\n\n@app.route(\"/api/entity/<string:entity_id>/workflow/trigger\", methods=[\"POST\"])\n@validate_request(WorkflowTriggerRequest)\nasync def trigger_workflow(data: WorkflowTriggerRequest, entity_id):\n    try:\n        entity = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"entity\",\n            entity_version=ENTITY_VERSION,\n            technical_id=entity_id\n        )\n        if not entity:\n            return jsonify({\"status\": \"error\", \"message\": \"Entity not found\"}), 404\n\n        # Add workflow trigger info to entity\n        entity['_workflow_trigger'] = {\n            \"event\": data.event,\n            \"payload\": data.payload\n        }\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"entity\",\n            entity_version=ENTITY_VERSION,\n            entity=entity,\n            technical_id=entity_id\n        )\n\n        updated_entity = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"entity\",\n            entity_version=ENTITY_VERSION,\n            technical_id=entity_id\n        )\n        current_state = updated_entity.get(\"current_state\", \"Created\")\n        result = updated_entity.get(\"data\", {})\n\n        return jsonify({\n            \"status\": \"accepted\",\n            \"entity_id\": entity_id,\n            \"workflow_state\": current_state,\n            \"result\": result\n        }), 202\n    except Exception as e:\n        logger.exception(f\"Failed to trigger workflow for entity {entity_id}: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Internal server error\"}), 500\n\n@app.route(\"/api/entity/<string:entity_id>/state\", methods=[\"GET\"])\nasync def get_entity_state(entity_id):\n    try:\n        entity = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"entity\",\n            entity_version=ENTITY_VERSION,\n            technical_id=entity_id\n        )\n        if not entity:\n            return jsonify({\"status\": \"error\", \"message\": \"Entity not found\"}), 404\n\n        return jsonify({\n            \"entity_id\": entity_id,\n            \"current_state\": entity.get(\"current_state\", \"Created\"),\n            \"data\": entity.get(\"data\", {})\n        })\n    except Exception as e:\n        logger.exception(f\"Failed to get entity state for {entity_id}: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Internal server error\"}), 500\n\n@validate_querystring(ListQuery)\n@app.route(\"/api/entity/list\", methods=[\"GET\"])\nasync def list_entities():\n    try:\n        state_filter = request.args.get(\"state\")\n        limit = request.args.get(\"limit\", type=int)\n        offset = request.args.get(\"offset\", type=int, default=0)\n\n        all_entities = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"entity\",\n            entity_version=ENTITY_VERSION\n        )\n        filtered = []\n        for entity in all_entities:\n            eid = entity.get(\"id\")\n            current_state = entity.get(\"current_state\", \"Created\")\n            if state_filter and current_state != state_filter:\n                continue\n            filtered.append({\"entity_id\": str(eid), \"current_state\": current_state})\n\n        if limit is not None and limit >= 0 and offset >= 0:\n            filtered = filtered[offset:offset + limit]\n        else:\n            filtered = filtered[offset:]\n\n        return jsonify({\"entities\": filtered})\n    except Exception as e:\n        logger.exception(f\"Failed to list entities: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Internal server error\"}), 500\n\nif __name__ == '__main__':\n    import sys\n\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s %(levelname)s [%(name)s] %(message)s',\n        stream=sys.stdout,\n    )\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}