{
    "entity_models": [
        {
            "entity_model_name": "prototype",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nfrom typing import Dict, Any\nimport logging\nlogger = logging.getLogger(__name__)",
                "content": "async def process_prototype(entity: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Workflow function applied to the 'prototype' entity asynchronously before persistence.\n    It processes the queued weather data fetch job.\n    \"\"\"\n    status = entity.get(\"status\")\n    if status != \"queued\":\n        # No processing needed if not queued\n        return entity\n\n    # Change status to processing (direct modification, will be persisted)\n    entity[\"status\"] = \"processing\"\n    entity[\"processingStartedAt\"] = datetime.utcnow().isoformat()\n\n    input_params = entity.get(\"input\", {})\n    latitude = input_params.get(\"latitude\")\n    longitude = input_params.get(\"longitude\")\n    start_date = input_params.get(\"start_date\")\n    end_date = input_params.get(\"end_date\")\n    parameters = input_params.get(\"parameters\", [])\n    hourly = \",\".join(parameters) if parameters else \"\"\n\n    # Validate essential parameters early to avoid unnecessary external calls\n    if latitude is None or longitude is None or not start_date or not end_date:\n        entity[\"status\"] = \"failed\"\n        entity[\"errorMessage\"] = \"Missing required input parameters\"\n        entity[\"failedAt\"] = datetime.utcnow().isoformat()\n        return entity\n\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"hourly\": hourly,\n        \"timezone\": \"auto\",\n    }\n\n    try:\n        external_data = await fetch_weather_external(params)\n        hourly_data = external_data.get(\"hourly\", {})\n        timestamps = hourly_data.get(\"time\", [])\n        filtered_params: Dict[str, Any] = {}\n        for param in parameters:\n            filtered_params[param] = hourly_data.get(param, [])\n\n        result = {\n            \"data_id\": entity.get(\"technical_id\") or entity.get(\"id\") or \"unknown\",\n            \"latitude\": latitude,\n            \"longitude\": longitude,\n            \"parameters\": filtered_params,\n            \"timestamps\": timestamps,\n        }\n\n        entity[\"result\"] = result\n        entity[\"status\"] = \"completed\"\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n\n    except Exception as e:\n        logger.exception(f\"Failed to fetch weather data in workflow for entity {entity.get('technical_id')}\")\n        entity[\"status\"] = \"failed\"\n        entity[\"result\"] = None\n        entity[\"errorMessage\"] = str(e)\n        entity[\"failedAt\"] = datetime.utcnow().isoformat()\n\n    return entity\n",
                "name": "process_prototype"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, List\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\nimport httpx\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass FetchRequest:\n    latitude: float\n    longitude: float\n    parameters: List[str]\n    start_date: str\n    end_date: str\n\nOPEN_METEO_URL = \"https://api.open-meteo.com/v1/forecast\"\n\nasync def fetch_weather_external(params: Dict[str, Any]) -> Dict[str, Any]:\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(OPEN_METEO_URL, params=params, timeout=10)\n            response.raise_for_status()\n            return response.json()\n        except httpx.HTTPError as e:\n            logger.exception(f\"HTTP error when calling Open-Meteo API: {e}\")\n            raise\n\nasync def process_prototype(entity: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Workflow function applied to the 'prototype' entity asynchronously before persistence.\n    It processes the queued weather data fetch job.\n    \"\"\"\n    status = entity.get(\"status\")\n    if status != \"queued\":\n        # No processing needed if not queued\n        return entity\n\n    # Change status to processing (direct modification, will be persisted)\n    entity[\"status\"] = \"processing\"\n    entity[\"processingStartedAt\"] = datetime.utcnow().isoformat()\n\n    input_params = entity.get(\"input\", {})\n    latitude = input_params.get(\"latitude\")\n    longitude = input_params.get(\"longitude\")\n    start_date = input_params.get(\"start_date\")\n    end_date = input_params.get(\"end_date\")\n    parameters = input_params.get(\"parameters\", [])\n    hourly = \",\".join(parameters) if parameters else \"\"\n\n    # Validate essential parameters early to avoid unnecessary external calls\n    if latitude is None or longitude is None or not start_date or not end_date:\n        entity[\"status\"] = \"failed\"\n        entity[\"errorMessage\"] = \"Missing required input parameters\"\n        entity[\"failedAt\"] = datetime.utcnow().isoformat()\n        return entity\n\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"hourly\": hourly,\n        \"timezone\": \"auto\",\n    }\n\n    try:\n        external_data = await fetch_weather_external(params)\n        hourly_data = external_data.get(\"hourly\", {})\n        timestamps = hourly_data.get(\"time\", [])\n        filtered_params: Dict[str, Any] = {}\n        for param in parameters:\n            filtered_params[param] = hourly_data.get(param, [])\n\n        result = {\n            \"data_id\": entity.get(\"technical_id\") or entity.get(\"id\") or \"unknown\",\n            \"latitude\": latitude,\n            \"longitude\": longitude,\n            \"parameters\": filtered_params,\n            \"timestamps\": timestamps,\n        }\n\n        entity[\"result\"] = result\n        entity[\"status\"] = \"completed\"\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n\n    except Exception as e:\n        logger.exception(f\"Failed to fetch weather data in workflow for entity {entity.get('technical_id')}\")\n        entity[\"status\"] = \"failed\"\n        entity[\"result\"] = None\n        entity[\"errorMessage\"] = str(e)\n        entity[\"failedAt\"] = datetime.utcnow().isoformat()\n\n    return entity\n\n\n@app.route(\"/weather/fetch\", methods=[\"POST\"])\n@validate_request(FetchRequest)\nasync def fetch_weather(data: FetchRequest):\n    data_dict = data.__dict__\n    # Create entity with status queued, workflow function will process it\n    data_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"prototype\",\n        entity_version=ENTITY_VERSION,\n        entity={\n            \"status\": \"queued\",\n            \"requestedAt\": datetime.utcnow().isoformat(),\n            \"input\": data_dict,\n            \"result\": None,\n        },\n    )\n    return jsonify({\n        \"status\": \"success\",\n        \"message\": \"Weather data fetch initiated\",\n        \"data_id\": str(data_id),\n    })\n\n\n@app.route(\"/weather/result/<data_id>\", methods=[\"GET\"])\nasync def get_weather_result(data_id: str):\n    try:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"prototype\",\n            entity_version=ENTITY_VERSION,\n            technical_id=data_id\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"status\": \"error\", \"message\": \"Data ID not found\"}), 404\n\n    if not job:\n        return jsonify({\"status\": \"error\", \"message\": \"Data ID not found\"}), 404\n\n    status = job.get(\"status\")\n    if status in (\"queued\", \"processing\"):\n        return jsonify({\"status\": \"processing\", \"message\": \"Data is being fetched\"}), 202\n    if status == \"failed\":\n        return jsonify({\"status\": \"failed\", \"message\": \"Failed to fetch weather data\", \"error\": job.get(\"errorMessage\")}), 500\n    return jsonify(job.get(\"result\"))\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}