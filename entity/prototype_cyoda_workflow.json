{
    "entity_models": [
        {
            "entity_model_name": "notification",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "",
                "content": "",
                "name": "None"
            }
        },
        {
            "entity_model_name": "event_detect",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nfrom typing import Dict, Any\nimport logging\nimport httpx\n\nlogger = logging.getLogger(__name__)\n\nasync def analyze_text_for_food_request(text: str) -> bool:\n    headers = {\n        \"Authorization\": f\"Bearer {OPENAI_API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"model\": \"gpt-4\",\n        \"messages\": [\n            {\n                \"role\": \"system\",\n                \"content\": (\n                    \"You are an assistant that detects if a cat is dramatically requesting food. \"\n                    \"Return 'yes' if the input text shows a dramatic food request, otherwise 'no'.\"\n                )\n            },\n            {\n                \"role\": \"user\",\n                \"content\": text\n            }\n        ],\n        \"max_tokens\": 5,\n        \"temperature\": 0\n    }\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.post(OPENAI_API_URL, json=data, headers=headers, timeout=10)\n            response.raise_for_status()\n            result = response.json()\n            answer = result[\"choices\"][0][\"message\"][\"content\"].strip().lower()\n            return answer == \"yes\"\n        except Exception as e:\n            logger.exception(f\"Error calling OpenAI API: {e}\")\n            return False\n",
                "content": "async def process_event_detect(entity: Dict[str, Any]) -> None:\n    cat_id = entity.get(\"cat_id\")\n    input_type = entity.get(\"input_type\")\n    input_data = entity.get(\"input_data\")\n    event_id = entity.get(\"event_id\") or f\"{cat_id}-{datetime.utcnow().timestamp()}\"\n\n    entity_jobs[event_id] = {\n        \"status\": \"processing\",\n        \"requestedAt\": datetime.utcnow().isoformat()\n    }\n\n    try:\n        event_detected = False\n        event_type = None\n        message = None\n\n        if input_type == \"text\":\n            event_detected = await analyze_text_for_food_request(input_data)\n        else:\n            logger.info(f\"Input type '{input_type}' is not supported yet for event detection.\")\n\n        if event_detected:\n            event_type = \"food_request\"\n            message = \"Emergency! A cat demands snacks\"\n            timestamp = datetime.utcnow().isoformat()\n\n            notification_entity = {\n                \"cat_id\": cat_id,\n                \"timestamp\": timestamp,\n                \"message\": message\n            }\n\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"notification\",\n                entity_version=ENTITY_VERSION,\n                entity=notification_entity,\n                workflow=None\n            )\n\n            logger.info(f\"Notification added for cat_id={cat_id}: {message}\")\n\n        entity[\"event_detected\"] = event_detected\n        entity[\"event_type\"] = event_type\n        entity[\"message\"] = message\n        entity[\"processed_at\"] = datetime.utcnow().isoformat()\n\n        entity_jobs[event_id][\"status\"] = \"completed\"\n        entity_jobs[event_id][\"result\"] = {\n            \"event_detected\": event_detected,\n            \"event_type\": event_type,\n            \"message\": message\n        }\n\n    except Exception as e:\n        logger.exception(f\"Error in event_detect workflow: {e}\")\n        entity_jobs[event_id][\"status\"] = \"failed\"\n        entity_jobs[event_id][\"result\"] = {\n            \"event_detected\": False,\n            \"event_type\": None,\n            \"message\": None,\n            \"error\": str(e)\n        }",
                "name": "process_event_detect"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, Callable\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\nnotifications_store: Dict[str, list] = {}\nentity_jobs: Dict[str, dict] = {}\n\nOPENAI_API_KEY = \"your_openai_api_key_here\"  # TODO: replace with environment variable in production\nOPENAI_API_URL = \"https://api.openai.com/v1/chat/completions\"\n\n@dataclass\nclass EventDetectRequest:\n    cat_id: str\n    input_type: str\n    input_data: str\n\nasync def analyze_text_for_food_request(text: str) -> bool:\n    headers = {\n        \"Authorization\": f\"Bearer {OPENAI_API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"model\": \"gpt-4\",\n        \"messages\": [\n            {\n                \"role\": \"system\",\n                \"content\": (\n                    \"You are an assistant that detects if a cat is dramatically requesting food. \"\n                    \"Return 'yes' if the input text shows a dramatic food request, otherwise 'no'.\"\n                )\n            },\n            {\n                \"role\": \"user\",\n                \"content\": text\n            }\n        ],\n        \"max_tokens\": 5,\n        \"temperature\": 0\n    }\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.post(OPENAI_API_URL, json=data, headers=headers, timeout=10)\n            response.raise_for_status()\n            result = response.json()\n            answer = result[\"choices\"][0][\"message\"][\"content\"].strip().lower()\n            return answer == \"yes\"\n        except Exception as e:\n            logger.exception(f\"Error calling OpenAI API: {e}\")\n            return False\n\nasync def process_event_detect(entity: Dict[str, Any]) -> None:\n    cat_id = entity.get(\"cat_id\")\n    input_type = entity.get(\"input_type\")\n    input_data = entity.get(\"input_data\")\n    event_id = entity.get(\"event_id\") or f\"{cat_id}-{datetime.utcnow().timestamp()}\"\n\n    entity_jobs[event_id] = {\n        \"status\": \"processing\",\n        \"requestedAt\": datetime.utcnow().isoformat()\n    }\n\n    try:\n        event_detected = False\n        event_type = None\n        message = None\n\n        if input_type == \"text\":\n            event_detected = await analyze_text_for_food_request(input_data)\n        else:\n            logger.info(f\"Input type '{input_type}' is not supported yet for event detection.\")\n\n        if event_detected:\n            event_type = \"food_request\"\n            message = \"Emergency! A cat demands snacks\"\n            timestamp = datetime.utcnow().isoformat()\n\n            notification_entity = {\n                \"cat_id\": cat_id,\n                \"timestamp\": timestamp,\n                \"message\": message\n            }\n\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"notification\",\n                entity_version=ENTITY_VERSION,\n                entity=notification_entity\n            )\n\n            logger.info(f\"Notification added for cat_id={cat_id}: {message}\")\n\n        entity[\"event_detected\"] = event_detected\n        entity[\"event_type\"] = event_type\n        entity[\"message\"] = message\n        entity[\"processed_at\"] = datetime.utcnow().isoformat()\n\n        entity_jobs[event_id][\"status\"] = \"completed\"\n        entity_jobs[event_id][\"result\"] = {\n            \"event_detected\": event_detected,\n            \"event_type\": event_type,\n            \"message\": message\n        }\n\n    except Exception as e:\n        logger.exception(f\"Error in event_detect workflow: {e}\")\n        entity_jobs[event_id][\"status\"] = \"failed\"\n        entity_jobs[event_id][\"result\"] = {\n            \"event_detected\": False,\n            \"event_type\": None,\n            \"message\": None,\n            \"error\": str(e)\n        }\n\nasync def process_example_entity(entity: Dict[str, Any]) -> None:\n    entity['processed_at'] = datetime.utcnow().isoformat()\n    logger.info(f\"Processed example_entity workflow: {entity}\")\n\n@app.route(\"/entity/<string:entity_name>\", methods=[\"POST\"])\nasync def add_entity(entity_name: str):\n    try:\n        data = await request.get_json()\n        if not isinstance(data, dict):\n            return jsonify({\"error\": \"Invalid JSON data, expected object\"}), 400\n\n        if entity_name.lower() == \"event_detect\":\n            data.setdefault(\"event_id\", f\"{data.get('cat_id', 'unknown')}-{datetime.utcnow().timestamp()}\")\n\n        workflow_func_name = f\"process_{entity_name.lower()}\"\n        workflow_func: Callable[[Dict[str, Any]], Any] = globals().get(workflow_func_name)\n\n        if workflow_func is None:\n            async def noop_workflow(entity: Dict[str, Any]):\n                pass\n            workflow_func = noop_workflow\n\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name.lower(),\n            entity_version=ENTITY_VERSION,\n            entity=data\n        )\n\n        return jsonify({\"status\": \"success\", \"entity_id\": entity_id}), 201\n\n    except Exception as e:\n        logger.exception(f\"Error adding entity '{entity_name}': {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route(\"/events/detect\", methods=[\"POST\"])\n@validate_request(EventDetectRequest)\nasync def detect_event(data: EventDetectRequest):\n    entity_data = {\n        \"cat_id\": data.cat_id,\n        \"input_type\": data.input_type,\n        \"input_data\": data.input_data,\n        \"event_id\": f\"{data.cat_id}-{datetime.utcnow().timestamp()}\"\n    }\n\n    entity_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"event_detect\",\n        entity_version=ENTITY_VERSION,\n        entity=entity_data\n    )\n\n    return jsonify({\"status\": \"success\", \"entity_id\": entity_id}), 200\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}