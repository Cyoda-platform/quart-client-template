{
    "entity_models": [
        {
            "entity_model_name": "pet_fetch_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import httpx\nimport logging\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\n\nPETSTORE_BASE = \"https://petstore3.swagger.io/api/v3\"",
                "content": "async def process_pet_fetch_request(entity: dict):\n    type_filter = entity.get(\"type\")\n    status_filter = entity.get(\"status\") or \"available\"\n\n    url = f\"{PETSTORE_BASE}/pet/findByStatus\"\n    params = {\"status\": status_filter}\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(url, params=params, timeout=10)\n            resp.raise_for_status()\n            pets = resp.json()\n        except Exception as e:\n            logger.exception(f\"Failed fetching pets from Petstore API: {e}\")\n            pets = []\n\n    if type_filter:\n        pets = [pet for pet in pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == type_filter.lower()]\n\n    # Add each pet as a pet entity with workflow process_pet\n    for pet in pets:\n        try:\n            pet_data = pet.copy()\n            pet_data.pop(\"id\", None)\n            # Defensive: ensure pet_data is dict and keys are strings\n            if not isinstance(pet_data, dict):\n                continue\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet\",\n                entity_version=ENTITY_VERSION,\n                entity=pet_data,\n                workflow=process_pet\n            )\n        except Exception as e:\n            logger.exception(f\"Failed to add pet to entity_service: {e}\")\n\n    # Mark the fetch request entity as completed to avoid re-processing\n    entity['fetch_completed'] = True\n",
                "name": "process_pet_fetch_request"
            }
        },
        {
            "entity_model_name": "pet_adoption_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import httpx\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nPETSTORE_BASE = \"https://petstore3.swagger.io/api/v3\"",
                "content": "async def process_pet_adoption_request(entity: dict):\n    pet_id = entity.get(\"pet_id\")\n    if not pet_id:\n        entity[\"adoption_status\"] = \"failed\"\n        entity[\"error\"] = \"No pet_id provided\"\n        return entity\n\n    get_url = f\"{PETSTORE_BASE}/pet/{pet_id}\"\n    update_url = f\"{PETSTORE_BASE}/pet\"\n\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(get_url, timeout=10)\n            resp.raise_for_status()\n            pet = resp.json()\n            if not pet:\n                entity[\"adoption_status\"] = \"failed\"\n                entity[\"error\"] = \"Pet not found\"\n                return entity\n\n            pet[\"status\"] = \"adopted\"\n            resp_update = await client.put(update_url, json=pet, timeout=10)\n            resp_update.raise_for_status()\n\n            entity[\"adoption_status\"] = \"success\"\n\n            # We cannot update pet entity here due to recursion rules,\n            # but we can mark adoption request success.\n            # External process can handle pet entity status update.\n\n        except Exception as e:\n            logger.exception(f\"Failed to adopt pet via external API: {e}\")\n            entity[\"adoption_status\"] = \"failed\"\n            entity[\"error\"] = str(e)\n\n    return entity\n",
                "name": "process_pet_adoption_request"
            }
        },
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "",
                "content": "async def process_pet(entity: dict):\n    # Normalize status to lowercase if present and str\n    if \"status\" in entity and isinstance(entity[\"status\"], str):\n        entity[\"status\"] = entity[\"status\"].lower()\n    # Ensure category name is normalized to lowercase if exists\n    if \"category\" in entity and isinstance(entity[\"category\"], dict):\n        if \"name\" in entity[\"category\"] and isinstance(entity[\"category\"][\"name\"], str):\n            entity[\"category\"][\"name\"] = entity[\"category\"][\"name\"].lower()\n    return entity\n",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom typing import Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\n@dataclass\nclass FetchPetsRequest:\n    type: Optional[str] = None\n    status: Optional[str] = None\n\n@dataclass\nclass AdoptPetRequest:\n    petId: int\n\nPETSTORE_BASE = \"https://petstore3.swagger.io/api/v3\"\n\n\n# Workflow for pet_fetch_request entity:\n# Fetch pets from external API and add each as pet entity.\nasync def process_pet_fetch_request(entity: dict):\n    type_filter = entity.get(\"type\")\n    status_filter = entity.get(\"status\") or \"available\"\n\n    url = f\"{PETSTORE_BASE}/pet/findByStatus\"\n    params = {\"status\": status_filter}\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(url, params=params, timeout=10)\n            resp.raise_for_status()\n            pets = resp.json()\n        except Exception as e:\n            logger.exception(f\"Failed fetching pets from Petstore API: {e}\")\n            pets = []\n\n    if type_filter:\n        pets = [pet for pet in pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == type_filter.lower()]\n\n    # Add each pet as a pet entity with workflow process_pet\n    for pet in pets:\n        try:\n            pet_data = pet.copy()\n            pet_data.pop(\"id\", None)\n            # Defensive: ensure pet_data is dict and keys are strings\n            if not isinstance(pet_data, dict):\n                continue\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet\",\n                entity_version=ENTITY_VERSION,\n                entity=pet_data\n            )\n        except Exception as e:\n            logger.exception(f\"Failed to add pet to entity_service: {e}\")\n\n    # Mark the fetch request entity as completed to avoid re-processing\n    entity['fetch_completed'] = True\n\n\n# Workflow for pet entity:\n# Modify or enrich pet entity before persistence.\nasync def process_pet(entity: dict):\n    # Normalize status to lowercase if present and str\n    if \"status\" in entity and isinstance(entity[\"status\"], str):\n        entity[\"status\"] = entity[\"status\"].lower()\n    # Ensure category name is normalized to lowercase if exists\n    if \"category\" in entity and isinstance(entity[\"category\"], dict):\n        if \"name\" in entity[\"category\"] and isinstance(entity[\"category\"][\"name\"], str):\n            entity[\"category\"][\"name\"] = entity[\"category\"][\"name\"].lower()\n    return entity\n\n\n# Workflow for pet_adoption_request entity:\n# Perform adoption via external API.\nasync def process_pet_adoption_request(entity: dict):\n    pet_id = entity.get(\"pet_id\")\n    if not pet_id:\n        entity[\"adoption_status\"] = \"failed\"\n        entity[\"error\"] = \"No pet_id provided\"\n        return entity\n\n    get_url = f\"{PETSTORE_BASE}/pet/{pet_id}\"\n    update_url = f\"{PETSTORE_BASE}/pet\"\n\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(get_url, timeout=10)\n            resp.raise_for_status()\n            pet = resp.json()\n            if not pet:\n                entity[\"adoption_status\"] = \"failed\"\n                entity[\"error\"] = \"Pet not found\"\n                return entity\n\n            pet[\"status\"] = \"adopted\"\n            resp_update = await client.put(update_url, json=pet, timeout=10)\n            resp_update.raise_for_status()\n\n            entity[\"adoption_status\"] = \"success\"\n\n            # We cannot update pet entity here due to recursion rules,\n            # but we can mark adoption request success.\n            # External process can handle pet entity status update.\n\n        except Exception as e:\n            logger.exception(f\"Failed to adopt pet via external API: {e}\")\n            entity[\"adoption_status\"] = \"failed\"\n            entity[\"error\"] = str(e)\n\n    return entity\n\n\n@app.route(\"/pets/fetch\", methods=[\"POST\"])\n@validate_request(FetchPetsRequest)\nasync def fetch_pets(data: FetchPetsRequest):\n    fetch_request_entity = {\n        \"type\": data.type,\n        \"status\": data.status,\n        \"requested_at\": str(asyncio.get_event_loop().time()),\n        \"fetch_completed\": False,\n    }\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_fetch_request\",\n            entity_version=ENTITY_VERSION,\n            entity=fetch_request_entity\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to create pet_fetch_request entity: {e}\")\n        return jsonify({\"error\": \"Failed to start pet fetch process\"}), 500\n\n    return jsonify({\"message\": \"Pet fetch request accepted. Pets will be fetched and cached asynchronously.\"}), 202\n\n\n@app.route(\"/pets/adopt\", methods=[\"POST\"])\n@validate_request(AdoptPetRequest)\nasync def adopt_pet(data: AdoptPetRequest):\n    pet_id_str = str(data.petId)\n\n    # Check if pet exists\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id_str\n        )\n    except Exception as e:\n        logger.exception(f\"Error retrieving pet from entity_service: {e}\")\n        return jsonify({\"error\": \"Internal server error.\"}), 500\n\n    if not pet:\n        return jsonify({\"error\": f\"Pet with ID {pet_id_str} not found. Please fetch pets first.\"}), 404\n\n    adoption_request_entity = {\n        \"pet_id\": pet_id_str,\n        \"requested_at\": str(asyncio.get_event_loop().time()),\n        \"adoption_status\": \"pending\"\n    }\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_adoption_request\",\n            entity_version=ENTITY_VERSION,\n            entity=adoption_request_entity\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to create pet_adoption_request entity: {e}\")\n        return jsonify({\"error\": \"Failed to start pet adoption process\"}), 500\n\n    return jsonify({\"message\": f\"Adoption request for pet {pet_id_str} accepted.\"}), 202\n\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def get_pets():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        return jsonify({\"pets\": pets})\n    except Exception as e:\n        logger.exception(f\"Failed to get pets from entity_service: {e}\")\n        return jsonify({\"error\": \"Failed to retrieve pets.\"}), 500\n\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def get_pet(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n        if not pet:\n            return jsonify({\"error\": f\"Pet with ID {pet_id} not found.\"}), 404\n        return jsonify(pet)\n    except Exception as e:\n        logger.exception(f\"Failed to get pet from entity_service: {e}\")\n        return jsonify({\"error\": \"Failed to retrieve pet.\"}), 500\n\n\nif __name__ == \"__main__\":\n    import sys\n    logging.basicConfig(\n        stream=sys.stdout,\n        format=\"%(asctime)s %(levelname)s %(name)s - %(message)s\",\n        level=logging.INFO,\n    )\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}