{
    "entity_models": [
        {
            "entity_model_name": "favorite",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport httpx\nimport logging\nlogger = logging.getLogger(__name__)\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"",
                "content": "async def process_favorite(entity_data: dict):\n    \"\"\"\n    Workflow function applied to the 'favorite' entity before persistence.\n    Adds timestamp and enriches entity with pet name & category from Petstore API.\n    \"\"\"\n    # Add timestamp if not present\n    if \"added_at\" not in entity_data:\n        entity_data[\"added_at\"] = datetime.utcnow().isoformat()\n\n    pet_id = entity_data.get(\"pet_id\")\n    if not pet_id:\n        logger.warning(\"Favorite entity missing pet_id, skipping enrichment\")\n        return entity_data\n\n    # Fetch pet info from Petstore API asynchronously\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n            resp = await client.get(url)\n            if resp.status_code == 200:\n                pet = resp.json()\n                entity_data[\"pet_name\"] = pet.get(\"name\")\n                entity_data[\"pet_category\"] = pet.get(\"category\", {}).get(\"name\")\n            else:\n                logger.warning(f\"Failed to fetch pet info for pet_id {pet_id}, status: {resp.status_code}\")\n        except Exception as e:\n            logger.exception(f\"Exception during fetching pet info for pet_id {pet_id}: {e}\")\n\n    return entity_data",
                "name": "process_favorite"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Optional\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass QueryPetsRequest:\n    category: Optional[str]\n    status: Optional[str]\n    sort_by: Optional[str]\n    sort_order: Optional[str]\n    limit: int\n    offset: int\n\n@dataclass\nclass PetIdRequest:\n    pet_id: str  # id is now string per requirements\n\nPET_ENTITY_NAME = \"pet\"\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"\n\nasync def fetch_pets_from_petstore(\n    filters: dict, sort_by: Optional[str], sort_order: Optional[str], limit: int, offset: int\n) -> dict:\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            status = filters.get(\"status\")\n            if status:\n                url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n                params = {\"status\": status}\n                response = await client.get(url, params=params)\n            else:\n                pets = []\n                for s in [\"available\", \"pending\", \"sold\"]:\n                    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n                    r = await client.get(url, params={\"status\": s})\n                    if r.status_code == 200:\n                        pets.extend(r.json())\n                response = None\n            if response and response.status_code == 200:\n                pets = response.json()\n            elif response:\n                logger.error(f\"Petstore API error: {response.status_code} {response.text}\")\n                pets = []\n        except Exception as e:\n            logger.exception(f\"Error fetching pets from Petstore API: {e}\")\n            pets = []\n\n    category_filter = filters.get(\"category\")\n    if category_filter:\n        pets = [\n            pet\n            for pet in pets\n            if pet.get(\"category\") and pet[\"category\"].get(\"name\", \"\").lower() == category_filter.lower()\n        ]\n\n    if sort_by:\n        reverse = sort_order == \"desc\"\n        def sort_key(p):\n            if sort_by == \"category\":\n                return p.get(\"category\", {}).get(\"name\", \"\").lower()\n            return p.get(sort_by, \"\")\n        pets.sort(key=sort_key, reverse=reverse)\n\n    total_count = len(pets)\n    pets = pets[offset : offset + limit]\n\n    result_pets = []\n    for p in pets:\n        result_pets.append(\n            {\n                \"id\": p.get(\"id\"),\n                \"name\": p.get(\"name\"),\n                \"category\": p.get(\"category\", {}).get(\"name\"),\n                \"status\": p.get(\"status\"),\n                \"photoUrls\": p.get(\"photoUrls\", []),\n                \"tags\": [t[\"name\"] for t in p.get(\"tags\", []) if \"name\" in t],\n            }\n        )\n\n    return {\"pets\": result_pets, \"total_count\": total_count}\n\n@app.route(\"/pets/query\", methods=[\"POST\"])\n@validate_request(QueryPetsRequest)\nasync def pets_query(data: QueryPetsRequest):\n    filters = {}\n    if data.category:\n        filters[\"category\"] = data.category\n    if data.status:\n        filters[\"status\"] = data.status\n    pets_data = await fetch_pets_from_petstore(\n        filters, data.sort_by, data.sort_order, data.limit, data.offset\n    )\n    return jsonify(pets_data)\n\ndef get_user_id() -> str:\n    # Placeholder for actual auth logic\n    return \"default_user\"\n\n# Workflow function for \"favorite\" entity\nasync def process_favorite(entity_data: dict):\n    \"\"\"\n    Workflow function applied to the 'favorite' entity before persistence.\n    Adds timestamp and enriches entity with pet name & category from Petstore API.\n    \"\"\"\n    # Add timestamp if not present\n    if \"added_at\" not in entity_data:\n        entity_data[\"added_at\"] = datetime.utcnow().isoformat()\n\n    pet_id = entity_data.get(\"pet_id\")\n    if not pet_id:\n        logger.warning(\"Favorite entity missing pet_id, skipping enrichment\")\n        return entity_data\n\n    # Fetch pet info from Petstore API asynchronously\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n            resp = await client.get(url)\n            if resp.status_code == 200:\n                pet = resp.json()\n                entity_data[\"pet_name\"] = pet.get(\"name\")\n                entity_data[\"pet_category\"] = pet.get(\"category\", {}).get(\"name\")\n            else:\n                logger.warning(f\"Failed to fetch pet info for pet_id {pet_id}, status: {resp.status_code}\")\n        except Exception as e:\n            logger.exception(f\"Exception during fetching pet info for pet_id {pet_id}: {e}\")\n\n    return entity_data\n\n@app.route(\"/favorites/add\", methods=[\"POST\"])\n@validate_request(PetIdRequest)\nasync def favorites_add(data: PetIdRequest):\n    pet_id = str(data.pet_id)\n    user_id = get_user_id()\n    favorite_data = {\n        \"user_id\": user_id,\n        \"pet_id\": pet_id,\n    }\n    try:\n        new_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"favorite\",\n            entity_version=ENTITY_VERSION,\n            entity=favorite_data\n        )\n        logger.info(f\"User {user_id} added pet {pet_id} to favorites with id {new_id}\")\n        return jsonify({\"success\": True, \"message\": \"Pet added to favorites.\", \"id\": new_id})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Failed to add favorite.\"}), 500\n\n@app.route(\"/favorites/remove\", methods=[\"POST\"])\n@validate_request(PetIdRequest)\nasync def favorites_remove(data: PetIdRequest):\n    pet_id = str(data.pet_id)\n    user_id = get_user_id()\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.user_id\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": user_id,\n                    \"type\": \"simple\",\n                },\n                {\n                    \"jsonPath\": \"$.pet_id\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": pet_id,\n                    \"type\": \"simple\",\n                },\n            ],\n        }\n    }\n    try:\n        favorites = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"favorite\",\n            entity_version=ENTITY_VERSION,\n            condition=condition,\n        )\n        if not favorites:\n            return jsonify({\"success\": False, \"message\": \"Pet not in favorites\"}), 400\n        for fav in favorites:\n            fav_id = str(fav.get(\"id\"))\n            await entity_service.delete_item(\n                token=cyoda_auth_service,\n                entity_model=\"favorite\",\n                entity_version=ENTITY_VERSION,\n                technical_id=fav_id,\n                meta={},\n            )\n        logger.info(f\"User {user_id} removed pet {pet_id} from favorites\")\n        return jsonify({\"success\": True, \"message\": \"Pet removed from favorites.\"})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Failed to remove favorite.\"}), 500\n\n@app.route(\"/favorites\", methods=[\"GET\"])\nasync def favorites_list():\n    user_id = get_user_id()\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.user_id\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": user_id,\n                    \"type\": \"simple\",\n                }\n            ],\n        }\n    }\n    try:\n        favorites = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"favorite\",\n            entity_version=ENTITY_VERSION,\n            condition=condition,\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"favorites\": []})\n\n    pet_ids = [str(fav.get(\"pet_id\")) for fav in favorites if fav.get(\"pet_id\")]\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        async def fetch_pet(pet_id: str):\n            try:\n                url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n                r = await client.get(url)\n                if r.status_code == 200:\n                    p = r.json()\n                    return {\n                        \"id\": p.get(\"id\"),\n                        \"name\": p.get(\"name\"),\n                        \"category\": p.get(\"category\", {}).get(\"name\"),\n                        \"status\": p.get(\"status\"),\n                        \"photoUrls\": p.get(\"photoUrls\", []),\n                    }\n                else:\n                    logger.warning(f\"Petstore API returned {r.status_code} for pet {pet_id}\")\n                    return None\n            except Exception as e:\n                logger.exception(f\"Error fetching pet {pet_id} details: {e}\")\n                return None\n\n        pet_details_results = await asyncio.gather(*[fetch_pet(pid) for pid in pet_ids])\n        favorites_pets = [pet for pet in pet_details_results if pet is not None]\n\n    return jsonify({\"favorites\": favorites_pets})\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}