{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom dataclasses import dataclass\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION",
                "content": "async def process_pet(entity: dict) -> dict:\n    # Add a timestamp for when the pet was processed\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n    # Potential place for other enrichment or async tasks related to pet entity\n    # Do not call entity_service.add/update/delete on \"pet\" here to avoid recursion\n    return entity",
                "name": "process_pet"
            }
        },
        {
            "entity_model_name": "favorite_pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom dataclasses import dataclass\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION",
                "content": "async def process_favorite_pet(entity: dict) -> dict:\n    # Fire and forget trigger event for pet_favorite\n    asyncio.create_task(trigger_event_workflow(\"pet_favorite\", {\"petId\": entity.get(\"petId\")}))\n    return entity",
                "name": "process_favorite_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom dataclasses import dataclass\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass PetQuery:\n    type: Optional[str]\n    status: Optional[str]\n\n@dataclass\nclass FavoritePet:\n    petId: int\n\nentity_jobs: Dict[str, dict] = {}\nentity_jobs_lock = asyncio.Lock()\n\nPETSTORE_BASE_URL = \"https://petstore.swagger.io/v2\"\n\nasync def fetch_pets_from_petstore(\n    type_filter: Optional[str] = None, status_filter: Optional[str] = None\n) -> List[dict]:\n    statuses = [status_filter] if status_filter else [\"available\"]\n    pets: List[dict] = []\n    async with httpx.AsyncClient(timeout=10) as client:\n        for status in statuses:\n            try:\n                resp = await client.get(\n                    f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params={\"status\": status}\n                )\n                resp.raise_for_status()\n                data = resp.json()\n                if isinstance(data, list):\n                    pets.extend(data)\n            except httpx.HTTPError as e:\n                logger.exception(f\"Failed to fetch pets by status '{status}': {e}\")\n    if type_filter:\n        pets = [pet for pet in pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == type_filter.lower()]\n    return pets\n\nasync def trigger_event_workflow(event_type: str, payload: dict):\n    job_id = f\"{event_type}_{datetime.utcnow().isoformat()}\"\n    async with entity_jobs_lock:\n        entity_jobs[job_id] = {\"status\": \"processing\", \"requestedAt\": datetime.utcnow().isoformat(), \"payload\": payload}\n    logger.info(f\"Event triggered: {event_type}, job id: {job_id}\")\n    asyncio.create_task(process_event_job(job_id))\n\nasync def process_event_job(job_id: str):\n    try:\n        await asyncio.sleep(0.5)\n        async with entity_jobs_lock:\n            if job_id in entity_jobs:\n                entity_jobs[job_id][\"status\"] = \"done\"\n                logger.info(f\"Event job {job_id} done.\")\n    except Exception as e:\n        logger.exception(f\"Error processing event job {job_id}: {e}\")\n\nasync def process_pet(entity: dict) -> dict:\n    # Add a timestamp for when the pet was processed\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n    # Potential place for other enrichment or async tasks related to pet entity\n    # Do not call entity_service.add/update/delete on \"pet\" here to avoid recursion\n    return entity\n\nasync def process_favorite_pet(entity: dict) -> dict:\n    # Fire and forget trigger event for pet_favorite\n    asyncio.create_task(trigger_event_workflow(\"pet_favorite\", {\"petId\": entity.get(\"petId\")}))\n    return entity\n\n@app.route(\"/pets/query\", methods=[\"POST\"])\n@validate_request(PetQuery)\nasync def pets_query(data: PetQuery):\n    try:\n        pets = await fetch_pets_from_petstore(data.type, data.status)\n        # Add pets to entity_service, one by one, applying process_pet workflow\n        for pet in pets:\n            try:\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet\",\n                    entity_version=ENTITY_VERSION,\n                    entity=pet\n                )\n            except Exception as e:\n                logger.exception(f\"Failed to add pet to entity_service: {e}\")\n        # Trigger event related to the whole query (cannot move into workflow since workflow is per entity)\n        await trigger_event_workflow(\"pet_query\", {\"type\": data.type, \"status\": data.status, \"resultCount\": len(pets)})\n        return jsonify({\"pets\": pets})\n    except Exception as e:\n        logger.exception(\"Error in /pets/query\")\n        return jsonify({\"error\": \"Failed to query pets\"}), 500\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def pets_get():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        return jsonify({\"pets\": pets})\n    except Exception as e:\n        logger.exception(\"Error in /pets GET\")\n        return jsonify({\"error\": \"Failed to get pets\"}), 500\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def pet_get(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id,\n        )\n        if pet is None:\n            return jsonify({\"error\": \"Pet not found\"}), 404\n        return jsonify(pet)\n    except Exception as e:\n        logger.exception(f\"Error in /pets/{pet_id} GET\")\n        return jsonify({\"error\": \"Failed to get pet\"}), 500\n\n@app.route(\"/pets/favorite\", methods=[\"POST\"])\n@validate_request(FavoritePet)\nasync def pets_favorite(data: FavoritePet):\n    try:\n        pet_id_str = str(data.petId)\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id_str,\n        )\n        if pet is None:\n            return jsonify({\"error\": \"Pet not found\"}), 404\n        try:\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"favorite_pet\",\n                entity_version=ENTITY_VERSION,\n                entity={\"petId\": pet_id_str}\n            )\n        except Exception as e:\n            logger.exception(f\"Failed to add favorite pet: {e}\")\n            return jsonify({\"error\": \"Failed to mark pet as favorite\"}), 500\n        return jsonify({\"message\": \"Pet marked as favorite\", \"petId\": pet_id_str})\n    except Exception as e:\n        logger.exception(\"Error in /pets/favorite\")\n        return jsonify({\"error\": \"Failed to mark pet as favorite\"}), 500\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}