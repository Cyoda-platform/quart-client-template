{
    "entity_models": [
        {
            "entity_model_name": "process_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport uuid",
                "content": "async def process_process_request(entity):\n    # Mark as processing with timestamp\n    entity.setdefault(\"status\", \"processing\")\n    entity.setdefault(\"createdAt\", datetime.utcnow().isoformat() + \"Z\")\n    # Generate and attach a correlation id for debugging/tracking\n    entity[\"tempCorrelationId\"] = str(uuid.uuid4())\n    # Cannot launch background task here with final id since it's unknown before persistence\n    # So just prepare entity state here\n    return entity",
                "name": "process_process_request"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nimport uuid\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass ProcessRequest:\n    inputData: dict\n\nasync def fetch_external_data():\n    headers = {\"Accept\": \"application/json\"}\n    async with httpx.AsyncClient(timeout=10) as client:\n        response = await client.get(\"https://icanhazdadjoke.com/\", headers=headers)\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"joke\", \"No joke found\")\n\nasync def process_entity(process_id, input_data):\n    try:\n        logger.info(f\"Processing job {process_id} with input: {input_data}\")\n\n        external_info = await fetch_external_data()\n\n        result_data = {\n            \"inputReceived\": input_data,\n            \"externalInfo\": external_info,\n            \"processedAt\": datetime.utcnow().isoformat() + \"Z\"\n        }\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"process_request\",\n            entity_version=ENTITY_VERSION,\n            entity={\n                \"status\": \"completed\",\n                \"resultData\": result_data,\n                \"completedAt\": datetime.utcnow().isoformat() + \"Z\"\n            },\n            technical_id=process_id,\n            meta={}\n        )\n        logger.info(f\"Job {process_id} completed successfully\")\n\n    except Exception as e:\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"process_request\",\n            entity_version=ENTITY_VERSION,\n            entity={\n                \"status\": \"failed\",\n                \"error\": str(e),\n                \"completedAt\": datetime.utcnow().isoformat() + \"Z\"\n            },\n            technical_id=process_id,\n            meta={}\n        )\n        logger.exception(f\"Job {process_id} failed during processing\")\n\nasync def process_process_request(entity):\n    # Mark as processing with timestamp\n    entity.setdefault(\"status\", \"processing\")\n    entity.setdefault(\"createdAt\", datetime.utcnow().isoformat() + \"Z\")\n    # Generate and attach a correlation id for debugging/tracking\n    entity[\"tempCorrelationId\"] = str(uuid.uuid4())\n    # Cannot launch background task here with final id since it's unknown before persistence\n    # So just prepare entity state here\n    return entity\n\n@app.route('/process', methods=['POST'])\n@validate_request(ProcessRequest)\nasync def process(data: ProcessRequest):\n    input_data = data.inputData\n    try:\n        # Add item with workflow function which sets initial state\n        process_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"process_request\",\n            entity_version=ENTITY_VERSION,\n            entity=input_data\n        )\n        # Launch background async processing with known id\n        asyncio.create_task(process_entity(process_id, input_data))\n        return jsonify({\n            \"processId\": process_id,\n            \"status\": \"processing\"\n        }), 202\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to create process\"}), 500\n\n@app.route('/result/<string:process_id>', methods=['GET'])\nasync def get_result(process_id):\n    try:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"process_request\",\n            entity_version=ENTITY_VERSION,\n            technical_id=process_id\n        )\n        if not job:\n            return jsonify({\"error\": \"processId not found\"}), 404\n        response = {\n            \"processId\": process_id,\n            \"status\": job.get(\"status\", \"unknown\"),\n            \"resultData\": job.get(\"resultData\")\n        }\n        if job.get(\"status\") == \"failed\":\n            response[\"error\"] = job.get(\"error\")\n        return jsonify(response)\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve process result\"}), 500\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}