{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n",
                "content": "async def process_pet(entity: dict) -> dict:\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n    logger.info(f\"Workflow process_pet: processing pet '{entity.get('name')}'\")\n    return entity",
                "name": "process_pet"
            }
        },
        {
            "entity_model_name": "pet_fetch_job",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nPET_ENTITY_NAME = \"pet\"\nPET_FETCH_JOB_ENTITY_NAME = \"pet_fetch_job\"\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"\n\nasync def fetch_pets_from_petstore(type_: Optional[str], status: Optional[str]) -> list:\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            params = {}\n            if status:\n                params[\"status\"] = status\n            response = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params=params)\n            response.raise_for_status()\n            pets = response.json()\n            if type_:\n                pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == type_.lower()]\n            return pets\n        except (httpx.RequestError, httpx.HTTPStatusError) as e:\n            logger.exception(f\"Error fetching pets from Petstore API: {e}\")\n            return []\n\n",
                "content": "async def process_pet_fetch_job(entity: dict) -> dict:\n    job_id = entity.get(\"id\")\n    type_ = entity.get(\"type\")\n    status_filter = entity.get(\"statusFilter\")\n\n    logger.info(f\"Workflow process_pet_fetch_job: Starting fetch job {job_id} with type={type_} status={status_filter}\")\n\n    try:\n        pets = await fetch_pets_from_petstore(type_, status_filter)\n        logger.info(f\"Fetched {len(pets)} pets from external API for job {job_id}\")\n\n        for pet in pets:\n            pet_data = pet.copy()\n            pet_data.pop(\"id\", None)\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                entity=pet_data,\n                workflow=process_pet\n            )\n\n        updated_entity = entity.copy()\n        updated_entity[\"status\"] = \"completed\"\n        updated_entity[\"completedAt\"] = datetime.utcnow().isoformat()\n        updated_entity[\"count\"] = len(pets)\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_FETCH_JOB_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            technical_id=job_id,\n            entity=updated_entity\n        )\n        logger.info(f\"Fetch job {job_id} completed successfully\")\n    except Exception as e:\n        logger.exception(f\"Fetch job {job_id} failed: {e}\")\n        updated_entity = entity.copy()\n        updated_entity[\"status\"] = \"failed\"\n        updated_entity[\"error\"] = str(e)\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=PET_FETCH_JOB_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                technical_id=job_id,\n                entity=updated_entity\n            )\n        except Exception as inner_e:\n            logger.exception(f\"Failed to update failed job status for job {job_id}: {inner_e}\")\n    return entity",
                "name": "process_pet_fetch_job"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass FetchPetsRequest:\n    type: Optional[str] = None\n    status: Optional[str] = None\n\n@dataclass\nclass GetPetsQuery:\n    type: Optional[str] = None\n    status: Optional[str] = None\n\n@dataclass\nclass FunFactRequest:\n    category: Optional[str] = None\n\nPET_ENTITY_NAME = \"pet\"\nPET_FETCH_JOB_ENTITY_NAME = \"pet_fetch_job\"\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"\n\nFUN_PET_FACTS = [\n    \"Cats sleep for 70% of their lives!\",\n    \"Dogs have three eyelids.\",\n    \"Rabbits can't vomit.\",\n    \"Goldfish can see both infrared and ultraviolet light.\",\n    \"Parrots will selflessly help each other out.\",\n]\n\nasync def fetch_pets_from_petstore(type_: Optional[str], status: Optional[str]) -> list:\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            params = {}\n            if status:\n                params[\"status\"] = status\n            response = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params=params)\n            response.raise_for_status()\n            pets = response.json()\n            if type_:\n                pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == type_.lower()]\n            return pets\n        except (httpx.RequestError, httpx.HTTPStatusError) as e:\n            logger.exception(f\"Error fetching pets from Petstore API: {e}\")\n            return []\n\nasync def process_pet(entity: dict) -> dict:\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n    logger.info(f\"Workflow process_pet: processing pet '{entity.get('name')}'\")\n    return entity\n\nasync def process_pet_fetch_job(entity: dict) -> dict:\n    job_id = entity.get(\"id\")\n    type_ = entity.get(\"type\")\n    status_filter = entity.get(\"statusFilter\")\n\n    logger.info(f\"Workflow process_pet_fetch_job: Starting fetch job {job_id} with type={type_} status={status_filter}\")\n\n    try:\n        pets = await fetch_pets_from_petstore(type_, status_filter)\n        logger.info(f\"Fetched {len(pets)} pets from external API for job {job_id}\")\n\n        for pet in pets:\n            pet_data = pet.copy()\n            pet_data.pop(\"id\", None)\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                entity=pet_data\n            )\n\n        updated_entity = entity.copy()\n        updated_entity[\"status\"] = \"completed\"\n        updated_entity[\"completedAt\"] = datetime.utcnow().isoformat()\n        updated_entity[\"count\"] = len(pets)\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_FETCH_JOB_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            technical_id=job_id,\n            entity=updated_entity\n        )\n        logger.info(f\"Fetch job {job_id} completed successfully\")\n    except Exception as e:\n        logger.exception(f\"Fetch job {job_id} failed: {e}\")\n        updated_entity = entity.copy()\n        updated_entity[\"status\"] = \"failed\"\n        updated_entity[\"error\"] = str(e)\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=PET_FETCH_JOB_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                technical_id=job_id,\n                entity=updated_entity\n            )\n        except Exception as inner_e:\n            logger.exception(f\"Failed to update failed job status for job {job_id}: {inner_e}\")\n    return entity\n\n@app.route(\"/pets/fetch\", methods=[\"POST\"])\n@validate_request(FetchPetsRequest)\nasync def pets_fetch(data: FetchPetsRequest):\n    job_entity = {\n        \"requestedAt\": datetime.utcnow().isoformat(),\n        \"status\": \"processing\",\n        \"type\": data.type,\n        \"statusFilter\": data.status\n    }\n    job_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=PET_FETCH_JOB_ENTITY_NAME,\n        entity_version=ENTITY_VERSION,\n        entity=job_entity\n    )\n    logger.info(f\"Created pet fetch job entity with id {job_id}\")\n    return jsonify({\"message\": \"Pets fetch started\", \"jobId\": job_id}), 202\n\n@validate_querystring(GetPetsQuery)\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def pets_list():\n    args = request.args\n    type_filter = args.get(\"type\")\n    status_filter = args.get(\"status\")\n\n    conditions_list = []\n    if type_filter:\n        conditions_list.append({\n            \"jsonPath\": \"$.category.name\",\n            \"operatorType\": \"IEQUALS\",\n            \"value\": type_filter,\n            \"type\": \"simple\"\n        })\n    if status_filter:\n        conditions_list.append({\n            \"jsonPath\": \"$.status\",\n            \"operatorType\": \"EQUALS\",\n            \"value\": status_filter,\n            \"type\": \"simple\"\n        })\n    condition = None\n    if conditions_list:\n        condition = {\n            \"cyoda\": {\n                \"type\": \"group\",\n                \"operator\": \"AND\",\n                \"conditions\": conditions_list\n            }\n        }\n\n    try:\n        if condition:\n            pets = await entity_service.get_items_by_condition(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                condition=condition\n            )\n        else:\n            pets = await entity_service.get_items(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n            )\n    except Exception as e:\n        logger.exception(f\"Failed to retrieve pets: {e}\")\n        return jsonify({\"error\": \"Failed to retrieve pets\"}), 500\n\n    pets_simple = [\n        {\n            \"id\": p.get(\"id\"),\n            \"name\": p.get(\"name\"),\n            \"type\": p.get(\"category\", {}).get(\"name\") if p.get(\"category\") else None,\n            \"status\": p.get(\"status\"),\n        }\n        for p in pets\n    ]\n    return jsonify(pets_simple)\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def pet_detail(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to retrieve pet {pet_id}: {e}\")\n        return jsonify({\"error\": \"Failed to retrieve pet\"}), 500\n\n    if not pet:\n        return jsonify({\"error\": \"Pet not found\"}), 404\n    pet_detail_response = {\n        \"id\": pet.get(\"id\"),\n        \"name\": pet.get(\"name\"),\n        \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n        \"status\": pet.get(\"status\"),\n        \"photoUrls\": pet.get(\"photoUrls\", []),\n        \"tags\": [tag.get(\"name\") for tag in pet.get(\"tags\", []) if \"name\" in tag],\n    }\n    return jsonify(pet_detail_response)\n\n@app.route(\"/fun/random-fact\", methods=[\"POST\"])\n@validate_request(FunFactRequest)\nasync def fun_random_fact(data: FunFactRequest):\n    import random\n    fact = random.choice(FUN_PET_FACTS)\n    return jsonify({\"fact\": fact})\n\nif __name__ == \"__main__\":\n    import sys\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        stream=sys.stdout,\n    )\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}