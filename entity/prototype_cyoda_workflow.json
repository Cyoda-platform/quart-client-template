{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nfrom typing import Dict, Any\nimport asyncio\n\nclass AppState:\n    def __init__(self):\n        self._lock = asyncio.Lock()\n        self.adopted_pet_ids: set[str] = set()\n\n    async def is_adopted(self, pet_id: str) -> bool:\n        async with self._lock:\n            return pet_id in self.adopted_pet_ids\n\napp_state = AppState()",
                "content": "async def process_pet(entity: Dict[str, Any]) -> Dict[str, Any]:\n    # Add last processed timestamp\n    entity['last_processed'] = datetime.utcnow().isoformat() + 'Z'\n\n    # Add or update description\n    name = entity.get(\"name\") or \"Unknown\"\n    pet_type = entity.get(\"type\") or \"pet\"\n    entity['description'] = f\"{name} is a lovely {pet_type}.\"\n\n    # Add adopted flag asynchronously\n    pet_id = entity.get(\"id\")\n    adopted = False\n    if pet_id is not None:\n        adopted = await app_state.is_adopted(str(pet_id))\n    entity['adopted'] = adopted\n\n    return entity",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom quart import Quart, jsonify, request, abort\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SearchPets:\n    type: Optional[str]\n    status: Optional[str]\n    name: Optional[str]\n\n@dataclass\nclass AdoptPet:\n    petId: int\n\nclass AppState:\n    def __init__(self):\n        self._lock = asyncio.Lock()\n        self.adopted_pet_ids: set[str] = set()\n\n    async def mark_adopted(self, pet_id: str):\n        async with self._lock:\n            self.adopted_pet_ids.add(pet_id)\n\n    async def is_adopted(self, pet_id: str) -> bool:\n        async with self._lock:\n            return pet_id in self.adopted_pet_ids\n\napp_state = AppState()\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"\n\nasync def process_pet(entity: Dict[str, Any]) -> Dict[str, Any]:\n    # Add last processed timestamp\n    entity['last_processed'] = datetime.utcnow().isoformat() + 'Z'\n\n    # Add or update description\n    name = entity.get(\"name\") or \"Unknown\"\n    pet_type = entity.get(\"type\") or \"pet\"\n    entity['description'] = f\"{name} is a lovely {pet_type}.\"\n\n    # Add adopted flag asynchronously\n    pet_id = entity.get(\"id\")\n    adopted = False\n    if pet_id is not None:\n        adopted = await app_state.is_adopted(str(pet_id))\n    entity['adopted'] = adopted\n\n    return entity\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchPets)\nasync def pets_search(data: SearchPets):\n    pet_type = data.type\n    status = data.status\n    name_filter = data.name\n\n    query_statuses = [status] if status else [\"available\"]\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        all_pets = []\n        for st in query_statuses:\n            try:\n                r = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params={\"status\": st})\n                r.raise_for_status()\n                pets_data = r.json()\n                all_pets.extend(pets_data)\n            except Exception as e:\n                logger.exception(f\"Error fetching pets by status={st}: {e}\")\n\n    if pet_type:\n        pet_type_lower = pet_type.lower()\n        all_pets = [pet for pet in all_pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == pet_type_lower]\n    if name_filter:\n        name_filter_lower = name_filter.lower()\n        all_pets = [pet for pet in all_pets if pet.get(\"name\") and name_filter_lower in pet[\"name\"].lower()]\n\n    for pet in all_pets:\n        pet_id = pet.get(\"id\")\n        if pet_id is None:\n            continue\n\n        entity_pet = {\n            \"id\": str(pet_id),\n            \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n            \"name\": pet.get(\"name\"),\n            \"status\": pet.get(\"status\"),\n            \"photoUrls\": pet.get(\"photoUrls\", []),\n        }\n\n        try:\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet\",\n                entity_version=ENTITY_VERSION,\n                entity=entity_pet\n            )\n            logger.info(f\"Added/Updated pet with id {pet_id} in entity service\")\n        except Exception as e:\n            logger.exception(f\"Error syncing pet id={pet_id} to entity_service: {e}\")\n\n    return jsonify({\"results\": all_pets})\n\n@app.route(\"/pets/adopt\", methods=[\"POST\"])\n@validate_request(AdoptPet)\nasync def pets_adopt(data: AdoptPet):\n    pet_id_int = data.petId\n    if not isinstance(pet_id_int, int):\n        abort(400, \"petId must be an integer\")\n\n    pet_id = str(pet_id_int)\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n    except Exception as e:\n        logger.exception(e)\n        abort(404, f\"Pet with id {pet_id} not found in entity service. Please search first.\")\n\n    if pet is None:\n        abort(404, f\"Pet with id {pet_id} not found in entity service. Please search first.\")\n\n    await app_state.mark_adopted(pet_id)\n\n    return jsonify({\n        \"adopted\": True,\n        \"petId\": pet_id_int,\n        \"message\": f\"Congratulations! You have adopted {pet.get('name')}.\"\n    })\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def pets_list():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception as e:\n        logger.exception(e)\n        pets = []\n    return jsonify({\"pets\": pets})\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def pet_detail(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n    except Exception as e:\n        logger.exception(e)\n        abort(404, f\"Pet with id {pet_id} not found in entity service.\")\n\n    if pet is None:\n        abort(404, f\"Pet with id {pet_id} not found in entity service.\")\n    return jsonify(pet)\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"PUT\"])\nasync def pet_update(pet_id: str):\n    data = await request.get_json()\n    if not data:\n        abort(400, \"Missing JSON data\")\n\n    try:\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=data,\n            technical_id=pet_id,\n            meta={}\n        )\n    except Exception as e:\n        logger.exception(e)\n        abort(404, f\"Pet with id {pet_id} not found or could not be updated.\")\n\n    return jsonify({\"updated\": True, \"petId\": pet_id})\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"DELETE\"])\nasync def pet_delete(pet_id: str):\n    try:\n        await entity_service.delete_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id,\n            meta={}\n        )\n    except Exception as e:\n        logger.exception(e)\n        abort(404, f\"Pet with id {pet_id} not found or could not be deleted.\")\n\n    return jsonify({\"deleted\": True, \"petId\": pet_id})\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO,\n                        format=\"%(asctime)s %(levelname)s %(name)s - %(message)s\")\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}