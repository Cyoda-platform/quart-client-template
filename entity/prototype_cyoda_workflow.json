{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from dataclasses import dataclass\nfrom typing import Optional, List, Dict\nimport asyncio\nimport logging\n\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\nfavorites_lock = asyncio.Lock()\nfavorites_cache: Dict[str, dict] = {}",
                "content": "async def process_pet(entity: dict):\n    # Set default status if missing\n    if not entity.get(\"status\"):\n        entity[\"status\"] = \"available\"\n    # Ensure category is a dict with id and name defaults\n    category = entity.get(\"category\")\n    if not category or not isinstance(category, dict):\n        entity[\"category\"] = {\"id\": 0, \"name\": \"\"}\n    else:\n        if \"name\" not in category or category[\"name\"] is None:\n            category[\"name\"] = \"\"\n        if \"id\" not in category or category[\"id\"] is None:\n            category[\"id\"] = 0\n        entity[\"category\"] = category\n    # Return entity is optional, but included for clarity\n    return entity",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nfrom typing import Optional, List, Dict\nimport asyncio\nimport logging\n\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\nfavorites_lock = asyncio.Lock()\nfavorites_cache: Dict[str, dict] = {}\n\n@dataclass\nclass PetSearch:\n    status: Optional[str]\n    type: Optional[str]\n\n@dataclass\nclass PetAdd:\n    name: str\n    type: str\n    status: Optional[str]  # optional, workflow will set default if missing\n    photoUrls: List[str]\n\n@dataclass\nclass PetUpdate:\n    id: str  # id is now string\n    name: Optional[str]\n    status: Optional[str]\n    photoUrls: Optional[List[str]]\n    type: Optional[str]\n\n@dataclass\nclass PetId:\n    id: str  # id is now string\n\n# Workflow function for 'pet' entity on add\nasync def process_pet(entity: dict):\n    # Set default status if missing\n    if not entity.get(\"status\"):\n        entity[\"status\"] = \"available\"\n    # Ensure category is a dict with id and name defaults\n    category = entity.get(\"category\")\n    if not category or not isinstance(category, dict):\n        entity[\"category\"] = {\"id\": 0, \"name\": \"\"}\n    else:\n        if \"name\" not in category or category[\"name\"] is None:\n            category[\"name\"] = \"\"\n        if \"id\" not in category or category[\"id\"] is None:\n            category[\"id\"] = 0\n        entity[\"category\"] = category\n    # Return entity is optional, but included for clarity\n    return entity\n\n# Workflow function for 'pet' entity on update\nasync def process_pet_update(entity: dict, update_data: dict):\n    # Apply partial updates to entity dict safely\n    if update_data.get(\"name\") is not None:\n        entity[\"name\"] = update_data[\"name\"]\n    if update_data.get(\"status\") is not None:\n        entity[\"status\"] = update_data[\"status\"]\n    if update_data.get(\"photoUrls\") is not None:\n        # Defensive: ensure list type for photoUrls\n        if isinstance(update_data[\"photoUrls\"], list):\n            entity[\"photoUrls\"] = update_data[\"photoUrls\"]\n    if update_data.get(\"type\") is not None:\n        entity[\"category\"] = {\"id\": 0, \"name\": update_data[\"type\"]}\n    return entity\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(PetSearch)\nasync def pets_search(data: PetSearch):\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": []\n        }\n    }\n    if data.status is not None:\n        condition[\"cyoda\"][\"conditions\"].append({\n            \"jsonPath\": \"$.status\",\n            \"operatorType\": \"EQUALS\",\n            \"value\": data.status,\n            \"type\": \"simple\"\n        })\n    if data.type is not None:\n        condition[\"cyoda\"][\"conditions\"].append({\n            \"jsonPath\": \"$.category.name\",\n            \"operatorType\": \"IEQUALS\",\n            \"value\": data.type,\n            \"type\": \"simple\"\n        })\n\n    try:\n        pets = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n    except Exception as e:\n        logger.exception(f\"Error fetching pets: {e}\")\n        pets = []\n\n    result = []\n    for pet in pets:\n        result.append({\n            \"id\": pet.get(\"technical_id\") or pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\", \"\"),\n            \"status\": pet.get(\"status\"),\n            \"photoUrls\": pet.get(\"photoUrls\", [])\n        })\n    return jsonify({\"pets\": result})\n\n@app.route(\"/pets/add\", methods=[\"POST\"])\n@validate_request(PetAdd)\nasync def pets_add(data: PetAdd):\n    pet_payload = {\n        \"name\": data.name,\n        \"photoUrls\": data.photoUrls,\n        \"status\": data.status,\n        \"category\": {\"id\": 0, \"name\": data.type},\n    }\n    try:\n        pet_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=pet_payload\n        )\n    except Exception as e:\n        logger.exception(f\"Error adding pet: {e}\")\n        return jsonify({\"success\": False}), 500\n    return jsonify({\"success\": True, \"petId\": str(pet_id)})\n\n@app.route(\"/pets/update\", methods=[\"POST\"])\n@validate_request(PetUpdate)\nasync def pets_update(data: PetUpdate):\n    if not data.id:\n        return jsonify({\"success\": False, \"error\": \"Missing pet id\"}), 400\n\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=data.id\n        )\n    except Exception as e:\n        logger.exception(f\"Error fetching pet: {e}\")\n        return jsonify({\"success\": False, \"error\": \"Pet not found\"}), 404\n\n    try:\n        # Apply workflow update logic\n        pet = await process_pet_update(pet, data.__dict__)\n    except Exception as e:\n        logger.exception(f\"Error processing pet update workflow: {e}\")\n        return jsonify({\"success\": False, \"error\": \"Update processing failed\"}), 500\n\n    try:\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=pet,\n            technical_id=data.id,\n            meta={}\n        )\n    except Exception as e:\n        logger.exception(f\"Error updating pet: {e}\")\n        return jsonify({\"success\": False}), 500\n\n    return jsonify({\"success\": True})\n\n@app.route(\"/pets/delete\", methods=[\"POST\"])\n@validate_request(PetId)\nasync def pets_delete(data: PetId):\n    try:\n        await entity_service.delete_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=data.id,\n            meta={}\n        )\n    except Exception as e:\n        logger.exception(f\"Error deleting pet: {e}\")\n        return jsonify({\"success\": False}), 500\n\n    async with favorites_lock:\n        favorites_cache.pop(data.id, None)\n\n    return jsonify({\"success\": True})\n\n@app.route(\"/pets/favorites\", methods=[\"GET\"])\nasync def pets_favorites():\n    async with favorites_lock:\n        favs = list(favorites_cache.values())\n    return jsonify({\"favorites\": favs})\n\n@app.route(\"/pets/favorites/add\", methods=[\"POST\"])\n@validate_request(PetId)\nasync def pets_favorites_add(data: PetId):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=data.id\n        )\n    except Exception as e:\n        logger.exception(f\"Error fetching pet: {e}\")\n        return jsonify({\"success\": False, \"error\": \"Pet not found\"}), 404\n\n    pet_fav = {\n        \"id\": data.id,\n        \"name\": pet.get(\"name\"),\n        \"type\": pet.get(\"category\", {}).get(\"name\", \"\"),\n        \"status\": pet.get(\"status\")\n    }\n\n    async with favorites_lock:\n        favorites_cache[data.id] = pet_fav\n\n    return jsonify({\"success\": True})\n\n@app.route(\"/pets/favorites/remove\", methods=[\"POST\"])\n@validate_request(PetId)\nasync def pets_favorites_remove(data: PetId):\n    async with favorites_lock:\n        favorites_cache.pop(data.id, None)\n    return jsonify({\"success\": True})\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}