{
    "entity_models": [
        {
            "entity_model_name": "notification",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import datetime",
                "content": "async def process_notification(entity: dict) -> None:\n    if \"timestamp\" not in entity:\n        entity[\"timestamp\"] = datetime.datetime.utcnow().isoformat() + \"Z\"\n    entity.setdefault(\"priority\", \"normal\")",
                "name": "process_notification"
            }
        },
        {
            "entity_model_name": "event",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import datetime\nimport asyncio\nimport logging",
                "content": "async def process_event(entity: dict) -> None:\n    entity[\"processed_at\"] = datetime.datetime.utcnow().isoformat() + \"Z\"\n\n    input_type = entity.get(\"input_type\")\n    input_data = entity.get(\"input_data\")\n    cat_id = entity.get(\"cat_id\")\n\n    if not (cat_id and input_type and input_data):\n        logger.warning(\"Event entity missing required fields for processing.\")\n        return\n\n    detected = False\n    try:\n        if input_type == \"text\":\n            detected = await detect_food_request_from_text(input_data)\n        elif input_type == \"audio\":\n            detected = await detect_food_request_from_audio(input_data)\n    except Exception:\n        logger.exception(\"Failed to detect food request in process_event\")\n\n    if detected:\n        entity[\"event_type\"] = \"food_request\"\n        entity[\"message\"] = \"Emergency! A cat demands snacks\"\n        # Fire-and-forget notification creation\n        asyncio.create_task(\n            send_notification_entity(cat_id, entity[\"event_type\"], entity[\"message\"])\n        )\n    else:\n        entity[\"event_type\"] = None\n        entity[\"message\"] = None",
                "name": "process_event"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport base64\nimport datetime\nimport logging\nfrom typing import Dict\nfrom uuid import uuid4\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass DetectEventRequest:\n    cat_id: str\n    input_type: str\n    input_data: str\n\n@dataclass\nclass NotificationRequest:\n    cat_id: str\n    event_type: str\n    message: str\n\nasync def detect_food_request_from_text(text: str) -> bool:\n    keywords = [\"snack\", \"food\", \"hungry\", \"feed\", \"treat\", \"meow\", \"demand\"]\n    return any(k in text.lower() for k in keywords)\n\nasync def detect_food_request_from_audio(audio_b64: str) -> bool:\n    ASSEMBLYAI_API_KEY = \"YOUR_ASSEMBLYAI_API_KEY\"  # TODO: Add your AssemblyAI API key\n    async with httpx.AsyncClient(timeout=60) as client:\n        try:\n            audio_bytes = base64.b64decode(audio_b64)\n            upload_resp = await client.post(\n                \"https://api.assemblyai.com/v2/upload\",\n                headers={\"authorization\": ASSEMBLYAI_API_KEY},\n                content=audio_bytes,\n            )\n            upload_resp.raise_for_status()\n            upload_url = upload_resp.json()[\"upload_url\"]\n            transcript_req = {\"audio_url\": upload_url, \"language_code\": \"en\", \"iab_categories\": False}\n            tr_resp = await client.post(\n                \"https://api.assemblyai.com/v2/transcript\",\n                headers={\"authorization\": ASSEMBLYAI_API_KEY, \"content-type\": \"application/json\"},\n                json=transcript_req,\n            )\n            tr_resp.raise_for_status()\n            tid = tr_resp.json()[\"id\"]\n            while True:\n                status_resp = await client.get(\n                    f\"https://api.assemblyai.com/v2/transcript/{tid}\",\n                    headers={\"authorization\": ASSEMBLYAI_API_KEY},\n                )\n                status_resp.raise_for_status()\n                st = status_resp.json()\n                if st[\"status\"] == \"completed\":\n                    text = st[\"text\"]\n                    break\n                if st[\"status\"] == \"error\":\n                    logger.error(\"AssemblyAI error: %s\", st.get(\"error\"))\n                    return False\n                await asyncio.sleep(2)\n            return await detect_food_request_from_text(text)\n        except Exception:\n            logger.exception(\"Audio detection failed\")\n            return False\n\nasync def send_notification_entity(cat_id: str, event_type: str, message: str):\n    notification = {\n        \"cat_id\": cat_id,\n        \"event_type\": event_type,\n        \"message\": message,\n        \"timestamp\": datetime.datetime.utcnow().isoformat() + \"Z\",\n    }\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"notification\",\n            entity_version=ENTITY_VERSION,\n            entity=notification\n        )\n        logger.info(\"Notification entity added asynchronously.\")\n    except Exception:\n        logger.exception(\"Failed to add notification entity asynchronously.\")\n\nasync def process_event(entity: dict) -> None:\n    entity[\"processed_at\"] = datetime.datetime.utcnow().isoformat() + \"Z\"\n\n    input_type = entity.get(\"input_type\")\n    input_data = entity.get(\"input_data\")\n    cat_id = entity.get(\"cat_id\")\n\n    if not (cat_id and input_type and input_data):\n        logger.warning(\"Event entity missing required fields for processing.\")\n        return\n\n    detected = False\n    try:\n        if input_type == \"text\":\n            detected = await detect_food_request_from_text(input_data)\n        elif input_type == \"audio\":\n            detected = await detect_food_request_from_audio(input_data)\n    except Exception:\n        logger.exception(\"Failed to detect food request in process_event\")\n\n    if detected:\n        entity[\"event_type\"] = \"food_request\"\n        entity[\"message\"] = \"Emergency! A cat demands snacks\"\n        # Fire-and-forget notification creation\n        asyncio.create_task(\n            send_notification_entity(cat_id, entity[\"event_type\"], entity[\"message\"])\n        )\n    else:\n        entity[\"event_type\"] = None\n        entity[\"message\"] = None\n\nasync def process_notification(entity: dict) -> None:\n    if \"timestamp\" not in entity:\n        entity[\"timestamp\"] = datetime.datetime.utcnow().isoformat() + \"Z\"\n    entity.setdefault(\"priority\", \"normal\")\n\n@app.route(\"/events/detect\", methods=[\"POST\"])\n@validate_request(DetectEventRequest)\nasync def detect_event(data: DetectEventRequest):\n    event = {\n        \"cat_id\": data.cat_id,\n        \"input_type\": data.input_type,\n        \"input_data\": data.input_data,\n    }\n    try:\n        event_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"event\",\n            entity_version=ENTITY_VERSION,\n            entity=event\n        )\n        return jsonify({\"id\": event_id})\n    except Exception:\n        logger.exception(\"Failed to add event\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route(\"/events/<string:cat_id>\", methods=[\"GET\"])\nasync def get_events(cat_id):\n    try:\n        condition = {\n            \"cyoda\": {\n                \"type\": \"group\",\n                \"operator\": \"AND\",\n                \"conditions\": [\n                    {\n                        \"jsonPath\": \"$.cat_id\",\n                        \"operatorType\": \"EQUALS\",\n                        \"value\": cat_id,\n                        \"type\": \"simple\"\n                    }\n                ]\n            }\n        }\n        events = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"event\",\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n        return jsonify(events)\n    except Exception:\n        logger.exception(\"Failed to get events\")\n        return jsonify([])\n\n@app.route(\"/notifications/send\", methods=[\"POST\"])\n@validate_request(NotificationRequest)\nasync def notifications_send(data: NotificationRequest):\n    notification = {\n        \"cat_id\": data.cat_id,\n        \"event_type\": data.event_type,\n        \"message\": data.message,\n    }\n    try:\n        notification_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"notification\",\n            entity_version=ENTITY_VERSION,\n            entity=notification\n        )\n        return jsonify({\"id\": notification_id})\n    except Exception:\n        logger.exception(\"Failed to add notification\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO)\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}