{
    "entity_models": [
        {
            "entity_model_name": "user",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from fastapi import HTTPException\nimport asyncio",
                "content": "async def process_user(entity: dict):\n    # Enrich user profile asynchronously before persistence\n    if 'id' in entity:\n        entity['profile'] = await async_fetch_profile(entity['id'])\n    # Fire and forget welcome email if new user (assumed no 'created' flag means new)\n    if not entity.get('created'):\n        # Cannot call entity_service inside workflow, so just trigger async task here (await to ensure execution)\n        await async_send_welcome_email(entity.get('email', ''))\n        entity['created'] = True  # mark as created to prevent repeat email",
                "name": "process_user"
            }
        },
        {
            "entity_model_name": "order",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from fastapi import HTTPException\nimport asyncio",
                "content": "async def process_order(entity: dict):\n    # Calculate totals asynchronously before persistence\n    await async_calculate_order_totals(entity)\n    # Enrich each item with product details\n    items = entity.get('items', [])\n    if items and isinstance(items, list):\n        for item in items:\n            product_id = item.get('product_id')\n            if product_id is not None:\n                product_details = await async_fetch_product_details(product_id)\n                # Add product name and price to item if not present\n                item.setdefault('name', product_details.get('name'))\n                item.setdefault('price', product_details.get('price'))",
                "name": "process_order"
            }
        },
        {
            "entity_model_name": "product",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from fastapi import HTTPException\nimport asyncio",
                "content": "async def process_product(entity: dict):\n    # No async logic currently for products, placeholder for extension\n    pass",
                "name": "process_product"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from fastapi import FastAPI, Request, HTTPException\nfrom typing import Dict, Any\nimport asyncio\n\napp = FastAPI()\n\n# Simulated in-memory entity storage\nentity_storage = {\n    'user': [],\n    'order': [],\n    'product': []\n}\n\n# Simulated entity service with add, update, delete operations\nclass EntityService:\n    async def add(self, entity_model: str, entity: Dict[str, Any]):\n        entity_storage[entity_model].append(entity)\n\n    async def update(self, entity_model: str, entity_id: Any, updated_entity: Dict[str, Any]):\n        for idx, ent in enumerate(entity_storage[entity_model]):\n            if ent.get('id') == entity_id:\n                entity_storage[entity_model][idx] = updated_entity\n                return\n        raise HTTPException(status_code=404, detail=f\"{entity_model} not found\")\n\n    async def delete(self, entity_model: str, entity_id: Any):\n        for idx, ent in enumerate(entity_storage[entity_model]):\n            if ent.get('id') == entity_id:\n                del entity_storage[entity_model][idx]\n                return\n        raise HTTPException(status_code=404, detail=f\"{entity_model} not found\")\n\nentity_service = EntityService()\n\n# Simulated async functions representing external calls or fire and forget tasks\nasync def async_fetch_profile(user_id):\n    await asyncio.sleep(0.1)  # simulate IO delay\n    return {\"bio\": \"User bio for user_id \" + str(user_id)}\n\nasync def async_send_welcome_email(user_email):\n    await asyncio.sleep(0.1)  # simulate sending email\n    # fire and forget simulated by no return\n\nasync def async_calculate_order_totals(order):\n    await asyncio.sleep(0.1)  # simulate calculation\n    # example total calculation\n    order['total'] = sum(item.get('price', 0) * item.get('quantity', 1) for item in order.get('items', []))\n\nasync def async_fetch_product_details(product_id):\n    await asyncio.sleep(0.1)  # simulate product lookup\n    return {\"name\": f\"Product {product_id}\", \"price\": 10.0 * product_id}\n\n# Workflow functions\n\nasync def process_user(entity: dict):\n    # Enrich user profile asynchronously before persistence\n    if 'id' in entity:\n        entity['profile'] = await async_fetch_profile(entity['id'])\n    # Fire and forget welcome email if new user (assumed no 'created' flag means new)\n    if not entity.get('created'):\n        # Cannot call entity_service inside workflow, so just trigger async task here (await to ensure execution)\n        await async_send_welcome_email(entity.get('email', ''))\n        entity['created'] = True  # mark as created to prevent repeat email\n\nasync def process_order(entity: dict):\n    # Calculate totals asynchronously before persistence\n    await async_calculate_order_totals(entity)\n    # Enrich each item with product details\n    items = entity.get('items', [])\n    if items and isinstance(items, list):\n        for item in items:\n            product_id = item.get('product_id')\n            if product_id is not None:\n                product_details = await async_fetch_product_details(product_id)\n                # Add product name and price to item if not present\n                item.setdefault('name', product_details.get('name'))\n                item.setdefault('price', product_details.get('price'))\n\nasync def process_product(entity: dict):\n    # No async logic currently for products, placeholder for extension\n    pass\n\n# Endpoints\n\n@app.post(\"/users\")\nasync def create_user(request: Request):\n    user_data = await request.json()\n    # Validate minimal required fields\n    if 'id' not in user_data or 'email' not in user_data:\n        raise HTTPException(status_code=400, detail=\"User must have 'id' and 'email'\")\n    # Call workflow function before persistence\n    await process_user(user_data)\n    await entity_service.add('user', user_data)\n    return {\"status\": \"user created\", \"user\": user_data}\n\n@app.put(\"/users/{user_id}\")\nasync def update_user(user_id: int, request: Request):\n    user_data = await request.json()\n    user_data['id'] = user_id\n    # Call workflow function before persistence\n    await process_user(user_data)\n    await entity_service.update('user', user_id, user_data)\n    return {\"status\": \"user updated\", \"user\": user_data}\n\n@app.post(\"/orders\")\nasync def create_order(request: Request):\n    order_data = await request.json()\n    if 'id' not in order_data:\n        raise HTTPException(status_code=400, detail=\"Order must have 'id'\")\n    if 'items' not in order_data or not isinstance(order_data['items'], list):\n        raise HTTPException(status_code=400, detail=\"Order must have 'items' as a list\")\n    await process_order(order_data)\n    await entity_service.add('order', order_data)\n    return {\"status\": \"order created\", \"order\": order_data}\n\n@app.put(\"/orders/{order_id}\")\nasync def update_order(order_id: int, request: Request):\n    order_data = await request.json()\n    order_data['id'] = order_id\n    await process_order(order_data)\n    await entity_service.update('order', order_id, order_data)\n    return {\"status\": \"order updated\", \"order\": order_data}\n\n@app.post(\"/products\")\nasync def create_product(request: Request):\n    product_data = await request.json()\n    if 'id' not in product_data:\n        raise HTTPException(status_code=400, detail=\"Product must have 'id'\")\n    await process_product(product_data)\n    await entity_service.add('product', product_data)\n    return {\"status\": \"product created\", \"product\": product_data}\n\n@app.put(\"/products/{product_id}\")\nasync def update_product(product_id: int, request: Request):\n    product_data = await request.json()\n    product_data['id'] = product_id\n    await process_product(product_data)\n    await entity_service.update('product', product_id, product_data)\n    return {\"status\": \"product updated\", \"product\": product_data}\n\n@app.delete(\"/users/{user_id}\")\nasync def delete_user(user_id: int):\n    await entity_service.delete('user', user_id)\n    return {\"status\": \"user deleted\", \"user_id\": user_id}\n\n@app.delete(\"/orders/{order_id}\")\nasync def delete_order(order_id: int):\n    await entity_service.delete('order', order_id)\n    return {\"status\": \"order deleted\", \"order_id\": order_id}\n\n@app.delete(\"/products/{product_id}\")\nasync def delete_product(product_id: int):\n    await entity_service.delete('product', product_id)\n    return {\"status\": \"product deleted\", \"product_id\": product_id}"
    }
}