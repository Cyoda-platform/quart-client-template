{
    "entity_models": [
        {
            "entity_model_name": "petsearch",
            "workflow_function": {
                "content": "async def process_petsearch(entity):\n    \"\"\"\n    Workflow function applied to the 'petsearch' entity asynchronously before persistence.\n    Performs the Petstore API call, filters by type/status, and saves pets asynchronously.\n    \"\"\"\n    pet_type = entity.get(\"type\")\n    status = entity.get(\"status\") or \"available\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            params = {\"status\": status}\n            resp = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params=params)\n            resp.raise_for_status()\n            pets_raw = resp.json()\n\n        if pet_type:\n            pets_filtered = [p for p in pets_raw if p.get(\"category\") and p[\"category\"].get(\"name\", \"\").lower() == pet_type.lower()]\n        else:\n            pets_filtered = pets_raw\n\n        # Save each pet entity via entity_service.add_item with workflow=process_pet\n        async def save_pet(pet):\n            pet_data = {\n                \"id\": str(pet.get(\"id\")),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\", None),\n                \"status\": pet.get(\"status\"),\n                \"photoUrls\": pet.get(\"photoUrls\", []),\n            }\n            try:\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet\",\n                    entity_version=ENTITY_VERSION,\n                    entity=pet_data,\n                    workflow=process_pet,\n                )\n            except Exception as e:\n                logger.exception(f\"Failed to save pet {pet_data.get('id')}: {e}\")\n\n        # Limit concurrency to avoid overwhelming the service\n        sem = asyncio.Semaphore(10)\n\n        async def sem_save_pet(p):\n            async with sem:\n                await save_pet(p)\n\n        await asyncio.gather(*(sem_save_pet(p) for p in pets_filtered))\n\n    except Exception as e:\n        logger.exception(f\"Failed to process petsearch entity: {e}\")\n\n    # Mark petsearch entity processed timestamp\n    entity[\"processed_at\"] = datetime.utcnow().isoformat()\n    return entity\n",
                "name": "process_petsearch"
            }
        },
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "content": "async def process_pet(entity):\n    \"\"\"\n    Workflow function applied to the 'pet' entity asynchronously before persistence.\n    Modify the entity as needed. For example, add a timestamp or default values.\n    Cannot add/update/delete 'pet' entity inside this function to avoid recursion.\n    \"\"\"\n    entity[\"processed_at\"] = datetime.utcnow().isoformat()\n    # Additional enrichment or side effects can be added here safely\n    return entity\n",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass PetSearch:\n    type: Optional[str] = None\n    status: Optional[str] = None\n\nasync def process_pet(entity):\n    \"\"\"\n    Workflow function applied to the 'pet' entity asynchronously before persistence.\n    Modify the entity as needed. For example, add a timestamp or default values.\n    Cannot add/update/delete 'pet' entity inside this function to avoid recursion.\n    \"\"\"\n    entity[\"processed_at\"] = datetime.utcnow().isoformat()\n    # Additional enrichment or side effects can be added here safely\n    return entity\n\nasync def process_petsearch(entity):\n    \"\"\"\n    Workflow function applied to the 'petsearch' entity asynchronously before persistence.\n    Performs the Petstore API call, filters by type/status, and saves pets asynchronously.\n    \"\"\"\n    pet_type = entity.get(\"type\")\n    status = entity.get(\"status\") or \"available\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            params = {\"status\": status}\n            resp = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params=params)\n            resp.raise_for_status()\n            pets_raw = resp.json()\n\n        if pet_type:\n            pets_filtered = [p for p in pets_raw if p.get(\"category\") and p[\"category\"].get(\"name\", \"\").lower() == pet_type.lower()]\n        else:\n            pets_filtered = pets_raw\n\n        # Save each pet entity via entity_service.add_item with workflow=process_pet\n        async def save_pet(pet):\n            pet_data = {\n                \"id\": str(pet.get(\"id\")),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\", None),\n                \"status\": pet.get(\"status\"),\n                \"photoUrls\": pet.get(\"photoUrls\", []),\n            }\n            try:\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet\",\n                    entity_version=ENTITY_VERSION,\n                    entity=pet_data\n                )\n            except Exception as e:\n                logger.exception(f\"Failed to save pet {pet_data.get('id')}: {e}\")\n\n        # Limit concurrency to avoid overwhelming the service\n        sem = asyncio.Semaphore(10)\n\n        async def sem_save_pet(p):\n            async with sem:\n                await save_pet(p)\n\n        await asyncio.gather(*(sem_save_pet(p) for p in pets_filtered))\n\n    except Exception as e:\n        logger.exception(f\"Failed to process petsearch entity: {e}\")\n\n    # Mark petsearch entity processed timestamp\n    entity[\"processed_at\"] = datetime.utcnow().isoformat()\n    return entity\n\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(PetSearch)\nasync def pets_search(data: PetSearch):\n    \"\"\"\n    POST /pets/search\n    Accepts optional filters: type, status\n    Creates a 'petsearch' entity; actual search and persistence handled asynchronously in workflow.\n    \"\"\"\n    try:\n        search_data = {\n            \"type\": data.type,\n            \"status\": data.status,\n        }\n        search_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"petsearch\",\n            entity_version=ENTITY_VERSION,\n            entity=search_data\n        )\n        return jsonify({\"search_id\": search_id, \"message\": \"Pet search request accepted and processing.\"})\n\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to initiate pet search\"}), 500\n\n\n@app.route(\"/pets/fun-fact\", methods=[\"POST\"])\nasync def pets_fun_fact():\n    import random\n    fact = random.choice(FUN_PET_FACTS)\n    return jsonify({\"fact\": fact})\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def get_pets():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        return jsonify({\"pets\": pets})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve pets\"}), 500\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def get_pet_by_id(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id,\n        )\n        if pet is None:\n            return jsonify({\"error\": f\"Pet with id {pet_id} not found.\"}), 404\n        return jsonify(pet)\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve pet\"}), 500\n\n\nif __name__ == '__main__':\n    import sys\n    import os\n\n    PETSTORE_BASE_URL = os.getenv(\"PETSTORE_BASE_URL\", \"https://petstore.swagger.io/v2\")\n    FUN_PET_FACTS = [\n        \"Cats sleep 70% of their lives.\",\n        \"Dogs have three eyelids.\",\n        \"Goldfish have a memory span of three months.\",\n        \"Rabbits can't vomit.\",\n    ]\n\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}