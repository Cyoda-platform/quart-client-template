{
    "entity_models": [
        {
            "entity_model_name": "order",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nimport httpx\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_order(entity: dict) -> dict:\n    \"\"\"\n    Workflow function that modifies the entity in place before persistence.\n    Expects '_event_meta' dict with keys:\n    - 'event_type': str\n    - 'original_event': dict\n    \"\"\"\n    event_meta = entity.pop('_event_meta', {})\n    event_type = event_meta.get('event_type')\n    event = event_meta.get('original_event', {})\n\n    if not event_type or not isinstance(event, dict):\n        logger.warning(\"Workflow called without valid event metadata\")\n        return entity\n\n    # Add processed timestamp\n    entity['processed_at'] = datetime.utcnow().isoformat() + 'Z'\n\n    # Fetch cat fact asynchronously but tolerate failure\n    cat_fact = await fetch_cat_fact()\n\n    # Defensive fallback for timestamp\n    timestamp = event.get(\"timestamp\")\n    try:\n        datetime.fromisoformat(timestamp)\n    except Exception:\n        timestamp = datetime.utcnow().isoformat() + 'Z'\n\n    if event_type == \"created\":\n        # On create, fill all relevant fields explicitly\n        entity.update({\n            \"order_id\": event.get(\"order_id\"),\n            \"cat_type\": event.get(\"cat_type\"),\n            \"quantity\": event.get(\"quantity\"),\n            \"price\": event.get(\"price\"),\n            \"status\": \"created\",\n            \"last_updated\": timestamp,\n            \"cat_fact\": cat_fact,\n        })\n    elif event_type == \"updated\":\n        # Update existing entity with event values if present, else keep current\n        entity.update({\n            \"cat_type\": event.get(\"cat_type\", entity.get(\"cat_type\")),\n            \"quantity\": event.get(\"quantity\", entity.get(\"quantity\")),\n            \"price\": event.get(\"price\", entity.get(\"price\")),\n            \"status\": \"updated\",\n            \"last_updated\": timestamp,\n            \"cat_fact\": cat_fact or entity.get(\"cat_fact\"),\n        })\n    elif event_type == \"canceled\":\n        entity.update({\n            \"status\": \"canceled\",\n            \"last_updated\": timestamp,\n            \"cat_fact\": cat_fact or entity.get(\"cat_fact\"),\n        })\n    else:\n        logger.warning(f\"Unknown event_type in workflow: {event_type}\")\n\n    return entity",
                "name": "process_order"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass OrderEvent:\n    event_type: str    # \"created\", \"updated\", \"canceled\"\n    order_id: str\n    cat_type: str      # e.g. \"siamese\", \"persian\"\n    quantity: int\n    price: float\n    timestamp: str     # ISO 8601 datetime\n\nCAT_FACTS_API = \"https://catfact.ninja/fact\"\n\nasync def fetch_cat_fact() -> Optional[str]:\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(CAT_FACTS_API, timeout=5)\n            resp.raise_for_status()\n            data = resp.json()\n            fact = data.get(\"fact\")\n            if isinstance(fact, str) and fact.strip():\n                return fact.strip()\n            else:\n                logger.warning(\"Received cat fact is empty or invalid\")\n                return None\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact from external API\")\n            return None\n\nasync def process_order(entity: dict) -> dict:\n    \"\"\"\n    Workflow function that modifies the entity in place before persistence.\n    Expects '_event_meta' dict with keys:\n    - 'event_type': str\n    - 'original_event': dict\n    \"\"\"\n    event_meta = entity.pop('_event_meta', {})\n    event_type = event_meta.get('event_type')\n    event = event_meta.get('original_event', {})\n\n    if not event_type or not isinstance(event, dict):\n        logger.warning(\"Workflow called without valid event metadata\")\n        return entity\n\n    # Add processed timestamp\n    entity['processed_at'] = datetime.utcnow().isoformat() + 'Z'\n\n    # Fetch cat fact asynchronously but tolerate failure\n    cat_fact = await fetch_cat_fact()\n\n    # Defensive fallback for timestamp\n    timestamp = event.get(\"timestamp\")\n    try:\n        datetime.fromisoformat(timestamp)\n    except Exception:\n        timestamp = datetime.utcnow().isoformat() + 'Z'\n\n    if event_type == \"created\":\n        # On create, fill all relevant fields explicitly\n        entity.update({\n            \"order_id\": event.get(\"order_id\"),\n            \"cat_type\": event.get(\"cat_type\"),\n            \"quantity\": event.get(\"quantity\"),\n            \"price\": event.get(\"price\"),\n            \"status\": \"created\",\n            \"last_updated\": timestamp,\n            \"cat_fact\": cat_fact,\n        })\n    elif event_type == \"updated\":\n        # Update existing entity with event values if present, else keep current\n        entity.update({\n            \"cat_type\": event.get(\"cat_type\", entity.get(\"cat_type\")),\n            \"quantity\": event.get(\"quantity\", entity.get(\"quantity\")),\n            \"price\": event.get(\"price\", entity.get(\"price\")),\n            \"status\": \"updated\",\n            \"last_updated\": timestamp,\n            \"cat_fact\": cat_fact or entity.get(\"cat_fact\"),\n        })\n    elif event_type == \"canceled\":\n        entity.update({\n            \"status\": \"canceled\",\n            \"last_updated\": timestamp,\n            \"cat_fact\": cat_fact or entity.get(\"cat_fact\"),\n        })\n    else:\n        logger.warning(f\"Unknown event_type in workflow: {event_type}\")\n\n    return entity\n\nasync def process_event(event: dict):\n    order_id = event.get(\"order_id\")\n    event_type = event.get(\"event_type\")\n    timestamp = event.get(\"timestamp\")\n\n    if not order_id or not event_type or not timestamp:\n        logger.warning(f\"Invalid event received: missing required fields: {event}\")\n        return\n\n    try:\n        datetime.fromisoformat(timestamp)\n    except Exception:\n        logger.warning(f\"Invalid timestamp format: {timestamp}\")\n        return\n\n    try:\n        current_order = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"order\",\n            entity_version=ENTITY_VERSION,\n            technical_id=order_id\n        )\n    except Exception:\n        logger.exception(f\"Failed to fetch order item for order_id={order_id}\")\n        return\n\n    if current_order:\n        entity = dict(current_order)\n    else:\n        entity = {}\n\n    # Inject event metadata for the workflow\n    entity['_event_meta'] = {\n        'event_type': event_type,\n        'original_event': event,\n    }\n\n    try:\n        entity = await process_order(entity)\n    except Exception:\n        logger.exception(f\"Workflow processing failed for order_id={order_id}\")\n        return\n\n    try:\n        if current_order:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=\"order\",\n                entity_version=ENTITY_VERSION,\n                entity=entity,\n                technical_id=order_id,\n                meta={}\n            )\n        else:\n            # Pass workflow again for compliance; won't cause recursion as add_item workflow is async pre-persist\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"order\",\n                entity_version=ENTITY_VERSION,\n                entity=entity\n            )\n        logger.info(f\"Order {order_id} processed successfully with event_type={event_type}\")\n    except Exception:\n        logger.exception(f\"Failed to persist order {order_id}\")\n\n@app.route(\"/orders/events\", methods=[\"POST\"])\n@validate_request(OrderEvent)\nasync def post_order_event(data: OrderEvent):\n    event = data.__dict__\n    try:\n        asyncio.create_task(process_event(event))\n    except Exception:\n        logger.exception(\"Failed to schedule event processing task\")\n        return jsonify({\"status\": \"error\", \"message\": \"Failed to start event processing\"}), 500\n    return jsonify({\"status\": \"success\", \"message\": \"Event processing started\", \"order_id\": event.get(\"order_id\")}), 200\n\n@app.route(\"/orders/<order_id>\", methods=[\"GET\"])\nasync def get_order(order_id: str):\n    try:\n        order = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"order\",\n            entity_version=ENTITY_VERSION,\n            technical_id=order_id\n        )\n    except Exception:\n        logger.exception(f\"Failed to fetch order {order_id}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Internal server error\"}), 500\n\n    if not order:\n        return jsonify({\"status\": \"error\", \"message\": \"Order not found\"}), 404\n    return jsonify(order), 200\n\n@app.route(\"/orders\", methods=[\"GET\"])\nasync def get_all_orders():\n    try:\n        all_orders = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"order\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to fetch all orders\")\n        return jsonify({\"status\": \"error\", \"message\": \"Internal server error\"}), 500\n    return jsonify(all_orders), 200\n\nif __name__ == '__main__':\n    # Using threaded=True to allow concurrency; use_reloader=False to avoid Quart reload issues with asyncio tasks\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}