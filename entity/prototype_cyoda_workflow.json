{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nimport httpx",
                "content": "async def process_pet(entity):\n    try:\n        # Add processing timestamp if missing\n        if \"processed_at\" not in entity:\n            entity[\"processed_at\"] = datetime.utcnow().isoformat() + \"Z\"\n\n        # Enrich description if missing and id is present\n        if (not entity.get(\"description\")) and entity.get(\"id\"):\n            pet_id = str(entity[\"id\"])\n            pet_details = await fetch_pet_details_from_petstore(pet_id)\n            if pet_details and pet_details.get(\"description\"):\n                entity[\"description\"] = pet_details[\"description\"]\n        # Additional async tasks or related entities can be handled here\n    except Exception:\n        logger.exception(\"Exception in process_pet workflow\")\n    return entity  # modifications done in place; return optional",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n# Local in-memory caches with asyncio.Lock for concurrency safety\nsearch_cache = {\"data\": None, \"lock\": asyncio.Lock()}\nfavorites_cache = {\"data\": set(), \"lock\": asyncio.Lock()}\n\nPETSTORE_BASE_URL = \"https://petstore.swagger.io/v2\"\n\n@dataclass\nclass PetSearchRequest:\n    type: Optional[str]\n    status: Optional[str]\n\n@dataclass\nclass PetDetailsRequest:\n    id: str\n\n@dataclass\nclass FavoriteRequest:\n    id: str\n\nasync def fetch_pets_from_petstore(type_: Optional[str], status: Optional[str]):\n    params = {}\n    if status:\n        params[\"status\"] = status\n    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            resp = await client.get(url, params=params)\n            resp.raise_for_status()\n            pets = resp.json()\n            if type_:\n                pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == type_.lower()]\n            return pets\n        except Exception:\n            logger.exception(\"Error fetching pets from Petstore API\")\n            return []\n\nasync def fetch_pet_details_from_petstore(pet_id: str):\n    url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            resp = await client.get(url)\n            resp.raise_for_status()\n            return resp.json()\n        except Exception:\n            logger.exception(f\"Error fetching pet details for id {pet_id}\")\n            return None\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(PetSearchRequest)\nasync def search_pets(data: PetSearchRequest):\n    pets = await fetch_pets_from_petstore(data.type, data.status)\n    async with search_cache[\"lock\"]:\n        search_cache[\"data\"] = pets\n    return jsonify({\"pets\": pets})\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def get_last_search():\n    async with search_cache[\"lock\"]:\n        pets = search_cache[\"data\"]\n    if pets is None:\n        return jsonify({\"pets\": []})\n    return jsonify({\"pets\": pets})\n\n@app.route(\"/pets/details\", methods=[\"POST\"])\n@validate_request(PetDetailsRequest)\nasync def pet_details(data: PetDetailsRequest):\n    pet = await fetch_pet_details_from_petstore(data.id)\n    if pet is None:\n        return jsonify({\"error\": \"Pet not found\"}), 404\n    return jsonify(pet)\n\n@app.route(\"/pets/favorites\", methods=[\"GET\"])\nasync def get_favorites():\n    async with favorites_cache[\"lock\"]:\n        fav_ids = list(favorites_cache[\"data\"])\n\n    async def fetch_one(pet_id: str):\n        pet = await fetch_pet_details_from_petstore(pet_id)\n        if pet:\n            return {\n                \"id\": pet.get(\"id\"),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\"),\n                \"status\": pet.get(\"status\"),\n            }\n        return None\n\n    pets = await asyncio.gather(*(fetch_one(pid) for pid in fav_ids))\n    pets = [p for p in pets if p is not None]\n    return jsonify({\"favorites\": pets})\n\n@app.route(\"/pets/favorites\", methods=[\"POST\"])\n@validate_request(FavoriteRequest)\nasync def add_favorite(data: FavoriteRequest):\n    pet = await fetch_pet_details_from_petstore(data.id)\n    if pet is None:\n        return jsonify({\"error\": \"Pet not found\"}), 404\n    async with favorites_cache[\"lock\"]:\n        favorites_cache[\"data\"].add(data.id)\n    response = {\n        \"message\": \"Pet added to favorites\",\n        \"pet\": {\n            \"id\": pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\"),\n            \"status\": pet.get(\"status\"),\n        },\n    }\n    return jsonify(response)\n\n# Workflow function for pet entity enrichment before persistence\nasync def process_pet(entity):\n    try:\n        # Add processing timestamp if missing\n        if \"processed_at\" not in entity:\n            entity[\"processed_at\"] = datetime.utcnow().isoformat() + \"Z\"\n\n        # Enrich description if missing and id is present\n        if (not entity.get(\"description\")) and entity.get(\"id\"):\n            pet_id = str(entity[\"id\"])\n            pet_details = await fetch_pet_details_from_petstore(pet_id)\n            if pet_details and pet_details.get(\"description\"):\n                entity[\"description\"] = pet_details[\"description\"]\n        # Additional async tasks or related entities can be handled here\n    except Exception:\n        logger.exception(\"Exception in process_pet workflow\")\n    return entity  # modifications done in place; return optional\n\n@app.route(\"/entity/pet\", methods=[\"POST\"])\nasync def add_pet():\n    try:\n        data = await request.get_json()\n        pet_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=data\n        )\n        return jsonify({\"id\": pet_id})\n    except Exception:\n        logger.exception(\"Failed to add pet\")\n        return jsonify({\"error\": \"Failed to add pet\"}), 500\n\n@app.route(\"/entity/pet/<string:id>\", methods=[\"GET\"])\nasync def get_pet(id):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=id\n        )\n        if pet is None:\n            return jsonify({\"error\": \"Pet not found\"}), 404\n        return jsonify(pet)\n    except Exception:\n        logger.exception(\"Failed to get pet\")\n        return jsonify({\"error\": \"Failed to get pet\"}), 500\n\n@app.route(\"/entity/pet\", methods=[\"GET\"])\nasync def get_all_pets():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        return jsonify(pets)\n    except Exception:\n        logger.exception(\"Failed to get pets\")\n        return jsonify({\"error\": \"Failed to get pets\"}), 500\n\n@app.route(\"/entity/pet/<string:id>\", methods=[\"PUT\"])\nasync def update_pet(id):\n    try:\n        data = await request.get_json()\n        # No workflow on update by default; add if needed in future\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=data,\n            technical_id=id,\n            meta={}\n        )\n        return jsonify({\"message\": \"Pet updated\"})\n    except Exception:\n        logger.exception(\"Failed to update pet\")\n        return jsonify({\"error\": \"Failed to update pet\"}), 500\n\n@app.route(\"/entity/pet/<string:id>\", methods=[\"DELETE\"])\nasync def delete_pet(id):\n    try:\n        await entity_service.delete_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=id,\n            meta={}\n        )\n        return jsonify({\"message\": \"Pet deleted\"})\n    except Exception:\n        logger.exception(\"Failed to delete pet\")\n        return jsonify({\"error\": \"Failed to delete pet\"}), 500\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}