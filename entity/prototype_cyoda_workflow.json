{
    "entity_models": [
        {
            "entity_model_name": "pets",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION",
                "content": "async def process_pets(entity: Dict) -> Dict:\n    # Normalize status field to lowercase if present\n    if \"status\" in entity and isinstance(entity[\"status\"], str):\n        entity[\"status\"] = entity[\"status\"].lower()\n\n    # Add processed timestamp\n    entity[\"processed_at\"] = datetime.utcnow().isoformat()\n\n    # Example enrichment: length of name\n    if \"name\" in entity and isinstance(entity[\"name\"], str):\n        entity[\"name_length\"] = len(entity[\"name\"])\n\n    # Example: add supplementary entities of different model here if needed (not implemented)\n\n    return entity",
                "name": "process_pets"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass FetchPetsRequest:\n    status: Optional[str] = None\n    category: Optional[str] = None\n\n@dataclass\nclass GetPetsQuery:\n    status: Optional[str] = None\n    category: Optional[str] = None\n    limit: int = 20\n    offset: int = 0\n\n@dataclass\nclass AdoptPetRequest:\n    petid: str\n\nPET_ENTITY_NAME = \"pets\"\nPETSTORE_BASE_URL = \"https://petstore.swagger.io/v2\"\n\n# Workflow function for pets entity\nasync def process_pets(entity: Dict) -> Dict:\n    # Normalize status field to lowercase if present\n    if \"status\" in entity and isinstance(entity[\"status\"], str):\n        entity[\"status\"] = entity[\"status\"].lower()\n\n    # Add processed timestamp\n    entity[\"processed_at\"] = datetime.utcnow().isoformat()\n\n    # Example enrichment: length of name\n    if \"name\" in entity and isinstance(entity[\"name\"], str):\n        entity[\"name_length\"] = len(entity[\"name\"])\n\n    # Example: add supplementary entities of different model here if needed (not implemented)\n\n    return entity\n\nasync def fetch_pets_from_petstore(status: Optional[str], category: Optional[str]) -> List[Dict]:\n    try:\n        async with httpx.AsyncClient() as client:\n            query_status = status if status else \"available,pending,sold\"\n            url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n            response = await client.get(url, params={\"status\": query_status})\n            response.raise_for_status()\n            pets = response.json()\n            if category:\n                cat_lower = category.lower()\n                pets = [\n                    pet for pet in pets\n                    if pet.get(\"category\", {}).get(\"name\", \"\").lower() == cat_lower\n                ]\n            return pets\n    except Exception as e:\n        logger.exception(f\"Failed to fetch pets from Petstore API: {e}\")\n        return []\n\nasync def store_pets(pets: List[Dict]):\n    for pet in pets:\n        pet_id = pet.get(\"id\")\n        if pet_id is None:\n            continue\n        technical_id = str(pet_id)\n        try:\n            existing_pet = await entity_service.get_item(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                technical_id=technical_id\n            )\n        except Exception:\n            existing_pet = None\n        if existing_pet is None:\n            data = {\n                \"id\": technical_id,\n                \"name\": pet.get(\"name\", \"\"),\n                \"category\": pet.get(\"category\", {}).get(\"name\", \"\"),\n                \"status\": pet.get(\"status\", \"\"),\n            }\n            try:\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=PET_ENTITY_NAME,\n                    entity_version=ENTITY_VERSION,\n                    entity=data\n                )\n            except Exception as e:\n                logger.exception(f\"Failed to store pet id {technical_id}: {e}\")\n        else:\n            # Do not update existing pets here to avoid infinite recursion\n            pass\n\n@app.route(\"/pets/fetch\", methods=[\"POST\"])\n@validate_request(FetchPetsRequest)\nasync def fetch_pets(data: FetchPetsRequest):\n    requested_at = datetime.utcnow().isoformat()\n    logger.info(f\"Fetch request at {requested_at} with status={data.status} category={data.category}\")\n\n    async def async_fetch_and_store():\n        pets = await fetch_pets_from_petstore(data.status, data.category)\n        await store_pets(pets)\n        logger.info(f\"Fetched and stored {len(pets)} pets\")\n\n    asyncio.create_task(async_fetch_and_store())\n    return jsonify({\"message\": \"Pets data fetch started asynchronously.\", \"requestedAt\": requested_at}), 202\n\n@validate_querystring(GetPetsQuery)\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def get_pets():\n    try:\n        status = request.args.get(\"status\")\n        category = request.args.get(\"category\")\n        limit = int(request.args.get(\"limit\", 20))\n        offset = int(request.args.get(\"offset\", 0))\n\n        conditions = {\"cyoda\": {\"type\": \"group\", \"operator\": \"AND\", \"conditions\": []}}\n\n        if status:\n            conditions[\"cyoda\"][\"conditions\"].append({\n                \"jsonPath\": \"$.status\",\n                \"operatorType\": \"EQUALS\",\n                \"value\": status.lower(),\n                \"type\": \"simple\"\n            })\n        if category:\n            conditions[\"cyoda\"][\"conditions\"].append({\n                \"jsonPath\": \"$.category\",\n                \"operatorType\": \"EQUALS\",\n                \"value\": category.lower(),\n                \"type\": \"simple\"\n            })\n\n        if conditions[\"cyoda\"][\"conditions\"]:\n            all_pets = await entity_service.get_items_by_condition(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                condition=conditions\n            )\n        else:\n            all_pets = await entity_service.get_items(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION\n            )\n\n        pets_list = all_pets or []\n        total = len(pets_list)\n        page = pets_list[offset: offset + limit]\n\n        return jsonify({\"pets\": page, \"total\": total, \"limit\": limit, \"offset\": offset})\n    except Exception as e:\n        logger.exception(f\"Failed to retrieve pets: {e}\")\n        return jsonify({\"error\": \"Failed to retrieve pets\"}), 500\n\n@app.route(\"/pets/adopt\", methods=[\"POST\"])\n@validate_request(AdoptPetRequest)\nasync def adopt(data: AdoptPetRequest):\n    pet_id = data.petid\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n        if not pet:\n            return jsonify({\"error\": f\"Pet with id {pet_id} not found\"}), 404\n\n        pet[\"status\"] = \"sold\"\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            entity=pet,\n            technical_id=pet_id,\n            meta={}\n        )\n        return jsonify({\"message\": f\"Pet {pet_id} adopted successfully.\", \"pet\": pet})\n    except Exception as e:\n        logger.exception(f\"Failed to adopt pet id {pet_id}: {e}\")\n        return jsonify({\"error\": \"Failed to adopt pet\"}), 500\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}