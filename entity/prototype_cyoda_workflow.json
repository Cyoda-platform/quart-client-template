{
    "entity_models": [
        {
            "entity_model_name": "cat_event",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\n\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass CatEvent:\n    catId: Optional[str] = None\n    eventType: str\n    intensity: str\n\nNOTIFICATION_WEBHOOK_URL = \"https://httpbin.org/post\"\n\nasync def send_notification(message: str) -> bool:\n    async with httpx.AsyncClient() as client:\n        try:\n            payload = {\"message\": message}\n            response = await client.post(NOTIFICATION_WEBHOOK_URL, json=payload, timeout=5)\n            response.raise_for_status()\n            logger.info(f\"Notification sent: {message}\")\n            return True\n        except Exception as e:\n            logger.exception(f\"Failed to send notification: {e}\")\n            return False",
                "content": "async def process_cat_event(entity: Dict[str, Any]) -> None:\n    \"\"\"\n    Workflow function applied to 'cat_event' entity before persistence.\n    Modifies entity state, sends notifications, and adds supplementary data entities.\n    \"\"\"\n    # Add timestamp to the entity\n    entity[\"timestamp\"] = datetime.now(timezone.utc).isoformat()\n\n    # Check event type and intensity for notification\n    if entity.get(\"eventType\") == \"food_request\" and entity.get(\"intensity\", \"\").lower() == \"dramatic\":\n        message = \"Emergency! A cat demands snacks\"\n        notification_sent = await send_notification(message)\n\n        # Add notification record as supplementary entity (different entity_model)\n        notification_record = {\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            \"message\": message,\n        }\n        try:\n            # Add notification entity (different model to avoid recursion)\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"notification\",\n                entity_version=ENTITY_VERSION,\n                entity=notification_record,\n                workflow=None  # no workflow for notifications\n            )\n        except Exception:\n            logger.exception(\"Failed to add notification entity\")\n\n        # Add notification info to the current entity state to persist\n        entity[\"notificationSent\"] = notification_sent\n        entity[\"notificationMessage\"] = message\n    else:\n        # No notification sent, clean fields just in case\n        entity[\"notificationSent\"] = False\n        entity[\"notificationMessage\"] = \"\"",
                "name": "process_cat_event"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any, Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\n\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass CatEvent:\n    catId: Optional[str] = None\n    eventType: str\n    intensity: str\n\nNOTIFICATION_WEBHOOK_URL = \"https://httpbin.org/post\"\n\nasync def send_notification(message: str) -> bool:\n    async with httpx.AsyncClient() as client:\n        try:\n            payload = {\"message\": message}\n            response = await client.post(NOTIFICATION_WEBHOOK_URL, json=payload, timeout=5)\n            response.raise_for_status()\n            logger.info(f\"Notification sent: {message}\")\n            return True\n        except Exception as e:\n            logger.exception(f\"Failed to send notification: {e}\")\n            return False\n\nasync def process_cat_event(entity: Dict[str, Any]) -> None:\n    \"\"\"\n    Workflow function applied to 'cat_event' entity before persistence.\n    Modifies entity state, sends notifications, and adds supplementary data entities.\n    \"\"\"\n    # Add timestamp to the entity\n    entity[\"timestamp\"] = datetime.now(timezone.utc).isoformat()\n\n    # Check event type and intensity for notification\n    if entity.get(\"eventType\") == \"food_request\" and entity.get(\"intensity\", \"\").lower() == \"dramatic\":\n        message = \"Emergency! A cat demands snacks\"\n        notification_sent = await send_notification(message)\n\n        # Add notification record as supplementary entity (different entity_model)\n        notification_record = {\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            \"message\": message,\n        }\n        try:\n            # Add notification entity (different model to avoid recursion)\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"notification\",\n                entity_version=ENTITY_VERSION,\n                entity=notification_record,\n                workflow=None  # no workflow for notifications\n            )\n        except Exception:\n            logger.exception(\"Failed to add notification entity\")\n\n        # Add notification info to the current entity state to persist\n        entity[\"notificationSent\"] = notification_sent\n        entity[\"notificationMessage\"] = message\n    else:\n        # No notification sent, clean fields just in case\n        entity[\"notificationSent\"] = False\n        entity[\"notificationMessage\"] = \"\"\n\n@app.route(\"/events/cat-demand\", methods=[\"POST\"])\n@validate_request(CatEvent)  # workaround: validation must go after route for POST due to quart-schema issue\nasync def cat_demand_event(data: CatEvent):\n    try:\n        # Pass the workflow function as argument\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_event\",\n            entity_version=ENTITY_VERSION,\n            entity=data.__dict__\n        )\n\n        # Fetch the persisted entity to include notification fields and timestamp in response\n        persisted_entity = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_event\",\n            entity_version=ENTITY_VERSION,\n            technical_id=entity_id\n        )\n\n        if persisted_entity is None:\n            # Defensive: item should exist, but handle gracefully\n            return jsonify({\"error\": \"Item not found after creation\"}), 500\n\n        # Return the persisted entity plus its ID\n        response = {\n            \"id\": entity_id,\n            \"eventProcessed\": persisted_entity\n        }\n        return jsonify(response)\n\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route(\"/events/cat-demand/<string:item_id>\", methods=[\"GET\"])\nasync def get_cat_event(item_id: str):\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_event\",\n            entity_version=ENTITY_VERSION,\n            technical_id=item_id\n        )\n        if item is None:\n            return jsonify({\"error\": \"Item not found\"}), 404\n        return jsonify(item)\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\nif __name__ == \"__main__\":\n    import sys\n\n    logging.basicConfig(\n        stream=sys.stdout,\n        level=logging.INFO,\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}