{
    "entity_models": [
        {
            "entity_model_name": "weather_fetch",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import logging\nfrom datetime import datetime\nimport httpx",
                "content": "async def process_weather_fetch(entity: dict):\n    \"\"\"\n    Workflow function applied before persisting 'weather_fetch' entity.\n    Fetches weather data asynchronously, updates entity state with results or errors.\n    \"\"\"\n    # Validate required input fields exist in entity\n    try:\n        latitude = entity[\"latitude\"]\n        longitude = entity[\"longitude\"]\n        parameters = entity[\"parameters\"]\n        start_date = entity[\"start_date\"]\n        end_date = entity[\"end_date\"]\n    except KeyError as e:\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = f\"Missing required field: {e.args[0]}\"\n        logger.error(entity[\"error\"])\n        return entity\n\n    entity[\"status\"] = \"processing\"\n    entity[\"requestedAt\"] = datetime.utcnow().isoformat() + \"Z\"\n\n    try:\n        raw_weather = await fetch_weather_data(latitude, longitude, parameters, start_date, end_date)\n        hourly_data = raw_weather.get(\"hourly\", {})\n        filtered_data = {param: hourly_data.get(param, []) for param in parameters}\n\n        entity[\"status\"] = \"completed\"\n        entity[\"result\"] = {\n            \"latitude\": latitude,\n            \"longitude\": longitude,\n            \"data\": filtered_data,\n            \"date_range\": {\"start\": start_date, \"end\": end_date},\n        }\n        entity[\"completedAt\"] = datetime.utcnow().isoformat() + \"Z\"\n        entity.pop(\"error\", None)\n    except Exception as e:\n        logger.exception(\"Error fetching weather data in workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n    return entity",
                "name": "process_weather_fetch"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nimport sys\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass WeatherFetchRequest:\n    latitude: float\n    longitude: float\n    parameters: list[str]\n    start_date: str\n    end_date: str\n\nOPEN_METEO_URL = \"https://api.open-meteo.com/v1/forecast\"\n\nasync def fetch_weather_data(latitude, longitude, parameters, start_date, end_date):\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"hourly\": \",\".join(parameters),\n        \"timezone\": \"auto\",\n    }\n    async with httpx.AsyncClient(timeout=10) as client:\n        resp = await client.get(OPEN_METEO_URL, params=params)\n        resp.raise_for_status()\n        return resp.json()\n\nasync def process_weather_fetch(entity: dict):\n    \"\"\"\n    Workflow function applied before persisting 'weather_fetch' entity.\n    Fetches weather data asynchronously, updates entity state with results or errors.\n    \"\"\"\n    # Validate required input fields exist in entity\n    try:\n        latitude = entity[\"latitude\"]\n        longitude = entity[\"longitude\"]\n        parameters = entity[\"parameters\"]\n        start_date = entity[\"start_date\"]\n        end_date = entity[\"end_date\"]\n    except KeyError as e:\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = f\"Missing required field: {e.args[0]}\"\n        logger.error(entity[\"error\"])\n        return entity\n\n    entity[\"status\"] = \"processing\"\n    entity[\"requestedAt\"] = datetime.utcnow().isoformat() + \"Z\"\n\n    try:\n        raw_weather = await fetch_weather_data(latitude, longitude, parameters, start_date, end_date)\n        hourly_data = raw_weather.get(\"hourly\", {})\n        filtered_data = {param: hourly_data.get(param, []) for param in parameters}\n\n        entity[\"status\"] = \"completed\"\n        entity[\"result\"] = {\n            \"latitude\": latitude,\n            \"longitude\": longitude,\n            \"data\": filtered_data,\n            \"date_range\": {\"start\": start_date, \"end\": end_date},\n        }\n        entity[\"completedAt\"] = datetime.utcnow().isoformat() + \"Z\"\n        entity.pop(\"error\", None)\n    except Exception as e:\n        logger.exception(\"Error fetching weather data in workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n    return entity\n\n@app.route(\"/weather/fetch\", methods=[\"POST\"])\n@validate_request(WeatherFetchRequest)\nasync def weather_fetch(data: WeatherFetchRequest):\n    try:\n        initial_entity = {\n            \"latitude\": data.latitude,\n            \"longitude\": data.longitude,\n            \"parameters\": data.parameters,\n            \"start_date\": data.start_date,\n            \"end_date\": data.end_date,\n        }\n\n        id_returned = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch\",\n            entity_version=ENTITY_VERSION,\n            entity=initial_entity\n        )\n\n        return jsonify(\n            {\n                \"status\": \"success\",\n                \"message\": \"Weather data fetch initiated\",\n                \"request_id\": str(id_returned),\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to initiate weather fetch: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Failed to initiate weather fetch\"}), 500\n\n@app.route(\"/weather/result/<string:technical_id>\", methods=[\"GET\"])\nasync def weather_result(technical_id: str):\n    try:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch\",\n            entity_version=ENTITY_VERSION,\n            technical_id=technical_id,\n        )\n        if not job:\n            return jsonify({\"status\": \"error\", \"message\": \"Request ID not found\"}), 404\n        status = job.get(\"status\")\n        if status == \"processing\":\n            return jsonify({\"status\": \"processing\", \"message\": \"Data is still being fetched\"}), 202\n        if status == \"failed\":\n            return jsonify({\"status\": \"failed\", \"message\": job.get(\"error\", \"Unknown error\")} ), 500\n        return jsonify(job.get(\"result\", {}))\n    except Exception as e:\n        logger.exception(f\"Error retrieving job result for {technical_id}: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Failed to retrieve data\"}), 500\n\nif __name__ == \"__main__\":\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO)\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}