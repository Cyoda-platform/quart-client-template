{
    "entity_models": [
        {
            "entity_model_name": "prototype",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import logging\nimport datetime\nfrom quart import Quart, request, jsonify\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION",
                "content": "async def process_prototype(entity):\n    # Add processed timestamp\n    entity['processed_at'] = datetime.datetime.utcnow().isoformat()\n\n    # Await enrichment logic\n    await enrich_prototype(entity)\n\n    # Log creation event asynchronously (supplementary entity)\n    await log_prototype_creation(entity)\n\n    # Additional entity state changes can be made here if needed\n\n    return entity",
                "name": "process_prototype"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import logging\nimport datetime\nfrom quart import Quart, request, jsonify\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\n\nentity_name = \"prototype\"  # entity name in underscore lowercase\n\n\nasync def enrich_prototype(entity):\n    # Placeholder for async enrichment logic, e.g. fetching external data\n    # Simulated with pass, replace with actual async code if needed\n    pass\n\n\nasync def log_prototype_creation(entity):\n    # Add a supplementary entity/log for audit purposes (different entity_model)\n    log_entity = {\n        \"prototype_id\": entity.get(\"id\"),\n        \"event\": \"created\",\n        \"timestamp\": datetime.datetime.utcnow().isoformat()\n    }\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model='prototype_log',  # different entity model\n            entity_version=ENTITY_VERSION,\n            entity=log_entity,\n            workflow=None  # no workflow for log entity\n        )\n    except Exception:\n        logger.exception(\"Failed to log prototype creation\")\n\n\nasync def process_prototype(entity):\n    # Add processed timestamp\n    entity['processed_at'] = datetime.datetime.utcnow().isoformat()\n\n    # Await enrichment logic\n    await enrich_prototype(entity)\n\n    # Log creation event asynchronously (supplementary entity)\n    await log_prototype_creation(entity)\n\n    # Additional entity state changes can be made here if needed\n\n    return entity\n\n\n@app.route('/prototypes', methods=['POST'])\nasync def create_prototype():\n    try:\n        data = await request.get_json()\n        if not data or not isinstance(data, dict):\n            return jsonify({\"error\": \"Invalid input data\"}), 400\n\n        # Add item with workflow handling async business logic pre-persistence\n        id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data\n        )\n        return jsonify({\"id\": str(id)}), 201\n    except Exception:\n        logger.exception(\"Failed to create prototype\")\n        return jsonify({\"error\": \"Failed to create prototype\"}), 500\n\n\n@app.route('/prototypes/<string:id>', methods=['GET'])\nasync def get_prototype(id):\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            technical_id=id\n        )\n        if item is None:\n            return jsonify({\"error\": \"Prototype not found\"}), 404\n        return jsonify(item), 200\n    except Exception:\n        logger.exception(\"Failed to get prototype\")\n        return jsonify({\"error\": \"Failed to get prototype\"}), 500\n\n\n@app.route('/prototypes', methods=['GET'])\nasync def get_prototypes():\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION\n        )\n        return jsonify(items), 200\n    except Exception:\n        logger.exception(\"Failed to get prototypes\")\n        return jsonify({\"error\": \"Failed to get prototypes\"}), 500\n\n\n@app.route('/prototypes/<string:id>', methods=['PUT'])\nasync def update_prototype(id):\n    try:\n        data = await request.get_json()\n        if not data or not isinstance(data, dict):\n            return jsonify({\"error\": \"Invalid input data\"}), 400\n\n        # If needed, create a similar workflow for update operations\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data,\n            technical_id=id,\n            meta={}\n        )\n        return jsonify({\"message\": \"Prototype updated\"}), 200\n    except Exception:\n        logger.exception(\"Failed to update prototype\")\n        return jsonify({\"error\": \"Failed to update prototype\"}), 500\n\n\n@app.route('/prototypes/<string:id>', methods=['DELETE'])\nasync def delete_prototype(id):\n    try:\n        await entity_service.delete_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            technical_id=id,\n            meta={}\n        )\n        return jsonify({\"message\": \"Prototype deleted\"}), 200\n    except Exception:\n        logger.exception(\"Failed to delete prototype\")\n        return jsonify({\"error\": \"Failed to delete prototype\"}), 500\n\n\n@app.route('/prototypes/search', methods=['POST'])\nasync def search_prototypes():\n    try:\n        condition = await request.get_json()\n        if not condition or not isinstance(condition, dict):\n            return jsonify({\"error\": \"Invalid search condition\"}), 400\n\n        items = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n        return jsonify(items), 200\n    except Exception:\n        logger.exception(\"Failed to search prototypes\")\n        return jsonify({\"error\": \"Failed to search prototypes\"}), 500\n"
    }
}