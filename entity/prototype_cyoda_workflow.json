{
    "entity_models": [
        {
            "entity_model_name": "adopt_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\n\nadoption_lock = asyncio.Lock()\nadoption_status = {}\nlogger = logging.getLogger(__name__)",
                "content": "async def process_adopt_request(entity: dict) -> dict:\n    pet_id = entity.get(\"petId\")\n    user_name = entity.get(\"userName\")\n    if not pet_id or not user_name:\n        raise ValueError(\"petId and userName are required in adopt_request entity\")\n\n    async with adoption_lock:\n        current_status = adoption_status.get(pet_id, \"available\")\n        if current_status != \"available\":\n            entity[\"adoption_success\"] = False\n            entity[\"message\"] = \"Pet is not available for adoption.\"\n            logger.info(f\"Adoption failed: pet {pet_id} already adopted\")\n        else:\n            adoption_status[pet_id] = \"adopted\"\n            entity[\"adoption_success\"] = True\n            entity[\"message\"] = \"Adoption request confirmed.\"\n            entity[\"adopted_at\"] = datetime.utcnow().isoformat() + \"Z\"\n            logger.info(f\"User '{user_name}' adopted pet {pet_id}\")\n\n    return entity",
                "name": "process_adopt_request"
            }
        },
        {
            "entity_model_name": "favorite_add_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\n\nadoption_status = {}\nlogger = logging.getLogger(__name__)\n\nasync def fetch_pet_by_id(pet_id: str) -> dict:\n    pass  # Assume this function is defined elsewhere as in the original code",
                "content": "async def process_favorite_add_request(entity: dict) -> dict:\n    pet_id = entity.get(\"pet_id\")\n    if not pet_id:\n        raise ValueError(\"pet_id is required in favorite_add_request entity\")\n\n    pet = await fetch_pet_by_id(pet_id)\n    if not pet:\n        raise ValueError(f\"Pet with id {pet_id} not found\")\n\n    pet_info = {\n        \"id\": str(pet.get(\"id\")),\n        \"name\": pet.get(\"name\", \"\"),\n        \"type\": pet.get(\"category\", {}).get(\"name\", \"\").lower() if pet.get(\"category\") else \"\",\n        \"breed\": \"\",  # Petstore does not provide breed info\n        \"age\": 0,     # Petstore does not provide age info\n        \"status\": adoption_status.get(str(pet.get(\"id\")), \"available\"),\n    }\n    entity[\"pet_info\"] = pet_info\n    now_iso = datetime.utcnow().isoformat() + \"Z\"\n    entity[\"added_at\"] = now_iso\n    entity[\"processed_at\"] = now_iso\n    return entity",
                "name": "process_favorite_add_request"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Dict, List\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SearchRequest:\n    type: str = None\n    breed: str = None\n    name: str = None\n\n@dataclass\nclass AdoptRequest:\n    petId: str\n    userName: str\n\n@dataclass\nclass FavoriteAddRequest:\n    petId: str\n    userName: str\n\n@dataclass\nclass FavoritesQuery:\n    userName: str\n\nadoption_lock = asyncio.Lock()\nadoption_status: Dict[str, str] = {}\nPETSTORE_API = \"https://petstore.swagger.io/v2\"\n\nasync def fetch_pet_by_id(pet_id: str) -> dict:\n    try:\n        async with httpx.AsyncClient() as client:\n            resp = await client.get(f\"{PETSTORE_API}/pet/{pet_id}\")\n            resp.raise_for_status()\n            pet = resp.json()\n            return pet\n    except Exception as e:\n        logger.warning(f\"Failed to fetch pet {pet_id} from Petstore: {e}\")\n        return None\n\nasync def fetch_pets_by_status(status: str = \"available\") -> List[dict]:\n    try:\n        async with httpx.AsyncClient() as client:\n            resp = await client.get(f\"{PETSTORE_API}/pet/findByStatus\", params={\"status\": status})\n            resp.raise_for_status()\n            pets = resp.json()\n            return pets\n    except Exception as e:\n        logger.warning(f\"Failed to fetch pets by status '{status}': {e}\")\n        return []\n\n# Workflow function for favorite_add_request entity\nasync def process_favorite_add_request(entity: dict) -> dict:\n    pet_id = entity.get(\"pet_id\")\n    if not pet_id:\n        raise ValueError(\"pet_id is required in favorite_add_request entity\")\n\n    pet = await fetch_pet_by_id(pet_id)\n    if not pet:\n        raise ValueError(f\"Pet with id {pet_id} not found\")\n\n    pet_info = {\n        \"id\": str(pet.get(\"id\")),\n        \"name\": pet.get(\"name\", \"\"),\n        \"type\": pet.get(\"category\", {}).get(\"name\", \"\").lower() if pet.get(\"category\") else \"\",\n        \"breed\": \"\",  # Petstore does not provide breed info\n        \"age\": 0,     # Petstore does not provide age info\n        \"status\": adoption_status.get(str(pet.get(\"id\")), \"available\"),\n    }\n    entity[\"pet_info\"] = pet_info\n    now_iso = datetime.utcnow().isoformat() + \"Z\"\n    entity[\"added_at\"] = now_iso\n    entity[\"processed_at\"] = now_iso\n    return entity\n\n# Workflow function for adopt_request entity\nasync def process_adopt_request(entity: dict) -> dict:\n    pet_id = entity.get(\"petId\")\n    user_name = entity.get(\"userName\")\n    if not pet_id or not user_name:\n        raise ValueError(\"petId and userName are required in adopt_request entity\")\n\n    async with adoption_lock:\n        current_status = adoption_status.get(pet_id, \"available\")\n        if current_status != \"available\":\n            entity[\"adoption_success\"] = False\n            entity[\"message\"] = \"Pet is not available for adoption.\"\n            logger.info(f\"Adoption failed: pet {pet_id} already adopted\")\n        else:\n            adoption_status[pet_id] = \"adopted\"\n            entity[\"adoption_success\"] = True\n            entity[\"message\"] = \"Adoption request confirmed.\"\n            entity[\"adopted_at\"] = datetime.utcnow().isoformat() + \"Z\"\n            logger.info(f\"User '{user_name}' adopted pet {pet_id}\")\n\n    return entity\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchRequest)\nasync def pets_search(data: SearchRequest):\n    pets = await fetch_pets_by_status(\"available\")\n\n    filtered = []\n    type_lower = data.type.lower() if data.type else None\n    name_lower = data.name.lower() if data.name else None\n    for pet in pets:\n        pet_type = pet.get(\"category\", {}).get(\"name\", \"\").lower() if pet.get(\"category\") else \"\"\n        pet_name = pet.get(\"name\", \"\").lower()\n        if type_lower and type_lower != pet_type:\n            continue\n        if name_lower and name_lower not in pet_name:\n            continue\n        filtered.append({\n            \"id\": str(pet.get(\"id\")),\n            \"name\": pet.get(\"name\", \"\"),\n            \"type\": pet_type,\n            \"breed\": \"\",\n            \"age\": 0,\n            \"status\": adoption_status.get(str(pet.get(\"id\")), \"available\"),\n        })\n    return jsonify({\"pets\": filtered})\n\n@app.route(\"/pets/adopt\", methods=[\"POST\"])\n@validate_request(AdoptRequest)\nasync def pets_adopt(data: AdoptRequest):\n    entity = {\"petId\": data.petId, \"userName\": data.userName}\n    try:\n        id_ = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"adopt_request\",\n            entity_version=ENTITY_VERSION,\n            entity=entity\n        )\n        if entity.get(\"adoption_success\"):\n            return jsonify({\"success\": True, \"message\": entity.get(\"message\", \"\")})\n        else:\n            return jsonify({\"success\": False, \"message\": entity.get(\"message\", \"\")}), 409\n    except Exception as e:\n        logger.exception(f\"Error in adopt endpoint: {e}\")\n        return jsonify({\"success\": False, \"message\": \"Adoption failed due to server error.\"}), 500\n\n@app.route(\"/pets/favorites/add\", methods=[\"POST\"])\n@validate_request(FavoriteAddRequest)\nasync def pets_favorites_add(data: FavoriteAddRequest):\n    entity = {\"pet_id\": data.petId, \"user_name\": data.userName}\n    try:\n        id_ = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"favorite_add_request\",\n            entity_version=ENTITY_VERSION,\n            entity=entity\n        )\n        return jsonify({\"success\": True, \"id\": id_})\n    except Exception as e:\n        logger.exception(f\"Error in favorites add endpoint: {e}\")\n        return jsonify({\"success\": False, \"message\": \"Failed to add favorite.\"}), 500\n\n@validate_querystring(FavoritesQuery)\n@app.route(\"/pets/favorites\", methods=[\"GET\"])\nasync def pets_favorites():\n    user_name = request.args.get(\"userName\")\n    try:\n        condition = {\n            \"cyoda\": {\n                \"type\": \"group\",\n                \"operator\": \"AND\",\n                \"conditions\": [\n                    {\n                        \"jsonPath\": \"$.user_name\",\n                        \"operatorType\": \"EQUALS\",\n                        \"value\": user_name,\n                        \"type\": \"simple\"\n                    }\n                ]\n            }\n        }\n        favorites = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"favorite_add_request\",\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n        return jsonify({\"favorites\": favorites})\n    except Exception as e:\n        logger.exception(f\"Error fetching favorites: {e}\")\n        return jsonify({\"favorites\": []}), 500\n\nif __name__ == \"__main__\":\n    import sys\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        stream=sys.stdout,\n    )\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}