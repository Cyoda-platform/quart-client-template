{
    "entity_models": [
        {
            "entity_model_name": "subscriber",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any\n\nlogger = logging.getLogger(__name__)\n\nasync def send_email(email: str, subject: str, body: str) -> None:\n    # TODO: Replace with real email sending implementation\n    logger.info(f\"Sending email to {email} with subject '{subject}' and body: {body}\")\n    await asyncio.sleep(0.1)",
                "content": "async def process_subscriber(entity: Dict[str, Any]) -> Dict[str, Any]:\n    email = entity.get(\"email\")\n    if email:\n        normalized_email = email.lower()\n        entity[\"email\"] = normalized_email\n\n        async def _send_welcome_email():\n            try:\n                await send_email(\n                    normalized_email,\n                    subject=\"Welcome to Cat Facts!\",\n                    body=\"Thank you for subscribing to Cat Facts!\"\n                )\n                logger.info(f\"Welcome email sent to {normalized_email}\")\n            except Exception as e:\n                logger.exception(f\"Failed to send welcome email to {normalized_email}: {e}\")\n\n        asyncio.create_task(_send_welcome_email())\n\n    if \"subscribedAt\" not in entity:\n        entity[\"subscribedAt\"] = datetime.utcnow().isoformat()\n\n    return entity",
                "name": "process_subscriber"
            }
        },
        {
            "entity_model_name": "cat_fact_sent",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom typing import Dict, Any\nimport httpx\n\nlogger = logging.getLogger(__name__)\n\nCAT_FACT_API_URL = \"https://catfact.ninja/fact\"\n\nasync def send_email(email: str, subject: str, body: str) -> None:\n    # TODO: Replace with real email sending implementation\n    logger.info(f\"Sending email to {email} with subject '{subject}' and body: {body}\")\n    await asyncio.sleep(0.1)\n\ninteraction_metrics = {\n    \"totalEmailsSent\": 0,\n    \"totalClicks\": 0,  # TODO: Implement tracking clicks from emails (placeholder)\n    \"totalOpens\": 0,   # TODO: Implement tracking email opens (placeholder)\n}",
                "content": "async def process_cat_fact_sent(entity: Dict[str, Any]) -> Dict[str, Any]:\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(CAT_FACT_API_URL, timeout=10)\n            response.raise_for_status()\n            cat_fact_data = response.json()\n            fact_text = cat_fact_data.get(\"fact\", \"Cats are mysterious creatures.\")\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact from external API\")\n            fact_text = \"Cats are mysterious creatures.\"\n\n    entity[\"factText\"] = fact_text\n    entity[\"sentAt\"] = datetime.utcnow().isoformat()\n    entity[\"emailsSent\"] = 0\n\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to get subscribers inside cat_fact_sent workflow\")\n        subscribers = []\n\n    send_tasks = []\n    for sub in subscribers:\n        email = sub.get(\"email\")\n        if email:\n            send_tasks.append(send_email(\n                email,\n                subject=\"Your Weekly Cat Fact \ud83d\udc31\",\n                body=fact_text,\n            ))\n\n    send_results = await asyncio.gather(*send_tasks, return_exceptions=True)\n    success_count = sum(1 for r in send_results if not isinstance(r, Exception))\n    entity[\"emailsSent\"] = success_count\n\n    interaction_metrics[\"totalEmailsSent\"] += success_count\n\n    cat_fact_log_entity = {\n        \"factText\": fact_text,\n        \"sentAt\": entity[\"sentAt\"],\n        \"emailsSent\": success_count,\n        \"factId\": str(uuid.uuid4()),\n    }\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_fact_log\",\n            entity_version=ENTITY_VERSION,\n            entity=cat_fact_log_entity,\n            workflow=None,\n        )\n    except Exception:\n        logger.exception(\"Failed to add cat_fact_log entity in cat_fact_sent workflow\")\n\n    logger.info(f\"Cat fact sent to {success_count} subscribers with fact: {fact_text}\")\n\n    return entity",
                "name": "process_cat_fact_sent"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SubscribeRequest:\n    email: str\n\ninteraction_metrics = {\n    \"totalEmailsSent\": 0,\n    \"totalClicks\": 0,  # TODO: Implement tracking clicks from emails (placeholder)\n    \"totalOpens\": 0,   # TODO: Implement tracking email opens (placeholder)\n}\n\nCAT_FACT_API_URL = \"https://catfact.ninja/fact\"\n\nasync def send_email(email: str, subject: str, body: str) -> None:\n    # TODO: Replace with real email sending implementation\n    logger.info(f\"Sending email to {email} with subject '{subject}' and body: {body}\")\n    await asyncio.sleep(0.1)\n\nasync def process_subscriber(entity: Dict[str, Any]) -> Dict[str, Any]:\n    email = entity.get(\"email\")\n    if email:\n        normalized_email = email.lower()\n        entity[\"email\"] = normalized_email\n\n        async def _send_welcome_email():\n            try:\n                await send_email(\n                    normalized_email,\n                    subject=\"Welcome to Cat Facts!\",\n                    body=\"Thank you for subscribing to Cat Facts!\"\n                )\n                logger.info(f\"Welcome email sent to {normalized_email}\")\n            except Exception as e:\n                logger.exception(f\"Failed to send welcome email to {normalized_email}: {e}\")\n\n        asyncio.create_task(_send_welcome_email())\n\n    if \"subscribedAt\" not in entity:\n        entity[\"subscribedAt\"] = datetime.utcnow().isoformat()\n\n    return entity\n\nasync def process_cat_fact_sent(entity: Dict[str, Any]) -> Dict[str, Any]:\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(CAT_FACT_API_URL, timeout=10)\n            response.raise_for_status()\n            cat_fact_data = response.json()\n            fact_text = cat_fact_data.get(\"fact\", \"Cats are mysterious creatures.\")\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact from external API\")\n            fact_text = \"Cats are mysterious creatures.\"\n\n    entity[\"factText\"] = fact_text\n    entity[\"sentAt\"] = datetime.utcnow().isoformat()\n    entity[\"emailsSent\"] = 0\n\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to get subscribers inside cat_fact_sent workflow\")\n        subscribers = []\n\n    send_tasks = []\n    for sub in subscribers:\n        email = sub.get(\"email\")\n        if email:\n            send_tasks.append(send_email(\n                email,\n                subject=\"Your Weekly Cat Fact \ud83d\udc31\",\n                body=fact_text,\n            ))\n\n    send_results = await asyncio.gather(*send_tasks, return_exceptions=True)\n    success_count = sum(1 for r in send_results if not isinstance(r, Exception))\n    entity[\"emailsSent\"] = success_count\n\n    interaction_metrics[\"totalEmailsSent\"] += success_count\n\n    cat_fact_log_entity = {\n        \"factText\": fact_text,\n        \"sentAt\": entity[\"sentAt\"],\n        \"emailsSent\": success_count,\n        \"factId\": str(uuid.uuid4()),\n    }\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_fact_log\",\n            entity_version=ENTITY_VERSION,\n            entity=cat_fact_log_entity,\n            workflow=None,\n        )\n    except Exception:\n        logger.exception(\"Failed to add cat_fact_log entity in cat_fact_sent workflow\")\n\n    logger.info(f\"Cat fact sent to {success_count} subscribers with fact: {fact_text}\")\n\n    return entity\n\n@app.route(\"/subscribe\", methods=[\"POST\"])\n@validate_request(SubscribeRequest)\nasync def subscribe(data: SubscribeRequest):\n    email = data.email\n    if not email:\n        return jsonify({\"error\": \"Email is required\"}), 400\n\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n\n    try:\n        items = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n            condition=condition,\n        )\n    except Exception:\n        logger.exception(\"Failed to check existing subscriber\")\n        return jsonify({\"error\": \"Failed to check existing subscriber\"}), 500\n\n    if items:\n        existing_id = items[0].get(\"id\")\n        return jsonify({\"message\": \"Email already subscribed\", \"subscriberId\": existing_id}), 200\n\n    data_dict = {\"email\": email}\n    try:\n        new_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n    except Exception:\n        logger.exception(\"Failed to add subscriber\")\n        return jsonify({\"error\": \"Failed to add subscriber\"}), 500\n\n    logger.info(f\"New subscriber added: {email} with id {new_id}\")\n    return jsonify({\"message\": \"Subscription successful\", \"subscriberId\": new_id}), 201\n\n@app.route(\"/subscribers/count\", methods=[\"GET\"])\nasync def subscribers_count():\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n        )\n        count = len(items)\n    except Exception:\n        logger.exception(\"Failed to retrieve subscribers count\")\n        return jsonify({\"error\": \"Failed to retrieve subscribers count\"}), 500\n    return jsonify({\"count\": count})\n\n@app.route(\"/facts/ingest-and-send\", methods=[\"POST\"])\nasync def ingest_and_send():\n    try:\n        new_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_fact_sent\",\n            entity_version=ENTITY_VERSION,\n            entity={}\n        )\n    except Exception:\n        logger.exception(\"Failed to ingest and send cat fact\")\n        return jsonify({\"error\": \"Failed to ingest and send cat fact\"}), 500\n\n    return jsonify({\"message\": \"Cat fact ingested and sent\", \"catFactSentId\": new_id})\n\n@app.route(\"/reports/interactions\", methods=[\"GET\"])\nasync def reports_interactions():\n    return jsonify(interaction_metrics)\n\nif __name__ == \"__main__\":\n    import sys\n\n    logging.basicConfig(\n        stream=sys.stdout,\n        format=\"%(asctime)s %(levelname)s %(name)s - %(message)s\",\n        level=logging.INFO,\n    )\n\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}