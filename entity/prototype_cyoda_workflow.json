{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime",
                "content": "async def process_pet(entity: dict):\n    # Add a processedAt timestamp before persistence.\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()",
                "name": "process_pet"
            }
        },
        {
            "entity_model_name": "pet_fetch_job",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Also depends on fetch_pets_from_petstore function and entity_service, cyoda_auth_service, ENTITY_VERSION from the file",
                "content": "async def process_pet_fetch_job(entity: dict):\n    # Guard against multiple runs if already completed or failed\n    if entity.get(\"status\") in (\"completed\", \"failed\"):\n        return\n\n    entity[\"status\"] = \"processing\"\n    entity[\"startedAt\"] = datetime.utcnow().isoformat()\n\n    # Defensive: petstore api params must not be None type\n    pet_type = entity.get(\"type\")\n    status_filter = entity.get(\"status_filter\")\n    limit = entity.get(\"limit\")\n    try:\n        pets = await fetch_pets_from_petstore(\n            pet_type=pet_type,\n            status=status_filter,\n            limit=limit\n        )\n        stored_ids = []\n        for pet in pets:\n            pet_data = pet.copy()\n            if \"id\" in pet_data:\n                pet_data[\"id\"] = str(pet_data[\"id\"])\n            # Add pet entity with workflow\n            new_id = await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet\",\n                entity_version=ENTITY_VERSION,\n                entity=pet_data,\n                workflow=process_pet\n            )\n            stored_ids.append(new_id)\n\n        entity[\"status\"] = \"completed\"\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n        entity[\"result_count\"] = len(stored_ids)\n        entity[\"stored_ids\"] = stored_ids\n\n    except Exception as e:\n        logger.exception(\"Error in pet_fetch_job workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()",
                "name": "process_pet_fetch_job"
            }
        },
        {
            "entity_model_name": "pet_filter_job",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Also depends on apply_filter_logic_sync function and entity_service, cyoda_auth_service, ENTITY_VERSION from the file",
                "content": "async def process_pet_filter_job(entity: dict):\n    if entity.get(\"status\") in (\"completed\", \"failed\"):\n        return\n\n    entity[\"status\"] = \"processing\"\n    entity[\"startedAt\"] = datetime.utcnow().isoformat()\n\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        filtered = apply_filter_logic_sync(\n            pets,\n            min_age=entity.get(\"min_age\"),\n            max_age=entity.get(\"max_age\"),\n            fun_category=entity.get(\"fun_category\")\n        )\n        entity[\"status\"] = \"completed\"\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n        entity[\"result_count\"] = len(filtered)\n        entity[\"filtered_pets\"] = filtered\n\n    except Exception as e:\n        logger.exception(\"Error in pet_filter_job workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()",
                "name": "process_pet_filter_job"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n# DATA CLASSES FOR REQUESTS\n\n@dataclass\nclass FetchPetsRequest:\n    type: Optional[str] = None\n    status: Optional[str] = None\n    limit: Optional[int] = None\n\n@dataclass\nclass FilterPetsRequest:\n    min_age: Optional[int] = None\n    max_age: Optional[int] = None\n    fun_category: Optional[str] = None\n\n# EXTERNAL API UTILS\n\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"\n\nasync def fetch_pets_from_petstore(pet_type: Optional[str], status: Optional[str], limit: Optional[int]) -> List[Dict]:\n    url = f\"{PETSTORE_API_BASE}/pet/findByStatus\"\n    params = {\"status\": status or \"available\"}\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            response = await client.get(url, params=params)\n            response.raise_for_status()\n            pets = response.json()\n    except Exception as e:\n        logger.exception(f\"Failed to fetch pets: {e}\")\n        return []\n    if pet_type:\n        pets = [p for p in pets if p.get(\"category\") and p[\"category\"].get(\"name\", \"\").lower() == pet_type.lower()]\n    if limit:\n        pets = pets[:limit]\n    import random\n    normalized = []\n    for pet in pets:\n        normalized.append({\n            \"id\": str(pet.get(\"id\")),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else \"unknown\",\n            \"age\": random.randint(1, 10),  # Simulated age\n            \"status\": pet.get(\"status\"),\n            \"fun_category\": None,\n        })\n    return normalized\n\n# FILTER LOGIC\n\ndef apply_filter_logic_sync(pets: List[Dict], min_age: Optional[int], max_age: Optional[int], fun_category: Optional[str]) -> List[Dict]:\n    filtered = []\n    for pet in pets:\n        age = pet.get(\"age\")\n        if min_age is not None and (age is None or age < min_age):\n            continue\n        if max_age is not None and (age is None or age > max_age):\n            continue\n        p = pet.copy()\n        if fun_category:\n            p[\"fun_category\"] = fun_category\n        else:\n            if age is not None:\n                if age <= 3:\n                    p[\"fun_category\"] = \"playful\"\n                elif age >= 7:\n                    p[\"fun_category\"] = \"sleepy\"\n                else:\n                    p[\"fun_category\"] = \"neutral\"\n            else:\n                p[\"fun_category\"] = \"unknown\"\n        filtered.append(p)\n    return filtered\n\n# WORKFLOW FUNCTIONS\n\nasync def process_pet(entity: dict):\n    # Add a processedAt timestamp before persistence.\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n\nasync def process_pet_fetch_job(entity: dict):\n    # Guard against multiple runs if already completed or failed\n    if entity.get(\"status\") in (\"completed\", \"failed\"):\n        return\n\n    entity[\"status\"] = \"processing\"\n    entity[\"startedAt\"] = datetime.utcnow().isoformat()\n\n    # Defensive: petstore api params must not be None type\n    pet_type = entity.get(\"type\")\n    status_filter = entity.get(\"status_filter\")\n    limit = entity.get(\"limit\")\n    try:\n        pets = await fetch_pets_from_petstore(\n            pet_type=pet_type,\n            status=status_filter,\n            limit=limit\n        )\n        stored_ids = []\n        for pet in pets:\n            pet_data = pet.copy()\n            if \"id\" in pet_data:\n                pet_data[\"id\"] = str(pet_data[\"id\"])\n            # Add pet entity with workflow\n            new_id = await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet\",\n                entity_version=ENTITY_VERSION,\n                entity=pet_data\n            )\n            stored_ids.append(new_id)\n\n        entity[\"status\"] = \"completed\"\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n        entity[\"result_count\"] = len(stored_ids)\n        entity[\"stored_ids\"] = stored_ids\n\n    except Exception as e:\n        logger.exception(\"Error in pet_fetch_job workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n\nasync def process_pet_filter_job(entity: dict):\n    if entity.get(\"status\") in (\"completed\", \"failed\"):\n        return\n\n    entity[\"status\"] = \"processing\"\n    entity[\"startedAt\"] = datetime.utcnow().isoformat()\n\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        filtered = apply_filter_logic_sync(\n            pets,\n            min_age=entity.get(\"min_age\"),\n            max_age=entity.get(\"max_age\"),\n            fun_category=entity.get(\"fun_category\")\n        )\n        entity[\"status\"] = \"completed\"\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n        entity[\"result_count\"] = len(filtered)\n        entity[\"filtered_pets\"] = filtered\n\n    except Exception as e:\n        logger.exception(\"Error in pet_filter_job workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n        entity[\"completedAt\"] = datetime.utcnow().isoformat()\n\n# ENDPOINTS\n\n@app.route(\"/pets/fetch\", methods=[\"POST\"])\n@validate_request(FetchPetsRequest)\nasync def pets_fetch(data: FetchPetsRequest):\n    job_entity = {\n        \"type\": data.type,\n        \"status_filter\": data.status,\n        \"limit\": data.limit,\n        \"status\": \"pending\",\n        \"requestedAt\": datetime.utcnow().isoformat(),\n    }\n    job_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"pet_fetch_job\",\n        entity_version=ENTITY_VERSION,\n        entity=job_entity\n    )\n    return jsonify({\"message\": \"Fetch job started\", \"job_id\": job_id}), 202\n\n@app.route(\"/pets/filter\", methods=[\"POST\"])\n@validate_request(FilterPetsRequest)\nasync def pets_filter(data: FilterPetsRequest):\n    job_entity = {\n        \"min_age\": data.min_age,\n        \"max_age\": data.max_age,\n        \"fun_category\": data.fun_category,\n        \"status\": \"pending\",\n        \"requestedAt\": datetime.utcnow().isoformat(),\n    }\n    job_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"pet_filter_job\",\n        entity_version=ENTITY_VERSION,\n        entity=job_entity\n    )\n    return jsonify({\"message\": \"Filter job started\", \"job_id\": job_id}), 202\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def pets_get():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        return jsonify(pets)\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve pets\"}), 500\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def pet_get(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n        if not pet:\n            return jsonify({\"error\": \"Pet not found\"}), 404\n        return jsonify(pet)\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve pet\"}), 500\n\n@app.route(\"/jobs/<string:job_id>\", methods=[\"GET\"])\nasync def job_status(job_id: str):\n    job = await entity_service.get_item(\n        token=cyoda_auth_service,\n        entity_model=\"pet_fetch_job\",\n        entity_version=ENTITY_VERSION,\n        technical_id=job_id\n    )\n    if not job:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_filter_job\",\n            entity_version=ENTITY_VERSION,\n            technical_id=job_id\n        )\n    if not job:\n        return jsonify({\"error\": \"Job ID not found\"}), 404\n    return jsonify(job)\n\n# MAIN\n\nif __name__ == \"__main__\":\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO, format=\"%(asctime)s [%(levelname)s] %(message)s\")\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}