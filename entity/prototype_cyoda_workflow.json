{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nfrom typing import Dict, Any",
                "content": "async def process_pet(entity: Dict[str, Any]) -> Dict[str, Any]:\n    # Workflow function applied to pet entity asynchronously before persistence.\n    # Modify entity state here, add related entities of different models if needed.\n    entity[\"processed\"] = True\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n    # Example: Add a supplementary entity (commented out - enable as needed)\n    # await entity_service.add_item(\n    #     token=cyoda_auth_service,\n    #     entity_model=\"pet_history\",\n    #     entity_version=ENTITY_VERSION,\n    #     entity={\"pet_name\": entity.get(\"name\"), \"event\": \"added\", \"timestamp\": entity[\"processedAt\"]}\n    # )\n    return entity",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass\n\nfrom quart import Quart, request, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass PetSearch:\n    type: Optional[str] = None\n    status: Optional[str] = None\n    name: Optional[str] = None\n\n@dataclass\nclass PetAdd:\n    name: str\n    type: str\n    status: str\n    photoUrls: Optional[List[str]] = None\n\n@dataclass\nclass PetUpdate:\n    id: str\n    name: Optional[str] = None\n    type: Optional[str] = None\n    status: Optional[str] = None\n    photoUrls: Optional[List[str]] = None\n\n@dataclass\nclass PetDelete:\n    id: str\n\nentity_jobs: Dict[str, Dict[str, Any]] = {}\n\nPET_ENTITY_NAME = \"pet\"\n\nasync def process_pet(entity: Dict[str, Any]) -> Dict[str, Any]:\n    # Workflow function applied to pet entity asynchronously before persistence.\n    # Modify entity state here, add related entities of different models if needed.\n    entity[\"processed\"] = True\n    entity[\"processedAt\"] = datetime.utcnow().isoformat()\n    # Example: Add a supplementary entity (commented out - enable as needed)\n    # await entity_service.add_item(\n    #     token=cyoda_auth_service,\n    #     entity_model=\"pet_history\",\n    #     entity_version=ENTITY_VERSION,\n    #     entity={\"pet_name\": entity.get(\"name\"), \"event\": \"added\", \"timestamp\": entity[\"processedAt\"]}\n    # )\n    return entity\n\nasync def process_add_pet(data: Dict[str, Any], job_id: str) -> None:\n    try:\n        payload = {\n            \"name\": data.get(\"name\"),\n            \"photoUrls\": data.get(\"photoUrls\") or [],\n            \"status\": data.get(\"status\"),\n            \"category\": {\"name\": data.get(\"type\")} if data.get(\"type\") else None,\n        }\n        if payload[\"category\"] is None:\n            payload.pop(\"category\")\n\n        pet_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            entity=payload\n        )\n\n        entity_jobs[job_id].update({\n            \"status\": \"completed\",\n            \"result\": {\"id\": str(pet_id), \"message\": \"Pet add job submitted\"},\n            \"completedAt\": datetime.utcnow().isoformat()\n        })\n    except Exception as e:\n        logger.exception(\"Error adding pet\")\n        entity_jobs[job_id].update({\n            \"status\": \"failed\",\n            \"error\": str(e)\n        })\n\nasync def process_update_pet(data: Dict[str, Any], job_id: str) -> None:\n    try:\n        pet_id = data.get(\"id\")\n        if not pet_id:\n            raise ValueError(\"Pet id is required for update\")\n\n        payload = {\n            \"name\": data.get(\"name\"),\n            \"photoUrls\": data.get(\"photoUrls\") or [],\n            \"status\": data.get(\"status\"),\n            \"category\": {\"name\": data.get(\"type\")} if data.get(\"type\") else None,\n        }\n        payload = {k: v for k, v in payload.items() if v is not None}\n        if \"category\" in payload and payload[\"category\"] is None:\n            payload.pop(\"category\")\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            entity=payload,\n            technical_id=str(pet_id),\n            meta={}\n        )\n        entity_jobs[job_id].update({\n            \"status\": \"completed\",\n            \"result\": {\"message\": \"Pet update job submitted\"},\n            \"completedAt\": datetime.utcnow().isoformat()\n        })\n    except Exception as e:\n        logger.exception(\"Error updating pet\")\n        entity_jobs[job_id].update({\n            \"status\": \"failed\",\n            \"error\": str(e)\n        })\n\nasync def process_delete_pet(data: Dict[str, Any], job_id: str) -> None:\n    try:\n        pet_id = data.get(\"id\")\n        if not pet_id:\n            raise ValueError(\"Pet id is required for delete\")\n\n        await entity_service.delete_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            technical_id=str(pet_id),\n            meta={}\n        )\n        entity_jobs[job_id].update({\n            \"status\": \"completed\",\n            \"result\": {\"message\": \"Pet delete job submitted\"},\n            \"completedAt\": datetime.utcnow().isoformat()\n        })\n    except Exception as e:\n        logger.exception(\"Error deleting pet\")\n        entity_jobs[job_id].update({\n            \"status\": \"failed\",\n            \"error\": str(e)\n        })\n\nasync def process_search(criteria: Dict[str, Any]) -> None:\n    job_id = criteria.get(\"job_id\")\n    try:\n        conditions = []\n        if criteria.get(\"status\"):\n            conditions.append({\n                \"jsonPath\": \"$.status\",\n                \"operatorType\": \"EQUALS\",\n                \"value\": criteria[\"status\"],\n                \"type\": \"simple\"\n            })\n        if criteria.get(\"type\"):\n            conditions.append({\n                \"jsonPath\": \"$.category.name\",\n                \"operatorType\": \"IEQUALS\",\n                \"value\": criteria[\"type\"],\n                \"type\": \"simple\"\n            })\n        if criteria.get(\"name\"):\n            conditions.append({\n                \"jsonPath\": \"$.name\",\n                \"operatorType\": \"ICONTAINS\",\n                \"value\": criteria[\"name\"],\n                \"type\": \"simple\"\n            })\n\n        condition = {\n            \"cyoda\": {\n                \"type\": \"group\",\n                \"operator\": \"AND\",\n                \"conditions\": conditions\n            }\n        } if conditions else None\n\n        if condition:\n            pets = await entity_service.get_items_by_condition(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                condition=condition\n            )\n        else:\n            pets = await entity_service.get_items(\n                token=cyoda_auth_service,\n                entity_model=PET_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n            )\n\n        entity_jobs[job_id].update({\n            \"status\": \"completed\",\n            \"result\": {\"pets\": pets},\n            \"completedAt\": datetime.utcnow().isoformat()\n        })\n    except Exception as e:\n        logger.exception(\"Error processing pet search\")\n        entity_jobs[job_id].update({\n            \"status\": \"failed\",\n            \"error\": str(e)\n        })\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(PetSearch)\nasync def pets_search(data: PetSearch):\n    job_id = f\"search_{datetime.utcnow().timestamp()}\"\n    entity_jobs[job_id] = {\"status\": \"processing\", \"requestedAt\": datetime.utcnow().isoformat()}\n    criteria = data.__dict__.copy()\n    criteria[\"job_id\"] = job_id\n    asyncio.create_task(process_search(criteria))\n    return jsonify({\"job_id\": job_id}), 202\n\n@app.route(\"/pets/add\", methods=[\"POST\"])\n@validate_request(PetAdd)\nasync def pets_add(data: PetAdd):\n    job_id = f\"add_{datetime.utcnow().timestamp()}\"\n    entity_jobs[job_id] = {\"status\": \"processing\", \"requestedAt\": datetime.utcnow().isoformat()}\n    payload = data.__dict__.copy()\n    asyncio.create_task(process_add_pet(payload, job_id))\n    return jsonify({\"job_id\": job_id}), 202\n\n@app.route(\"/pets/update\", methods=[\"POST\"])\n@validate_request(PetUpdate)\nasync def pets_update(data: PetUpdate):\n    job_id = f\"update_{datetime.utcnow().timestamp()}\"\n    entity_jobs[job_id] = {\"status\": \"processing\", \"requestedAt\": datetime.utcnow().isoformat()}\n    payload = data.__dict__.copy()\n    asyncio.create_task(process_update_pet(payload, job_id))\n    return jsonify({\"job_id\": job_id}), 202\n\n@app.route(\"/pets/delete\", methods=[\"POST\"])\n@validate_request(PetDelete)\nasync def pets_delete(data: PetDelete):\n    job_id = f\"delete_{datetime.utcnow().timestamp()}\"\n    entity_jobs[job_id] = {\"status\": \"processing\", \"requestedAt\": datetime.utcnow().isoformat()}\n    payload = data.__dict__.copy()\n    asyncio.create_task(process_delete_pet(payload, job_id))\n    return jsonify({\"job_id\": job_id}), 202\n\n@app.route(\"/pets/job_status/<job_id>\", methods=[\"GET\"])\nasync def job_status(job_id: str):\n    job = entity_jobs.get(job_id)\n    if not job:\n        return jsonify({\"error\": \"Job not found\"}), 404\n    return jsonify(job)\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def get_pet(pet_id: str):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=PET_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n        if not pet:\n            return jsonify({\"error\": \"Pet not found\"}), 404\n        return jsonify(pet)\n    except Exception as e:\n        logger.exception(\"Failed to retrieve pet\")\n        return jsonify({\"error\": \"Failed to retrieve pet\"}), 500\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}