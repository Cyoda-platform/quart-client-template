{
    "entity_models": [
        {
            "entity_model_name": "subscriber",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime, timezone\n\nimport httpx\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# The following are referenced within the workflow function:\n# - fetch_cat_fact (async function)\n# - send_email (async function)\n# - cache (instance of Cache class)\n# - entity_service (external service)\n# - cyoda_auth_service (external token service)\n# - entity_name (string, 'subscriber')\n# - ENTITY_VERSION (constant)\n\n# Definitions for these are present in the file, shown above.",
                "content": "async def process_subscriber(entity_data: dict):\n    # Add subscribedAt timestamp if not present\n    if 'subscribedAt' not in entity_data:\n        entity_data['subscribedAt'] = datetime.now(timezone.utc).isoformat()\n\n    # Fetch a cat fact\n    try:\n        cat_fact = await fetch_cat_fact()\n    except Exception:\n        cat_fact = None\n\n    if cat_fact:\n        # Send a cat fact email to this subscriber\n        await send_email(entity_data['email'], cat_fact)\n\n        # Update latest fact and report caches\n        try:\n            await cache.update_latest_fact(cat_fact)\n        except Exception as e:\n            logger.error(f\"Failed to update latest fact and report cache: {e}\")\n\n    # Update subscriber count cache by querying current count asynchronously\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION\n        )\n        await cache.update_subscriber_count(len(items))\n    except Exception as e:\n        logger.error(f\"Failed to update subscriber count in cache: {e}\")",
                "name": "process_subscriber"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom typing import Dict\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass Subscriber:\n    email: str\n\n@dataclass\nclass SendRequest:\n    pass  # Empty dataclass for POST body; TODO: add fields if control params are needed\n\nentity_name = \"subscriber\"  # underscore lowercase entity name\n\n# In-memory async-safe caches for latest fact and report only\nclass Cache:\n    def __init__(self):\n        self._latest_fact: Dict = {}\n        self._report = {\n            \"subscriberCount\": 0,\n            \"factsSent\": 0,\n            \"lastSentAt\": None,\n        }\n        self._lock = asyncio.Lock()\n\n    async def update_latest_fact(self, fact: str):\n        async with self._lock:\n            now = datetime.now(timezone.utc).isoformat()\n            self._latest_fact = {\"catFact\": fact, \"sentAt\": now}\n            self._report[\"factsSent\"] += 1\n            self._report[\"lastSentAt\"] = now\n\n    async def get_latest_fact(self) -> Dict:\n        async with self._lock:\n            return dict(self._latest_fact)\n\n    async def get_report(self) -> Dict:\n        async with self._lock:\n            return dict(self._report)\n\n    async def update_subscriber_count(self, count: int):\n        async with self._lock:\n            self._report[\"subscriberCount\"] = count\n\ncache = Cache()\n\nasync def send_email(to_email: str, cat_fact: str):\n    # Simulate sending email asynchronously, handle errors silently to not interrupt flow\n    try:\n        await asyncio.sleep(0.1)\n        logger.info(f\"Sent cat fact email to {to_email}\")\n        # TODO: Integrate with real email service provider\n    except Exception as e:\n        logger.error(f\"Error sending email to {to_email}: {e}\")\n\nasync def fetch_cat_fact() -> str:\n    url = \"https://catfact.ninja/fact\"\n    try:\n        async with httpx.AsyncClient() as client:\n            resp = await client.get(url, timeout=10)\n            resp.raise_for_status()\n            data = resp.json()\n            fact = data.get(\"fact\")\n            if not fact:\n                raise ValueError(\"No 'fact' field in response from Cat Fact API\")\n            return fact\n    except Exception as e:\n        logger.error(f\"Failed to fetch cat fact: {e}\")\n        raise\n\n# Workflow function applied to the entity asynchronously before persistence.\n# This function takes the entity data as the only argument.\n# You can change entity state inside this function.\nasync def process_subscriber(entity_data: dict):\n    # Add subscribedAt timestamp if not present\n    if 'subscribedAt' not in entity_data:\n        entity_data['subscribedAt'] = datetime.now(timezone.utc).isoformat()\n\n    # Fetch a cat fact\n    try:\n        cat_fact = await fetch_cat_fact()\n    except Exception:\n        cat_fact = None\n\n    if cat_fact:\n        # Send a cat fact email to this subscriber\n        await send_email(entity_data['email'], cat_fact)\n\n        # Update latest fact and report caches\n        try:\n            await cache.update_latest_fact(cat_fact)\n        except Exception as e:\n            logger.error(f\"Failed to update latest fact and report cache: {e}\")\n\n    # Update subscriber count cache by querying current count asynchronously\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION\n        )\n        await cache.update_subscriber_count(len(items))\n    except Exception as e:\n        logger.error(f\"Failed to update subscriber count in cache: {e}\")\n\n@app.route(\"/api/subscribers\", methods=[\"POST\"])\n@validate_request(Subscriber)  # Workaround: place validate_request last for POST due to quart-schema defect\nasync def subscribe(data: Subscriber):\n    email = data.email.strip().lower()\n    if not email or \"@\" not in email:\n        return jsonify({\"error\": \"Invalid or missing email\"}), 400\n\n    # Check if subscriber exists by condition\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n    try:\n        existing_subs = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to check existing subscribers\"}), 500\n\n    if existing_subs:\n        return jsonify({\"error\": \"Email already subscribed\"}), 400\n\n    data_dict = {\"email\": email}\n    try:\n        new_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add subscriber\"}), 500\n\n    logger.info(f\"New subscriber added: {email} with id {new_id}\")\n    return jsonify({\"id\": str(new_id)}), 201\n\n@app.route(\"/api/subscribers\", methods=[\"GET\"])\nasync def list_subscribers():\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve subscribers\"}), 500\n\n    subs = [{\"email\": item.get(\"email\")} for item in items if \"email\" in item]\n    return jsonify({\"subscribers\": subs, \"count\": len(subs)}), 200\n\n@app.route(\"/api/catfact/send\", methods=[\"POST\"])\n@validate_request(SendRequest)  # Workaround: place validate_request last for POST due to quart-schema defect\nasync def send_cat_fact(data: SendRequest):\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve subscribers\"}), 500\n\n    subscribers = [item.get(\"email\") for item in items if \"email\" in item]\n    if not subscribers:\n        return jsonify({\"error\": \"No subscribers to send emails to\"}), 400\n\n    try:\n        cat_fact = await fetch_cat_fact()\n    except Exception:\n        return jsonify({\"error\": \"Failed to fetch cat fact\"}), 500\n\n    # Send emails concurrently, but protect against exceptions stopping others\n    async def safe_send(email):\n        try:\n            await send_email(email, cat_fact)\n        except Exception as e:\n            logger.error(f\"Failed to send cat fact email to {email}: {e}\")\n\n    await asyncio.gather(*(safe_send(email) for email in subscribers))\n\n    # Update latest fact and report caches atomically\n    try:\n        await cache.update_latest_fact(cat_fact)\n    except Exception as e:\n        logger.error(f\"Failed to update latest fact and report cache: {e}\")\n\n    # Update subscriber count cache\n    try:\n        await cache.update_subscriber_count(len(subscribers))\n    except Exception as e:\n        logger.error(f\"Failed to update subscriber count in cache: {e}\")\n\n    logger.info(f\"Cat fact sent to {len(subscribers)} subscribers\")\n\n    return jsonify({\"catFact\": cat_fact, \"emailsSent\": len(subscribers)}), 200\n\n@app.route(\"/api/catfact/latest\", methods=[\"GET\"])\nasync def get_latest_cat_fact():\n    latest = await cache.get_latest_fact()\n    if not latest:\n        return jsonify({\"error\": \"No cat fact sent yet\"}), 404\n    return jsonify(latest), 200\n\n@app.route(\"/api/report\", methods=[\"GET\"])\nasync def get_report():\n    report = await cache.get_report()\n    return jsonify(report), 200\n\nif __name__ == '__main__':\n    import sys\n\n    logging.basicConfig(\n        format='[%(asctime)s] %(levelname)s in %(module)s: %(message)s',\n        level=logging.INFO,\n        stream=sys.stdout,\n    )\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}