{
    "entity_models": [
        {
            "entity_model_name": "pet_adoption",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport httpx\nimport logging\nfrom app_init.app_init import BeanFactory\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\ncache = Cache()",
                "content": "async def process_pet_adoption(entity: dict):\n    \"\"\"\n    Workflow for 'pet_adoption' entity.\n    - Validate pet exists and is available.\n    - Check if already adopted.\n    - Enrich entity with pet details and adoption info.\n    - Update in-memory cache as supplementary (example of secondary entity).\n    \"\"\"\n    pet_id = entity.get(\"id\")\n    if not pet_id:\n        raise ValueError(\"Pet ID is required for adoption.\")\n\n    # Fetch pet info from petstore\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            r = await client.get(f\"https://petstore3.swagger.io/api/v3/pet/{pet_id}\")\n            r.raise_for_status()\n            pet = r.json()\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise ValueError(\"Pet not found.\")\n            logger.exception(f\"HTTP error fetching pet {pet_id}: {e}\")\n            raise RuntimeError(\"Error fetching pet info.\")\n        except Exception as e:\n            logger.exception(f\"Error fetching pet {pet_id}: {e}\")\n            raise RuntimeError(\"Error fetching pet info.\")\n\n    if pet.get(\"status\") != \"available\":\n        raise ValueError(\"Pet is not available for adoption.\")\n\n    # Check in-memory cache if already adopted\n    # This is an example of querying a secondary entity to prevent duplicates\n    async with cache.lock:\n        if pet_id in cache.adopted_pets:\n            raise ValueError(\"Pet already adopted.\")\n\n    # Enrich entity with pet details\n    entity[\"name\"] = pet.get(\"name\")\n    entity[\"type\"] = pet.get(\"category\", {}).get(\"name\")\n    entity[\"adoptionDate\"] = datetime.utcnow().isoformat() + \"Z\"\n    entity[\"message\"] = f\"Congratulations on adopting {entity['name']}! \u000f\u000f\u000f\u000f\"  \n\n    # Update in-memory cache as a secondary/supplementary entity\n    # This simulates adding/updating another entity_model different from 'pet_adoption'\n    async with cache.lock:\n        cache.adopted_pets[pet_id] = {\n            \"id\": pet_id,\n            \"name\": entity[\"name\"],\n            \"type\": entity[\"type\"],\n            \"adoptionDate\": entity[\"adoptionDate\"],\n            \"message\": entity[\"message\"],\n        }}",
                "name": "process_pet_adoption"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\n\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SearchPets:\n    type: Optional[str] = None\n    status: Optional[str] = None\n    name: Optional[str] = None\n\n@dataclass\nclass AdoptPet:\n    petid: str\n\n@dataclass\nclass FunFactsRequest:\n    type: Optional[str] = None\n    name: Optional[str] = None\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"\n\n# In-memory cache for adopted pets (used only for read in endpoint)\n# We keep it for quick access, but persistence is via entity_service\nclass Cache:\n    def __init__(self):\n        self.adopted_pets: Dict[str, Dict] = {}\n        self.lock = asyncio.Lock()\n\ncache = Cache()\n\nasync def fetch_pets_from_petstore(type_: Optional[str] = None, status: Optional[str] = None, name: Optional[str] = None) -> List[Dict]:\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        if status:\n            try:\n                r = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params={\"status\": status})\n                r.raise_for_status()\n                pets = r.json()\n            except Exception as e:\n                logger.exception(f\"Error fetching pets by status from Petstore: {e}\")\n                pets = []\n        else:\n            pets = []\n            for s in [\"available\", \"pending\", \"sold\"]:\n                try:\n                    r = await client.get(f\"{PETSTORE_BASE_URL}/pet/findByStatus\", params={\"status\": s})\n                    r.raise_for_status()\n                    pets.extend(r.json())\n                except Exception as e:\n                    logger.exception(f\"Error fetching pets by status '{s}' from Petstore: {e}\")\n\n        def matches_criteria(pet):\n            if type_ and pet.get(\"category\", {}).get(\"name\", \"\").lower() != type_.lower():\n                return False\n            if name and name.lower() not in pet.get(\"name\", \"\").lower():\n                return False\n            return True\n\n        filtered = [pet for pet in pets if matches_criteria(pet)]\n        return filtered\n\ndef generate_fun_description(pet: Dict) -> str:\n    jokes = {\n        \"cat\": \"Did you know cats can make over 100 vocal sounds? Purrhaps it\u001999s true!\",\n        \"dog\": \"Dogs\u001999 noses are wet to help absorb scent chemicals. Sniff-tastic!\",\n        \"bird\": \"Birds are the only animals with feathers, they really know how to dress up!\",\n    }\n    pet_type = pet.get(\"category\", {}).get(\"name\", \"\").lower()\n    name = pet.get(\"name\", \"Your new friend\")\n    return jokes.get(pet_type, f\"{name} is as awesome as any pet you can imagine!\")\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchPets)\nasync def pets_search(data: SearchPets):\n    pets_raw = await fetch_pets_from_petstore(data.type, data.status, data.name)\n    pets = []\n    for p in pets_raw:\n        pets.append(\n            {\n                \"id\": p.get(\"id\"),\n                \"name\": p.get(\"name\"),\n                \"type\": p.get(\"category\", {}).get(\"name\"),\n                \"status\": p.get(\"status\"),\n                \"description\": generate_fun_description(p),\n                \"imageUrl\": p.get(\"photoUrls\")[0] if p.get(\"photoUrls\") else None,\n            }\n        )\n    return jsonify({\"pets\": pets})\n\n@app.route(\"/pets/adopt\", methods=[\"POST\"])\n@validate_request(AdoptPet)\nasync def pets_adopt(data: AdoptPet):\n    # Minimal entity data: just id, workflow will enrich and validate\n    adoption_entity_data = {\n        \"id\": str(data.petid),\n    }\n\n    try:\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_adoption\",\n            entity_version=ENTITY_VERSION,\n            entity=adoption_entity_data\n        )\n    except Exception as e:\n        # Assume workflow raised an Exception in case of validation error or fetch error\n        logger.exception(f\"Adoption failed: {e}\")\n        return jsonify({\"success\": False, \"message\": str(e)}), 400\n\n    return jsonify({\"success\": True, \"message\": f\"Pet adopted successfully!\", \"entityId\": entity_id})\n\n@app.route(\"/pets/adopted\", methods=[\"GET\"])\nasync def pets_adopted():\n    async with cache.lock:\n        adopted_list = list(cache.adopted_pets.values())\n    return jsonify({\"adoptedPets\": adopted_list})\n\n@app.route(\"/pets/fun-facts\", methods=[\"POST\"])\n@validate_request(FunFactsRequest)\nasync def pets_fun_facts(data: FunFactsRequest):\n    type_ = data.type.lower() if data.type else None\n    name = data.name\n\n    facts = {\n        \"cat\": \"Cats sleep for 70% of their lives. Talk about a catnap!\",\n        \"dog\": \"Dogs\u001999 sense of smell is at least 40x better than humans\u001999!\",\n        \"bird\": \"Some birds can mimic human speech amazingly well.\",\n    }\n\n    if type_ in facts:\n        fact = facts[type_]\n    elif name:\n        fact = f\"{name} is truly one of a kind and full of surprises!\"\n    else:\n        fact = \"Pets make life pawsome! \u001f\u001f\u001f\u001f\u001f\u001f\"\n\n    return jsonify({\"fact\": fact})\n\n# Workflow function removed from this version"
    }
}