{
    "entity_models": [
        {
            "entity_model_name": "subscriber",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def send_email(to_email: str, subject: str, body: str):\n    # TODO: Implement real email service\n    logger.info(f\"Sending email to {to_email} with subject '{subject}' and body: {body}\")",
                "content": "async def process_subscriber(entity: dict) -> dict:\n    \"\"\"\n    This workflow runs after subscriber creation.\n    Could be used to send welcome email or initialize related data.\n    \"\"\"\n    email = entity.get(\"email\")\n    name = entity.get(\"name\", \"\")\n    if email:\n        try:\n            await send_email(email, \"Welcome to Cat Facts Newsletter\",\n                             f\"Hello {name or 'subscriber'}, thank you for subscribing!\")\n        except Exception as e:\n            logger.error(f\"Failed to send welcome email to {email}: {e}\")\n    return entity",
                "name": "process_subscriber"
            }
        },
        {
            "entity_model_name": "cat_fact",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def send_email(to_email: str, subject: str, body: str):\n    # TODO: Implement real email service\n    logger.info(f\"Sending email to {to_email} with subject '{subject}' and body: {body}\")",
                "content": "async def process_cat_fact(entity: dict) -> dict:\n    \"\"\"\n    This workflow runs after the cat_fact entity is created.\n    It sends the fact to all subscribers asynchronously.\n    \"\"\"\n    fact_text = entity.get(\"fact\")\n    if not fact_text:\n        logger.warning(\"Cat fact entity missing 'fact' key\")\n        return entity\n\n    # Get all subscribers\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.error(f\"Failed to retrieve subscribers in cat_fact workflow: {e}\")\n        return entity\n\n    # Send emails concurrently for speed\n    async def send_to_sub(sub):\n        try:\n            await send_email(sub[\"email\"], \"Your Weekly Cat Fact \u001f\u001f\", fact_text)\n        except Exception as e:\n            logger.error(f\"Failed to send email to {sub['email']}: {e}\")\n\n    await asyncio.gather(*(send_to_sub(sub) for sub in subscribers.values()))\n    return entity",
                "name": "process_cat_fact"
            }
        },
        {
            "entity_model_name": "interaction",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "",
                "content": "async def process_interaction(entity: dict) -> dict:\n    \"\"\"\n    Placeholder workflow for interactions.\n    Extend if you want to trigger side effects upon interaction recording.\n    \"\"\"\n    # For now, no additional async operations needed\n    return entity",
                "name": "process_interaction"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\n\nimport httpx\nfrom dataclasses import dataclass\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SubscriptionRequest:\n    email: str\n    name: Optional[str] = None\n\n@dataclass\nclass InteractionRequest:\n    subscriberId: str\n    interactionType: str\n    factId: str\n\nCAT_FACT_API_URL = \"https://catfact.ninja/fact\"\n\nasync def fetch_cat_fact() -> dict:\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(CAT_FACT_API_URL, timeout=10)\n            resp.raise_for_status()\n            return resp.json()\n        except Exception as e:\n            logger.exception(f\"Failed to fetch cat fact: {e}\")\n            raise\n\nasync def send_email(to_email: str, subject: str, body: str):\n    # TODO: Implement real email service\n    logger.info(f\"Sending email to {to_email} with subject '{subject}' and body: {body}\")\n\n# Workflow functions\n\nasync def process_cat_fact(entity: dict) -> dict:\n    \"\"\"\n    This workflow runs after the cat_fact entity is created.\n    It sends the fact to all subscribers asynchronously.\n    \"\"\"\n    fact_text = entity.get(\"fact\")\n    if not fact_text:\n        logger.warning(\"Cat fact entity missing 'fact' key\")\n        return entity\n\n    # Get all subscribers\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.error(f\"Failed to retrieve subscribers in cat_fact workflow: {e}\")\n        return entity\n\n    # Send emails concurrently for speed\n    async def send_to_sub(sub):\n        try:\n            await send_email(sub[\"email\"], \"Your Weekly Cat Fact \u001f\u001f\", fact_text)\n        except Exception as e:\n            logger.error(f\"Failed to send email to {sub['email']}: {e}\")\n\n    await asyncio.gather(*(send_to_sub(sub) for sub in subscribers.values()))\n    return entity\n\nasync def process_subscriber(entity: dict) -> dict:\n    \"\"\"\n    This workflow runs after subscriber creation.\n    Could be used to send welcome email or initialize related data.\n    \"\"\"\n    email = entity.get(\"email\")\n    name = entity.get(\"name\", \"\")\n    if email:\n        try:\n            await send_email(email, \"Welcome to Cat Facts Newsletter\",\n                             f\"Hello {name or 'subscriber'}, thank you for subscribing!\")\n        except Exception as e:\n            logger.error(f\"Failed to send welcome email to {email}: {e}\")\n    return entity\n\nasync def process_interaction(entity: dict) -> dict:\n    \"\"\"\n    Placeholder workflow for interactions.\n    Extend if you want to trigger side effects upon interaction recording.\n    \"\"\"\n    # For now, no additional async operations needed\n    return entity\n\n# Routes\n\n@app.route(\"/subscribe\", methods=[\"POST\"])\n@validate_request(SubscriptionRequest)\nasync def subscribe(data: SubscriptionRequest):\n    email = data.email\n    name = data.name\n    if not email:\n        return jsonify({\"message\": \"Email is required\"}), 400\n\n    # Check if email already subscribed\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.error(f\"Failed to get subscribers: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    for sub_id, sub in subscribers.items():\n        if sub.get(\"email\", \"\").lower() == email.lower():\n            return jsonify({\"message\": \"Email already subscribed\", \"subscriberId\": sub_id}), 200\n\n    subscriber_data = {\"email\": email, \"name\": name}\n    try:\n        subscriber_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n            entity=subscriber_data\n        )\n    except Exception as e:\n        logger.error(f\"Failed to add subscriber: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    logger.info(f\"New subscriber added: {email} (id: {subscriber_id})\")\n    return jsonify({\"message\": \"Subscription successful\", \"subscriberId\": subscriber_id}), 201\n\n\n@app.route(\"/subscribers/count\", methods=[\"GET\"])\nasync def get_subscribers_count():\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.error(f\"Failed to get subscribers count: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    return jsonify({\"count\": len(subscribers)})\n\n\n@app.route(\"/fetch-and-send-fact\", methods=[\"POST\"])\nasync def fetch_and_send_fact():\n    requested_at = datetime.utcnow().isoformat()\n    try:\n        # Fetch cat fact BEFORE creating entity\n        cat_fact_data = await fetch_cat_fact()\n        fact_text = cat_fact_data.get(\"fact\", \"No fact retrieved\")\n        fact_data = {\"fact\": fact_text, \"createdAt\": datetime.utcnow().isoformat()}\n\n        # Add cat_fact entity with workflow that sends emails to subscribers\n        fact_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_fact\",\n            entity_version=ENTITY_VERSION,\n            entity=fact_data\n        )\n\n        return jsonify({\n            \"message\": \"Cat fact sent to subscribers\",\n            \"fact\": fact_text,\n            \"factId\": fact_id,\n            \"sentAt\": requested_at\n        })\n    except Exception as e:\n        logger.error(f\"Failed to fetch and send cat fact: {e}\")\n        return jsonify({\"message\": \"Failed to fetch and send cat fact\"}), 500\n\n\n@app.route(\"/interaction\", methods=[\"POST\"])\n@validate_request(InteractionRequest)\nasync def record_interaction(data: InteractionRequest):\n    subscriber_id = data.subscriberId\n    interaction_type = data.interactionType\n    fact_id = data.factId\n\n    # Check subscriber exists\n    try:\n        subscriber = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n            technical_id=subscriber_id\n        )\n    except Exception as e:\n        logger.error(f\"Failed to get subscriber {subscriber_id}: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    if subscriber is None:\n        return jsonify({\"message\": \"Subscriber not found\"}), 404\n\n    # Check fact exists\n    try:\n        fact = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"cat_fact\",\n            entity_version=ENTITY_VERSION,\n            technical_id=fact_id\n        )\n    except Exception as e:\n        logger.error(f\"Failed to get cat fact {fact_id}: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    if fact is None:\n        return jsonify({\"message\": \"Fact not found\"}), 404\n\n    if interaction_type not in (\"open\", \"click\"):\n        return jsonify({\"message\": \"Invalid interactionType\"}), 400\n\n    interaction_data = {\n        \"subscriberId\": subscriber_id,\n        \"interactionType\": interaction_type,\n        \"factId\": fact_id,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"interaction\",\n            entity_version=ENTITY_VERSION,\n            entity=interaction_data\n        )\n    except Exception as e:\n        logger.error(f\"Failed to add interaction: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    logger.info(f\"Recorded interaction: sub={subscriber_id}, type={interaction_type}, fact={fact_id}\")\n    return jsonify({\"message\": \"Interaction recorded\"})\n\n\n@app.route(\"/interactions/report\", methods=[\"GET\"])\nasync def interactions_report():\n    try:\n        interactions = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"interaction\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.error(f\"Failed to get interactions: {e}\")\n        return jsonify({\"message\": \"Internal server error\"}), 500\n\n    total_opens = sum(1 for i in interactions.values() if i.get(\"interactionType\") == \"open\")\n    total_clicks = sum(1 for i in interactions.values() if i.get(\"interactionType\") == \"click\")\n    return jsonify({\"totalOpens\": total_opens, \"totalClicks\": total_clicks})\n\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO,\n                        format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\")\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}