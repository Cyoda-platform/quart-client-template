{
    "entity_models": [
        {
            "entity_model_name": "subscriber",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime, timezone\nimport asyncio\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_subscriber(entity: dict) -> dict:\n    \"\"\"\n    Workflow function applied to subscriber entity before persistence.\n    - Adds createdAt timestamp\n    - Sends welcome email asynchronously (fire-and-forget)\n    \"\"\"\n    if \"createdAt\" not in entity:\n        entity[\"createdAt\"] = datetime.now(timezone.utc).isoformat()\n\n    async def send_welcome_email():\n        try:\n            await asyncio.sleep(0.05)  # Simulate sending email\n            logger.info(f\"Welcome email sent to {entity.get('email')}\")\n        except Exception:\n            logger.exception(\"Failed to send welcome email\")\n\n    # Fire and forget sending welcome email\n    asyncio.create_task(send_welcome_email())\n\n    return entity",
                "name": "process_subscriber"
            }
        },
        {
            "entity_model_name": "fact",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import httpx\nfrom datetime import datetime, timezone\nimport asyncio\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n# Dependencies: entity_service, cyoda_auth_service, ENTITY_VERSION (assumed imported or in scope)",
                "content": "async def process_fact(entity: dict) -> dict:\n    \"\"\"\n    Workflow function applied to fact entity before persistence.\n    - Fetches a cat fact if 'fact' not provided\n    - Adds sentDate timestamp if missing\n    - Sends fact email to all subscribers asynchronously\n    - Updates emailsSent count on the fact entity before persisting\n    \"\"\"\n    if not entity.get(\"fact\"):\n        url = \"https://catfact.ninja/fact\"\n        try:\n            async with httpx.AsyncClient() as client:\n                resp = await client.get(url, timeout=10)\n                resp.raise_for_status()\n                data = resp.json()\n                entity[\"fact\"] = data.get(\"fact\", \"Cats are mysterious creatures!\")\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact\")\n            entity[\"fact\"] = \"Cats are mysterious creatures!\"\n\n    if \"sentDate\" not in entity:\n        entity[\"sentDate\"] = datetime.now(timezone.utc).isoformat()\n\n    # Initialize counts if missing\n    entity.setdefault(\"emailsSent\", 0)\n    entity.setdefault(\"emailsOpened\", 0)\n    entity.setdefault(\"linksClicked\", 0)\n\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to retrieve subscribers\")\n        subscribers = []\n\n    async def send_email(email: str, fact_text: str):\n        try:\n            await asyncio.sleep(0.05)  # Simulate sending email\n            logger.info(f\"Sent cat fact email to {email}\")\n        except Exception:\n            logger.exception(f\"Failed to send cat fact email to {email}\")\n\n    send_tasks = []\n    for sub in subscribers:\n        email = sub.get(\"email\")\n        if email:\n            send_tasks.append(send_email(email, entity[\"fact\"]))\n\n    if send_tasks:\n        await asyncio.gather(*send_tasks)\n\n    entity[\"emailsSent\"] = len(send_tasks)\n\n    return entity",
                "name": "process_fact"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime, timezone\nimport uuid\n\nfrom quart import Quart, request, jsonify\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\nimport httpx\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SignupRequest:\n    email: str\n    name: str = None\n\n@dataclass\nclass SubscriberQuery:\n    countOnly: bool = False\n\n# Workflow function for subscriber entity\nasync def process_subscriber(entity: dict) -> dict:\n    \"\"\"\n    Workflow function applied to subscriber entity before persistence.\n    - Adds createdAt timestamp\n    - Sends welcome email asynchronously (fire-and-forget)\n    \"\"\"\n    if \"createdAt\" not in entity:\n        entity[\"createdAt\"] = datetime.now(timezone.utc).isoformat()\n\n    async def send_welcome_email():\n        try:\n            await asyncio.sleep(0.05)  # Simulate sending email\n            logger.info(f\"Welcome email sent to {entity.get('email')}\")\n        except Exception:\n            logger.exception(\"Failed to send welcome email\")\n\n    # Fire and forget sending welcome email\n    asyncio.create_task(send_welcome_email())\n\n    return entity\n\n# Workflow function for fact entity\nasync def process_fact(entity: dict) -> dict:\n    \"\"\"\n    Workflow function applied to fact entity before persistence.\n    - Fetches a cat fact if 'fact' not provided\n    - Adds sentDate timestamp if missing\n    - Sends fact email to all subscribers asynchronously\n    - Updates emailsSent count on the fact entity before persisting\n    \"\"\"\n    if not entity.get(\"fact\"):\n        url = \"https://catfact.ninja/fact\"\n        try:\n            async with httpx.AsyncClient() as client:\n                resp = await client.get(url, timeout=10)\n                resp.raise_for_status()\n                data = resp.json()\n                entity[\"fact\"] = data.get(\"fact\", \"Cats are mysterious creatures!\")\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact\")\n            entity[\"fact\"] = \"Cats are mysterious creatures!\"\n\n    if \"sentDate\" not in entity:\n        entity[\"sentDate\"] = datetime.now(timezone.utc).isoformat()\n\n    # Initialize counts if missing\n    entity.setdefault(\"emailsSent\", 0)\n    entity.setdefault(\"emailsOpened\", 0)\n    entity.setdefault(\"linksClicked\", 0)\n\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to retrieve subscribers\")\n        subscribers = []\n\n    async def send_email(email: str, fact_text: str):\n        try:\n            await asyncio.sleep(0.05)  # Simulate sending email\n            logger.info(f\"Sent cat fact email to {email}\")\n        except Exception:\n            logger.exception(f\"Failed to send cat fact email to {email}\")\n\n    send_tasks = []\n    for sub in subscribers:\n        email = sub.get(\"email\")\n        if email:\n            send_tasks.append(send_email(email, entity[\"fact\"]))\n\n    if send_tasks:\n        await asyncio.gather(*send_tasks)\n\n    entity[\"emailsSent\"] = len(send_tasks)\n\n    return entity\n\n@app.route(\"/api/signup\", methods=[\"POST\"])\n@validate_request(SignupRequest)\nasync def signup(data: SignupRequest):\n    email = data.email\n    if not email:\n        return jsonify({\"error\": \"Email is required\"}), 400\n\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n    try:\n        existing_subscribers = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n    except Exception:\n        logger.exception(\"Failed to check existing subscriber\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n    if existing_subscribers:\n        return jsonify({\"message\": \"Email already subscribed\"}), 409\n\n    subscriber_data = {\"email\": email, \"name\": data.name}\n    try:\n        subscriber_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n            entity=subscriber_data\n        )\n    except Exception:\n        logger.exception(\"Failed to add subscriber\")\n        return jsonify({\"error\": \"Failed to subscribe\"}), 500\n\n    logger.info(f\"New subscriber added: {email}\")\n    return jsonify({\"message\": \"Subscription successful\", \"subscriberId\": subscriber_id})\n\n@validate_querystring(SubscriberQuery)\n@app.route(\"/api/subscribers\", methods=[\"GET\"])\nasync def get_subscribers():\n    args = SubscriberQuery(**request.args)\n    try:\n        subscribers_raw = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscriber\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to retrieve subscribers\")\n        return jsonify({\"error\": \"Failed to retrieve subscribers\"}), 500\n\n    if args.countOnly:\n        return jsonify({\"totalSubscribers\": len(subscribers_raw)})\n\n    subs_list = [\n        {\"id\": str(sub.get(\"id\", \"\")), \"email\": sub.get(\"email\"), \"name\": sub.get(\"name\")}\n        for sub in subscribers_raw\n    ]\n    return jsonify({\"totalSubscribers\": len(subscribers_raw), \"subscribers\": subs_list})\n\n@app.route(\"/api/facts/sendWeekly\", methods=[\"POST\"])\nasync def send_weekly_fact():\n    fact_data = {}\n    try:\n        fact_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"fact\",\n            entity_version=ENTITY_VERSION,\n            entity=fact_data\n        )\n    except Exception:\n        logger.exception(\"Failed to send weekly cat fact\")\n        return jsonify({\"error\": \"Failed to send cat fact\"}), 500\n\n    return jsonify({\n        \"message\": \"Cat fact sent to subscribers\",\n        \"factId\": fact_id\n    })\n\n@app.route(\"/api/facts/reports\", methods=[\"GET\"])\nasync def get_facts_reports():\n    try:\n        facts_raw = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"fact\",\n            entity_version=ENTITY_VERSION,\n        )\n    except Exception:\n        logger.exception(\"Failed to retrieve facts reports\")\n        return jsonify({\"error\": \"Failed to retrieve facts\"}), 500\n\n    facts_list = []\n    for fact in facts_raw:\n        facts_list.append({\n            \"factId\": str(fact.get(\"id\", \"\")),\n            \"fact\": fact.get(\"fact\"),\n            \"sentDate\": fact.get(\"sentDate\"),\n            \"emailsSent\": fact.get(\"emailsSent\"),\n            \"emailsOpened\": fact.get(\"emailsOpened\"),\n            \"linksClicked\": fact.get(\"linksClicked\")\n        })\n    return jsonify({\"facts\": facts_list})\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}