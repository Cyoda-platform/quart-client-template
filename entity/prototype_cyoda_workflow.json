{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_pet(entity: dict):\n    \"\"\"\n    Workflow: enrich pet entity before persistence and handle side effects.\n    \"\"\"\n    logger.info(f\"Workflow process_pet invoked for entity: {entity}\")\n\n    # Set creation timestamp if missing\n    if \"created_at\" not in entity:\n        entity[\"created_at\"] = datetime.utcnow().isoformat()\n\n    # Normalize type to lowercase\n    if entity.get(\"type\"):\n        entity[\"type\"] = entity[\"type\"].lower()\n\n    # Additional validation example: enforce status is one of allowed values\n    allowed_statuses = {\"available\", \"pending\", \"sold\"}\n    if \"status\" in entity and entity[\"status\"] not in allowed_statuses:\n        logger.warning(f\"Invalid status '{entity['status']}' set to 'available'\")\n        entity[\"status\"] = \"available\"",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n# Request schemas\n@dataclass\nclass SearchReq:\n    type: Optional[str] = None\n    status: Optional[str] = None\n    name: Optional[str] = None\n\n@dataclass\nclass FavoriteReq:\n    userId: str\n    petId: int\n\n@dataclass\nclass RecommendReq:\n    userId: str\n    preferences: Dict[str, Optional[str]]\n\n@dataclass\nclass AddPetReq:\n    id: int\n    name: str\n    type: Optional[str] = None\n    status: Optional[str] = \"available\"\n    photoUrls: Optional[List[str]] = None\n\n# In-memory cache for favorites: {userId: set(petId)}\nfavorites_cache: Dict[str, set] = {}\n\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"\n\n\n# --- Workflow functions ---\n\nasync def process_pet(entity: dict):\n    \"\"\"\n    Workflow: enrich pet entity before persistence and handle side effects.\n    \"\"\"\n    logger.info(f\"Workflow process_pet invoked for entity: {entity}\")\n\n    # Set creation timestamp if missing\n    if \"created_at\" not in entity:\n        entity[\"created_at\"] = datetime.utcnow().isoformat()\n\n    # Normalize type to lowercase\n    if entity.get(\"type\"):\n        entity[\"type\"] = entity[\"type\"].lower()\n\n    # Additional validation example: enforce status is one of allowed values\n    allowed_statuses = {\"available\", \"pending\", \"sold\"}\n    if \"status\" in entity and entity[\"status\"] not in allowed_statuses:\n        logger.warning(f\"Invalid status '{entity['status']}' set to 'available'\")\n        entity[\"status\"] = \"available\"\n\nasync def process_search(entity: dict):\n    \"\"\"\n    Workflow: fetch pets from external API based on search parameters and store results.\n    The 'entity' here represents search parameters.\n    \"\"\"\n    logger.info(f\"Workflow process_search invoked with search params: {entity}\")\n\n    type_ = entity.get(\"type\")\n    status = entity.get(\"status\") or \"available\"\n    name = entity.get(\"name\")\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            r = await client.get(f\"{PETSTORE_API_BASE}/pet/findByStatus\", params={\"status\": status})\n            r.raise_for_status()\n            pets = r.json()\n        except Exception as e:\n            logger.exception(\"Error fetching pets in process_search\")\n            entity['results'] = []\n            return\n\n    filtered = []\n    for pet in pets:\n        if type_:\n            cat = pet.get(\"category\", {}).get(\"name\")\n            if not cat or cat.lower() != type_.lower():\n                continue\n        if name and pet.get(\"name\"):\n            if name.lower() not in pet[\"name\"].lower():\n                continue\n        filtered.append({\n            \"id\": pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\", \"\"),\n            \"status\": status,\n            \"photoUrls\": pet.get(\"photoUrls\", [])\n        })\n\n    entity['results'] = filtered\n\nasync def process_favorite(entity: dict):\n    \"\"\"\n    Workflow for adding favorite pet to user cache.\n    \"\"\"\n    logger.info(f\"Workflow process_favorite invoked with data: {entity}\")\n    user_id = entity[\"userId\"]\n    pet_id = entity[\"petId\"]\n    user_favs = favorites_cache.setdefault(user_id, set())\n    user_favs.add(pet_id)\n\nasync def process_recommend(entity: dict):\n    \"\"\"\n    Workflow to fetch recommended pets for user excluding favorites.\n    Store recommendations in entity['recommendations'].\n    \"\"\"\n    logger.info(f\"Workflow process_recommend invoked with data: {entity}\")\n\n    user_id = entity[\"userId\"]\n    prefs = entity.get(\"preferences\") or {}\n    type_ = prefs.get(\"type\")\n    status = prefs.get(\"status\") or \"available\"\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            r = await client.get(f\"{PETSTORE_API_BASE}/pet/findByStatus\", params={\"status\": status})\n            r.raise_for_status()\n            pets = r.json()\n        except Exception as e:\n            logger.exception(\"Error fetching pets in process_recommend\")\n            entity['recommendations'] = []\n            return\n\n    user_favs = favorites_cache.get(user_id, set())\n    recommended = []\n    for pet in pets:\n        if pet.get(\"id\") not in user_favs:\n            if type_:\n                cat = pet.get(\"category\", {}).get(\"name\")\n                if not cat or cat.lower() != type_.lower():\n                    continue\n            recommended.append({\n                \"id\": pet.get(\"id\"),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\", \"\"),\n                \"status\": status,\n                \"photoUrls\": pet.get(\"photoUrls\", [])\n            })\n        if len(recommended) >= 5:\n            break\n    entity['recommendations'] = recommended\n\n# --- End workflow functions ---\n\n\n# --- Routes ---\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchReq)\nasync def pets_search(data: SearchReq):\n    entity = data.__dict__\n    await process_search(entity)\n    return jsonify({\"pets\": entity.get(\"results\", [])})\n\n@app.route(\"/pets/favorites\", methods=[\"POST\"])\n@validate_request(FavoriteReq)\nasync def add_favorite(data: FavoriteReq):\n    entity = data.__dict__\n    await process_favorite(entity)\n    return jsonify({\"message\": \"Pet added to favorites\"})\n\n@app.route(\"/pets/favorites/<user_id>\", methods=[\"GET\"])\nasync def get_favorites(user_id: str):\n    user_favs = favorites_cache.get(user_id, set())\n    if not user_favs:\n        return jsonify({\"favorites\": []})\n\n    pets = []\n    async with httpx.AsyncClient(timeout=10) as client:\n        for pet_id in user_favs:\n            try:\n                r = await client.get(f\"{PETSTORE_API_BASE}/pet/{pet_id}\")\n                if r.status_code == 200:\n                    pet = r.json()\n                    pets.append({\n                        \"id\": pet.get(\"id\"),\n                        \"name\": pet.get(\"name\"),\n                        \"type\": pet.get(\"category\", {}).get(\"name\", \"\"),\n                        \"status\": pet.get(\"status\", \"\")\n                    })\n                else:\n                    logger.info(f\"Pet id {pet_id} not found\")\n            except Exception as e:\n                logger.exception(e)\n    return jsonify({\"favorites\": pets})\n\n@app.route(\"/pets/recommend\", methods=[\"POST\"])\n@validate_request(RecommendReq)\nasync def recommend_pets(data: RecommendReq):\n    entity = data.__dict__\n    await process_recommend(entity)\n    return jsonify({\"recommendations\": entity.get(\"recommendations\", [])})\n\n@app.route(\"/pets/add\", methods=[\"POST\"])\n@validate_request(AddPetReq)\nasync def add_pet(data: AddPetReq):\n    entity = data.__dict__\n    try:\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=entity\n        )\n        return jsonify({\"message\": \"Pet added\", \"entity_id\": entity_id})\n    except Exception as e:\n        logger.exception(\"Failed to add pet entity\")\n        return jsonify({\"error\": str(e)}), 500\n\n# --- End routes ---\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO)\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}