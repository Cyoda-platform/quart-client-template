{
    "entity_models": [
        {
            "entity_model_name": "subscription",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nfrom datetime import datetime\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_subscription(entity: dict):\n    entity[\"subscribed_at\"] = datetime.utcnow().isoformat()\n    email = entity.get(\"email\")\n    if email:\n        # Fire and forget sending confirmation email\n        asyncio.create_task(send_email(\n            to_email=email,\n            subject=\"Subscription Confirmation\",\n            body=\"Thank you for subscribing!\"\n        ))\n    return entity",
                "name": "process_subscription"
            }
        },
        {
            "entity_model_name": "fact_sent",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_fact_sent(entity: dict):\n    fact = entity.get(\"fact\")\n    if not fact:\n        logger.error(\"process_fact_sent: no 'fact' in entity\")\n        return entity\n\n    # Fetch all subscribers\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=ENTITY_NAME,\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.exception(f\"process_fact_sent: error fetching subscribers: {e}\")\n        return entity\n\n    # Send emails concurrently\n    send_tasks = []\n    subject = \"Your Weekly Cat Fact \u001f\u007f\"\n    for subscriber in subscribers:\n        email = subscriber.get(\"email\")\n        if email:\n            send_tasks.append(send_email(email, subject, fact))\n    if send_tasks:\n        try:\n            await asyncio.gather(*send_tasks)\n        except Exception as e:\n            logger.exception(f\"process_fact_sent: error sending emails: {e}\")\n\n    sent_count = len(send_tasks)\n\n    # Update or create interaction entity to increment emails_sent\n    try:\n        interactions = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=INTERACTION_ENTITY_NAME,\n            entity_version=ENTITY_VERSION\n        )\n        if interactions:\n            interaction = interactions[0]\n            technical_id = str(interaction.get(\"id\") or interaction.get(\"technical_id\") or \"\")\n            updated_interaction = {\n                \"emails_sent\": interaction.get(\"emails_sent\", 0) + sent_count,\n                \"opens\": interaction.get(\"opens\", 0),\n                \"clicks\": interaction.get(\"clicks\", 0),\n            }\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=INTERACTION_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                entity=updated_interaction,\n                technical_id=technical_id,\n                meta={}\n            )\n        else:\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=INTERACTION_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                entity={\"emails_sent\": sent_count, \"opens\": 0, \"clicks\": 0}\n            )\n    except Exception as e:\n        logger.exception(f\"process_fact_sent: error updating interactions: {e}\")\n\n    return entity",
                "name": "process_fact_sent"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass Subscription:\n    email: str  # simple email field for subscription\n\nENTITY_NAME = \"subscription\"  # underscore lowercase\nFACT_SENT_ENTITY_NAME = \"fact_sent\"\nINTERACTION_ENTITY_NAME = \"interaction\"\nCAT_FACT_API_URL = \"https://catfact.ninja/fact\"\n\n# Dummy email sending function\nasync def send_email(to_email: str, subject: str, body: str):\n    # TODO: Replace with real email sending implementation\n    logger.info(f\"Sending email to {to_email} | Subject: {subject} | Body preview: {body[:50]}...\")\n\n# Workflow function for subscription: add timestamp and send confirmation email\nasync def process_subscription(entity: dict):\n    entity[\"subscribed_at\"] = datetime.utcnow().isoformat()\n    email = entity.get(\"email\")\n    if email:\n        # Fire and forget sending confirmation email\n        asyncio.create_task(send_email(\n            to_email=email,\n            subject=\"Subscription Confirmation\",\n            body=\"Thank you for subscribing!\"\n        ))\n    return entity\n\n# Workflow function for fact_sent: send cat fact emails to all subscribers,\n# and add/update interaction entity to increment emails_sent count.\nasync def process_fact_sent(entity: dict):\n    fact = entity.get(\"fact\")\n    if not fact:\n        logger.error(\"process_fact_sent: no 'fact' in entity\")\n        return entity\n\n    # Fetch all subscribers\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=ENTITY_NAME,\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.exception(f\"process_fact_sent: error fetching subscribers: {e}\")\n        return entity\n\n    # Send emails concurrently\n    send_tasks = []\n    subject = \"Your Weekly Cat Fact \u001f\u007f\"\n    for subscriber in subscribers:\n        email = subscriber.get(\"email\")\n        if email:\n            send_tasks.append(send_email(email, subject, fact))\n    if send_tasks:\n        try:\n            await asyncio.gather(*send_tasks)\n        except Exception as e:\n            logger.exception(f\"process_fact_sent: error sending emails: {e}\")\n\n    sent_count = len(send_tasks)\n\n    # Update or create interaction entity to increment emails_sent\n    try:\n        interactions = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=INTERACTION_ENTITY_NAME,\n            entity_version=ENTITY_VERSION\n        )\n        if interactions:\n            interaction = interactions[0]\n            technical_id = str(interaction.get(\"id\") or interaction.get(\"technical_id\") or \"\")\n            updated_interaction = {\n                \"emails_sent\": interaction.get(\"emails_sent\", 0) + sent_count,\n                \"opens\": interaction.get(\"opens\", 0),\n                \"clicks\": interaction.get(\"clicks\", 0),\n            }\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=INTERACTION_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                entity=updated_interaction,\n                technical_id=technical_id,\n                meta={}\n            )\n        else:\n            await entity_service.add_item(\n                token=cyoda_auth_service,\n                entity_model=INTERACTION_ENTITY_NAME,\n                entity_version=ENTITY_VERSION,\n                entity={\"emails_sent\": sent_count, \"opens\": 0, \"clicks\": 0}\n            )\n    except Exception as e:\n        logger.exception(f\"process_fact_sent: error updating interactions: {e}\")\n\n    return entity\n\n@app.route(\"/api/subscribe\", methods=[\"POST\"])\n@validate_request(Subscription)\nasync def subscribe(data: Subscription):\n    email = data.email\n    if not email or \"@\" not in email:\n        return jsonify({\"success\": False, \"message\": \"Invalid email\"}), 400\n\n    # Check if email already subscribed\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n    try:\n        existing_items = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Error checking subscription\"}), 500\n\n    if existing_items:\n        return jsonify({\"success\": False, \"message\": \"Email already subscribed\"}), 400\n\n    try:\n        id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            entity=data.__dict__\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Error adding subscription\"}), 500\n\n    return jsonify({\"success\": True, \"message\": \"Subscription successful\", \"id\": str(id)})\n\n@app.route(\"/api/facts/send-weekly\", methods=[\"POST\"])\nasync def send_weekly_fact():\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(CAT_FACT_API_URL, timeout=10)\n            resp.raise_for_status()\n            data = resp.json()\n            fact = data.get(\"fact\")\n            if not fact:\n                logger.error(\"Cat fact API response missing 'fact'\")\n                return jsonify({\"success\": False, \"message\": \"Failed to retrieve cat fact\"}), 500\n        except Exception as e:\n            logger.exception(e)\n            return jsonify({\"success\": False, \"message\": \"Error fetching cat fact\"}), 500\n\n    # Persist fact_sent entity\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=FACT_SENT_ENTITY_NAME,\n            entity_version=ENTITY_VERSION,\n            entity={\"fact\": fact, \"sent_at\": datetime.utcnow().isoformat()}\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Error recording/sending fact\"}), 500\n\n    return jsonify({\"success\": True, \"message\": \"Weekly cat fact sent\"})\n\n@app.route(\"/api/report/subscribers-count\", methods=[\"GET\"])\nasync def subscribers_count():\n    try:\n        subscribers = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=ENTITY_NAME,\n            entity_version=ENTITY_VERSION\n        )\n        count = len(subscribers)\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Error fetching subscriber count\"}), 500\n    return jsonify({\"subscribersCount\": count})\n\n@app.route(\"/api/report/interactions\", methods=[\"GET\"])\nasync def interactions():\n    try:\n        interactions = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=INTERACTION_ENTITY_NAME,\n            entity_version=ENTITY_VERSION\n        )\n        if interactions:\n            interaction = interactions[0]\n            total_emails_sent = interaction.get(\"emails_sent\", 0)\n            total_opens = interaction.get(\"opens\", 0)\n            total_clicks = interaction.get(\"clicks\", 0)\n        else:\n            total_emails_sent = 0\n            total_opens = 0\n            total_clicks = 0\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"success\": False, \"message\": \"Error fetching interactions\"}), 500\n\n    return jsonify({\n        \"totalEmailsSent\": total_emails_sent,\n        \"totalOpens\": total_opens,\n        \"totalClicks\": total_clicks,\n    })\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}