{
    "entity_models": [
        {
            "entity_model_name": "search_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nimport uuid\nfrom datetime import datetime\n\nFUN_FACTS = {\n    \"cat\": \"Cats are curious and love to explore!\",\n    \"dog\": \"Dogs are loyal and friendly companions.\",\n    \"bird\": \"Birds are social and enjoy singing.\",\n    \"rabbit\": \"Rabbits have nearly 360-degree panoramic vision.\",\n}\n\nlogger = logging.getLogger(__name__)",
                "content": "async def process_search_request(entity: dict):\n    search_id = entity.get(\"id\")\n    if not search_id:\n        search_id = str(uuid.uuid4())\n        entity[\"id\"] = search_id\n    criteria = entity\n    try:\n        pets = await fetch_pets_from_petstore(\n            criteria.get(\"type\"),\n            criteria.get(\"status\"),\n            criteria.get(\"nameContains\"),\n        )\n        for pet in pets:\n            fact = FUN_FACTS.get(pet[\"type\"].lower(), \"Every pet is unique and special!\")\n            pet[\"funFact\"] = fact\n        _search_results_cache[search_id] = {\n            \"requestedAt\": datetime.utcnow().isoformat() + \"Z\",\n            \"criteria\": criteria,\n            \"pets\": pets,\n            \"status\": \"completed\",\n        }\n        logger.info(f\"Search completed for searchId={search_id}, {len(pets)} pets found\")\n    except Exception as e:\n        logger.exception(f\"Failed processing search {search_id}: {e}\")\n        _search_results_cache[search_id] = {\n            \"requestedAt\": datetime.utcnow().isoformat() + \"Z\",\n            \"criteria\": criteria,\n            \"pets\": [],\n            \"status\": \"failed\",\n        }",
                "name": "process_search_request"
            }
        },
        {
            "entity_model_name": "favorite_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n_user_favorites_cache = {}",
                "content": "async def process_favorite_request(entity: dict):\n    user_id = entity.get(\"user_id\")\n    pet_id = entity.get(\"pet_id\")\n    if not user_id or not pet_id:\n        logger.warning(f\"Favorite request missing user_id or pet_id: {entity}\")\n        return\n    favorites = _user_favorites_cache.setdefault(user_id, set())\n    favorites.add(pet_id)\n    logger.info(f\"Added pet_id={pet_id} to favorites for user_id={user_id}\")",
                "name": "process_favorite_request"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nimport uuid\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SearchRequest:\n    type: Optional[str] = None\n    status: Optional[str] = None\n    nameContains: Optional[str] = None\n\n@dataclass\nclass FavoriteRequest:\n    pet_id: str  # pet id as string\n    user_id: str\n\n_search_results_cache: Dict[str, Dict] = {}\n_user_favorites_cache: Dict[str, set] = {}\n\nFUN_FACTS = {\n    \"cat\": \"Cats are curious and love to explore!\",\n    \"dog\": \"Dogs are loyal and friendly companions.\",\n    \"bird\": \"Birds are social and enjoy singing.\",\n    \"rabbit\": \"Rabbits have nearly 360-degree panoramic vision.\",\n}\n\nPETSTORE_BASE_URL = \"https://petstore.swagger.io/v2\"\nhttp_client = httpx.AsyncClient(timeout=10.0)\n\nasync def fetch_pets_from_petstore(\n    type_filter: Optional[str], status_filter: Optional[str], name_contains: Optional[str]\n) -> List[Dict]:\n    pets = []\n    try:\n        status_query = status_filter if status_filter else \"available\"\n        url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n        response = await http_client.get(url, params={\"status\": status_query})\n        response.raise_for_status()\n        pet_list = response.json()\n        for pet in pet_list:\n            pet_type = None\n            if pet.get(\"category\") and isinstance(pet[\"category\"], dict):\n                pet_type = pet[\"category\"].get(\"name\", \"\").lower()\n            if type_filter and (not pet_type or pet_type != type_filter.lower()):\n                continue\n            pet_name = pet.get(\"name\", \"\").lower()\n            if name_contains and name_contains.lower() not in pet_name:\n                continue\n            pets.append({\n                \"id\": str(pet.get(\"id\")),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet_type or \"unknown\",\n                \"status\": status_query,\n            })\n    except Exception as e:\n        logger.exception(f\"Error fetching pets from Petstore API: {e}\")\n    return pets\n\nasync def process_search_request(entity: dict):\n    search_id = entity.get(\"id\")\n    if not search_id:\n        search_id = str(uuid.uuid4())\n        entity[\"id\"] = search_id\n    criteria = entity\n    try:\n        pets = await fetch_pets_from_petstore(\n            criteria.get(\"type\"),\n            criteria.get(\"status\"),\n            criteria.get(\"nameContains\"),\n        )\n        for pet in pets:\n            fact = FUN_FACTS.get(pet[\"type\"].lower(), \"Every pet is unique and special!\")\n            pet[\"funFact\"] = fact\n        _search_results_cache[search_id] = {\n            \"requestedAt\": datetime.utcnow().isoformat() + \"Z\",\n            \"criteria\": criteria,\n            \"pets\": pets,\n            \"status\": \"completed\",\n        }\n        logger.info(f\"Search completed for searchId={search_id}, {len(pets)} pets found\")\n    except Exception as e:\n        logger.exception(f\"Failed processing search {search_id}: {e}\")\n        _search_results_cache[search_id] = {\n            \"requestedAt\": datetime.utcnow().isoformat() + \"Z\",\n            \"criteria\": criteria,\n            \"pets\": [],\n            \"status\": \"failed\",\n        }\n\nasync def process_favorite_request(entity: dict):\n    user_id = entity.get(\"user_id\")\n    pet_id = entity.get(\"pet_id\")\n    if not user_id or not pet_id:\n        logger.warning(f\"Favorite request missing user_id or pet_id: {entity}\")\n        return\n    favorites = _user_favorites_cache.setdefault(user_id, set())\n    favorites.add(pet_id)\n    logger.info(f\"Added pet_id={pet_id} to favorites for user_id={user_id}\")\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchRequest)\nasync def pets_search(data: SearchRequest):\n    data_dict = data.__dict__\n    try:\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"search_request\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"searchId\": str(entity_id)})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add search request\"}), 500\n\n@app.route(\"/pets/results/<string:search_id>\", methods=[\"GET\"])\nasync def pets_results(search_id):\n    result = _search_results_cache.get(search_id)\n    if not result:\n        return jsonify({\"error\": \"searchId not found\"}), 404\n    return jsonify({\n        \"searchId\": search_id,\n        \"status\": result.get(\"status\", \"unknown\"),\n        \"pets\": result.get(\"pets\", []),\n    })\n\n@app.route(\"/pets/favorite\", methods=[\"POST\"])\n@validate_request(FavoriteRequest)\nasync def pets_favorite(data: FavoriteRequest):\n    data_dict = data.__dict__\n    try:\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"favorite_request\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"favoriteId\": str(entity_id)})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add favorite\"}), 500\n\n@app.route(\"/pets/favorites/<string:user_id>\", methods=[\"GET\"])\nasync def pets_favorites(user_id):\n    favorites = _user_favorites_cache.get(user_id, set())\n    pets_result = []\n    all_pets = []\n    for search_data in _search_results_cache.values():\n        if search_data.get(\"status\") != \"completed\":\n            continue\n        all_pets.extend(search_data.get(\"pets\", []))\n    pet_map = {str(pet[\"id\"]): pet for pet in all_pets}\n    for pet_id in favorites:\n        pet = pet_map.get(str(pet_id))\n        if pet:\n            pets_result.append({\n                \"id\": pet[\"id\"],\n                \"name\": pet[\"name\"],\n                \"type\": pet[\"type\"],\n                \"status\": pet[\"status\"],\n            })\n        else:\n            pets_result.append({\n                \"id\": pet_id,\n                \"name\": \"Unknown\",\n                \"type\": \"Unknown\",\n                \"status\": \"Unknown\",\n            })\n    return jsonify({\"userId\": user_id, \"favorites\": pets_result})\n\n@app.before_serving\nasync def startup():\n    logger.info(\"Purrfect Pets API starting up...\")\n\n@app.after_serving\nasync def shutdown():\n    await http_client.aclose()\n    logger.info(\"Purrfect Pets API shutting down...\")\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}