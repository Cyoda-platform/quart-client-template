{
    "entity_models": [
        {
            "entity_model_name": "subscribe_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nfrom common.config.config import ENTITY_VERSION\nimport logging\nimport asyncio\nfrom uuid import uuid4\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nlogger = logging.getLogger(__name__)\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]",
                "content": "async def process_subscribe_request(entity: dict) -> dict:\n    \"\"\"\n    Workflow function applied asynchronously before persisting a subscribe_request entity.\n    Moves duplicate email check here, sets subscribedAt timestamp.\n    \"\"\"\n    email = entity.get(\"email\")\n    if not email:\n        raise ValueError(\"Email is required in subscribe_request entity\")\n\n    # Check if email already subscribed\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n    existing = await entity_service.get_items_by_condition(\n        token=cyoda_auth_service,\n        entity_model=\"subscribe_request\",\n        entity_version=ENTITY_VERSION,\n        condition=condition\n    )\n    if existing:\n        raise ValueError(f\"Email {email} already subscribed\")\n\n    # Set subscribedAt if not already set\n    if \"subscribedAt\" not in entity:\n        entity[\"subscribedAt\"] = datetime.utcnow().isoformat()\n\n    return entity",
                "name": "process_subscribe_request"
            }
        },
        {
            "entity_model_name": "catfact_send_job",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nfrom common.config.config import ENTITY_VERSION\nimport logging\nimport asyncio\nfrom uuid import uuid4\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nlogger = logging.getLogger(__name__)\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]",
                "content": "async def process_catfact_send_job(entity: dict) -> dict:\n    \"\"\"\n    Workflow function that fetches cat fact, sends emails to subscribers asynchronously.\n    It does not modify the job entity but triggers side effects.\n    \"\"\"\n    logger.info(\"Starting catfact_send_job workflow\")\n\n    # Fetch cat fact\n    fact = await fetch_cat_fact()\n    if not fact:\n        logger.error(\"Failed to fetch cat fact in workflow\")\n        return entity\n\n    # Retrieve all subscribers\n    subscribers = await entity_service.get_items(\n        token=cyoda_auth_service,\n        entity_model=\"subscribe_request\",\n        entity_version=ENTITY_VERSION\n    )\n    if not subscribers:\n        logger.info(\"No subscribers found in catfact_send_job workflow\")\n        return entity\n\n    emails_sent = 0\n\n    async def send_to_subscriber(sub):\n        nonlocal emails_sent\n        subject = \"Your Weekly Cat Fact! \ud83d\udc31\"\n        name_part = f\" {sub.get('name')}\" if sub.get('name') else \"\"\n        body = f\"Hello{name_part},\\n\\nHere's your cat fact this week:\\n\\n{fact}\\n\\nEnjoy!\"\n        try:\n            sent = await send_email(sub[\"email\"], subject, body)\n            if sent:\n                emails_sent += 1\n        except Exception as e:\n            logger.exception(f\"Failed to send email to {sub['email']}: {e}\")\n\n    await asyncio.gather(*(send_to_subscriber(sub) for sub in subscribers))\n\n    logger.info(f\"Cat fact sent to {emails_sent} subscribers\")\n\n    # Add an entity to record the send job result\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"catfact_send_result\",\n            entity_version=ENTITY_VERSION,\n            entity={\n                \"jobId\": entity.get(\"id\", str(uuid4())),\n                \"sentAt\": datetime.utcnow().isoformat(),\n                \"emailsSentCount\": emails_sent,\n                \"fact\": fact\n            },\n            workflow=None\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to record catfact_send_result: {e}\")\n\n    return entity",
                "name": "process_catfact_send_job"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\nfrom uuid import uuid4\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SubscribeRequest:\n    email: str\n    name: Optional[str] = None\n\n# Workflow for subscribe_request entity\nasync def process_subscribe_request(entity: dict) -> dict:\n    \"\"\"\n    Workflow function applied asynchronously before persisting a subscribe_request entity.\n    Moves duplicate email check here, sets subscribedAt timestamp.\n    \"\"\"\n    email = entity.get(\"email\")\n    if not email:\n        raise ValueError(\"Email is required in subscribe_request entity\")\n\n    # Check if email already subscribed\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n    existing = await entity_service.get_items_by_condition(\n        token=cyoda_auth_service,\n        entity_model=\"subscribe_request\",\n        entity_version=ENTITY_VERSION,\n        condition=condition\n    )\n    if existing:\n        raise ValueError(f\"Email {email} already subscribed\")\n\n    # Set subscribedAt if not already set\n    if \"subscribedAt\" not in entity:\n        entity[\"subscribedAt\"] = datetime.utcnow().isoformat()\n\n    return entity\n\n# Workflow for catfact_send_job entity\nasync def process_catfact_send_job(entity: dict) -> dict:\n    \"\"\"\n    Workflow function that fetches cat fact, sends emails to subscribers asynchronously.\n    It does not modify the job entity but triggers side effects.\n    \"\"\"\n    logger.info(\"Starting catfact_send_job workflow\")\n\n    # Fetch cat fact\n    fact = await fetch_cat_fact()\n    if not fact:\n        logger.error(\"Failed to fetch cat fact in workflow\")\n        return entity\n\n    # Retrieve all subscribers\n    subscribers = await entity_service.get_items(\n        token=cyoda_auth_service,\n        entity_model=\"subscribe_request\",\n        entity_version=ENTITY_VERSION\n    )\n    if not subscribers:\n        logger.info(\"No subscribers found in catfact_send_job workflow\")\n        return entity\n\n    emails_sent = 0\n\n    async def send_to_subscriber(sub):\n        nonlocal emails_sent\n        subject = \"Your Weekly Cat Fact! \u001f431\"\n        name_part = f\" {sub.get('name')}\" if sub.get('name') else \"\"\n        body = f\"Hello{name_part},\\n\\nHere's your cat fact this week:\\n\\n{fact}\\n\\nEnjoy!\"\n        try:\n            sent = await send_email(sub[\"email\"], subject, body)\n            if sent:\n                emails_sent += 1\n        except Exception as e:\n            logger.exception(f\"Failed to send email to {sub['email']}: {e}\")\n\n    await asyncio.gather(*(send_to_subscriber(sub) for sub in subscribers))\n\n    logger.info(f\"Cat fact sent to {emails_sent} subscribers\")\n\n    # Add an entity to record the send job result\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"catfact_send_result\",\n            entity_version=ENTITY_VERSION,\n            entity={\n                \"jobId\": entity.get(\"id\", str(uuid4())),\n                \"sentAt\": datetime.utcnow().isoformat(),\n                \"emailsSentCount\": emails_sent,\n                \"fact\": fact\n            },\n            workflow=None\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to record catfact_send_result: {e}\")\n\n    return entity\n\n@app.route(\"/subscribe\", methods=[\"POST\"])\n@validate_request(SubscribeRequest)\nasync def subscribe(data: SubscribeRequest):\n    data_dict = {\n        \"email\": data.email,\n        \"name\": data.name,\n    }\n    try:\n        new_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"subscribe_request\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n    except ValueError as ve:\n        return jsonify({\"error\": str(ve)}), 400\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add subscriber\"}), 500\n\n    logger.info(f\"New subscriber: {data.email} (id={new_id})\")\n    return jsonify({\"message\": \"Subscription successful\", \"subscriberId\": new_id})\n\n@app.route(\"/subscribers/count\", methods=[\"GET\"])\nasync def get_subscriber_count():\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"subscribe_request\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve subscribers\"}), 500\n    count = len(items) if items else 0\n    return jsonify({\"subscriberCount\": count})\n\n@app.route(\"/fetch-and-send-catfact\", methods=[\"POST\"])\nasync def fetch_and_send_catfact():\n    try:\n        job_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"catfact_send_job\",\n            entity_version=ENTITY_VERSION,\n            entity={}\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to start cat fact send job\"}), 500\n\n    return jsonify({\"message\": \"Cat fact send job started\", \"jobId\": job_id})\n\n@app.route(\"/report/interactions\", methods=[\"GET\"])\nasync def get_interactions_report():\n    try:\n        results = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"catfact_send_result\",\n            entity_version=ENTITY_VERSION\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve interaction report\"}), 500\n\n    emails_sent = sum(r.get(\"emailsSentCount\", 0) for r in results) if results else 0\n\n    interaction_metrics = {\n        \"emailsSent\": emails_sent,\n        \"emailsOpened\": 0,\n        \"clicks\": 0,\n    }\n    return jsonify(interaction_metrics)\n\nasync def send_email(to_email: str, subject: str, body: str) -> bool:\n    logger.info(f\"Sending email to {to_email} with subject '{subject}'\")\n    await asyncio.sleep(0.1)\n    return True\n\nasync def fetch_cat_fact() -> Optional[str]:\n    url = \"https://catfact.ninja/fact\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            resp = await client.get(url)\n            resp.raise_for_status()\n            data = resp.json()\n            fact = data.get(\"fact\")\n            logger.info(f\"Fetched cat fact: {fact}\")\n            return fact\n        except (httpx.RequestError, httpx.HTTPStatusError) as e:\n            logger.exception(f\"Failed to fetch cat fact: {e}\")\n            return None\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)"
    }
}