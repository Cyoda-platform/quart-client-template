{
    "entity_models": [
        {
            "entity_model_name": "subscriber",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\nasync def fetch_cat_fact() -> Optional[str]:\n    url = \"https://catfact.ninja/fact\"\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(url, timeout=10)\n            resp.raise_for_status()\n            data = resp.json()\n            fact = data.get(\"fact\")\n            if not fact:\n                logger.warning(\"Cat fact API returned no fact\")\n                return None\n            return fact\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact\")\n            return None\n\nasync def send_email_stub(email: str, subject: str, body: str) -> bool:\n    # TODO: Replace this stub with real email sending logic (SMTP / API)\n    logger.info(f\"Sending email to {email} with subject '{subject}' and body:\\n{body}\")\n    await asyncio.sleep(0.05)\n    return True",
                "content": "async def process_subscriber(entity_data: dict) -> None:\n    # Add subscription timestamp if not present\n    if \"subscribed_at\" not in entity_data:\n        entity_data[\"subscribed_at\"] = datetime.utcnow().isoformat()\n\n    # Add default status if missing\n    if \"status\" not in entity_data:\n        entity_data[\"status\"] = \"active\"\n\n    # Fetch a welcome cat fact asynchronously and add it to entity data for example\n    cat_fact = await fetch_cat_fact()\n    if cat_fact:\n        entity_data[\"welcome_cat_fact\"] = cat_fact\n\n    # Fire and forget sending welcome email (do not await to not block persistence)\n    async def fire_and_forget_email():\n        subject = \"Welcome to Cat Facts Newsletter \u001f\u001f\"\n        body = f\"Hello {entity_data.get('name') or 'Subscriber'},\\n\\n\" \\\n               f\"Thank you for subscribing! Here's a fun cat fact to start:\\n\\n{cat_fact or 'Cats are great!'}\\n\\nEnjoy!\"\n        try:\n            await send_email_stub(entity_data.get(\"email\"), subject, body)\n        except Exception:\n            logger.exception(\"Failed to send welcome email\")\n\n    asyncio.create_task(fire_and_forget_email())",
                "name": "process_subscriber"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nentity_name = \"subscriber\"  # underscore lowercase entity name\n\n@dataclass\nclass SubscribeRequest:\n    email: str\n    name: Optional[str] = None\n\n@dataclass\nclass UnsubscribeRequest:\n    email: str\n\nasync def fetch_cat_fact() -> Optional[str]:\n    url = \"https://catfact.ninja/fact\"\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(url, timeout=10)\n            resp.raise_for_status()\n            data = resp.json()\n            fact = data.get(\"fact\")\n            if not fact:\n                logger.warning(\"Cat fact API returned no fact\")\n                return None\n            return fact\n        except Exception:\n            logger.exception(\"Failed to fetch cat fact\")\n            return None\n\nasync def send_email_stub(email: str, subject: str, body: str) -> bool:\n    # TODO: Replace this stub with real email sending logic (SMTP / API)\n    logger.info(f\"Sending email to {email} with subject '{subject}' and body:\\n{body}\")\n    await asyncio.sleep(0.05)\n    return True\n\nasync def process_subscriber(entity_data: dict) -> None:\n    # Add subscription timestamp if not present\n    if \"subscribed_at\" not in entity_data:\n        entity_data[\"subscribed_at\"] = datetime.utcnow().isoformat()\n\n    # Add default status if missing\n    if \"status\" not in entity_data:\n        entity_data[\"status\"] = \"active\"\n\n    # Fetch a welcome cat fact asynchronously and add it to entity data for example\n    cat_fact = await fetch_cat_fact()\n    if cat_fact:\n        entity_data[\"welcome_cat_fact\"] = cat_fact\n\n    # Fire and forget sending welcome email (do not await to not block persistence)\n    async def fire_and_forget_email():\n        subject = \"Welcome to Cat Facts Newsletter \u001f\u001f\"\n        body = f\"Hello {entity_data.get('name') or 'Subscriber'},\\n\\n\" \\\n               f\"Thank you for subscribing! Here's a fun cat fact to start:\\n\\n{cat_fact or 'Cats are great!'}\\n\\nEnjoy!\"\n        try:\n            await send_email_stub(entity_data.get(\"email\"), subject, body)\n        except Exception:\n            logger.exception(\"Failed to send welcome email\")\n\n    asyncio.create_task(fire_and_forget_email())\n\n@app.route(\"/subscribe\", methods=[\"POST\"])\n@validate_request(SubscribeRequest)\nasync def subscribe(data: SubscribeRequest):\n    email = data.email.strip().lower()\n    name = data.name\n    if \"@\" not in email or \".\" not in email:\n        return jsonify(status=\"error\", message=\"Invalid email format\"), 400\n\n    entity_data = {\"email\": email, \"name\": name}\n\n    try:\n        id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=entity_data\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify(status=\"error\", message=\"Failed to subscribe\"), 500\n\n    return jsonify(status=\"success\", id=str(id), message=\"Subscription started\")\n\n@app.route(\"/unsubscribe\", methods=[\"POST\"])\n@validate_request(UnsubscribeRequest)\nasync def unsubscribe(data: UnsubscribeRequest):\n    email = data.email.strip().lower()\n\n    condition = {\n        \"cyoda\": {\n            \"type\": \"group\",\n            \"operator\": \"AND\",\n            \"conditions\": [\n                {\n                    \"jsonPath\": \"$.email\",\n                    \"operatorType\": \"EQUALS\",\n                    \"value\": email,\n                    \"type\": \"simple\"\n                }\n            ]\n        }\n    }\n\n    try:\n        items = await entity_service.get_items_by_condition(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            condition=condition\n        )\n        if not items:\n            return jsonify(status=\"error\", message=\"Email not found\"), 400\n        subscriber = items[0]\n        technical_id = str(subscriber.get(\"technical_id\") or subscriber.get(\"id\") or \"\")\n        if not technical_id:\n            return jsonify(status=\"error\", message=\"Invalid subscriber id\"), 400\n\n        await entity_service.delete_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            technical_id=technical_id,\n            meta={}\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify(status=\"error\", message=\"Failed to unsubscribe\"), 500\n\n    return jsonify(status=\"success\", message=\"Unsubscribed successfully\")\n\nasync def get_all_subscribers():\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n        )\n        return items\n    except Exception as e:\n        logger.exception(e)\n        return []\n\n@app.route(\"/send-weekly-fact\", methods=[\"POST\"])\nasync def send_weekly_fact():\n    asyncio.create_task(process_send_weekly_fact())\n    return jsonify(status=\"success\", message=\"Weekly cat fact sending started\")\n\nasync def process_send_weekly_fact():\n    subscribers = await get_all_subscribers()\n    if not subscribers:\n        logger.info(\"No subscribers to send cat fact to\")\n        return 0\n\n    fact = await fetch_cat_fact()\n    if not fact:\n        logger.warning(\"No cat fact retrieved, abort sending\")\n        return 0\n\n    subject = \"Your Weekly Cat Fact \u001f\u001f\"\n    body = f\"Hello,\\n\\nHere's your weekly cat fact:\\n\\n{fact}\\n\\nEnjoy your week!\"\n\n    success_count = 0\n    semaphore = asyncio.Semaphore(20)\n\n    async def send(email: str):\n        async with semaphore:\n            try:\n                return await send_email_stub(email, subject, body)\n            except Exception:\n                logger.exception(f\"Failed to send email to {email}\")\n                return False\n\n    tasks = [send(sub.get(\"email\")) for sub in subscribers if sub.get(\"email\")]\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    for r in results:\n        if r is True:\n            success_count += 1\n\n    logger.info(f\"Sent cat fact email to {success_count} subscribers\")\n    return success_count\n\n@app.route(\"/report/subscribers\", methods=[\"GET\"])\nasync def report_subscribers():\n    try:\n        items = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n        )\n        total = len(items)\n    except Exception as e:\n        logger.exception(e)\n        total = 0\n    return jsonify(total_subscribers=total)\n\n@app.route(\"/report/emails-sent\", methods=[\"GET\"])\nasync def report_emails_sent():\n    # Since emails sent counter was in-memory, and no external method provided,\n    # we cannot provide this data anymore\n    return jsonify(total_emails_sent=\"Not available\")\n\nif __name__ == '__main__':\n    logging.basicConfig(\n        format='%(asctime)s %(levelname)s %(name)s: %(message)s',\n        level=logging.INFO,\n    )\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}