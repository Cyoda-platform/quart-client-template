{
    "entity_models": [
        {
            "entity_model_name": "weather_fetch_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nfrom datetime import datetime\nimport uuid",
                "content": "async def process_weather_fetch_request(entity: dict):\n    # Set initial state for entity before persistence\n    entity['status'] = 'processing'\n    entity['createdAt'] = datetime.utcnow().isoformat()\n\n    # Ensure entity has a unique technical_id for tracking\n    if \"technical_id\" not in entity or not entity[\"technical_id\"]:\n        entity[\"technical_id\"] = str(uuid.uuid4())\n\n    # Schedule background processing task; copy entity to avoid mutation issues\n    asyncio.create_task(process_entity(entity[\"technical_id\"], entity.copy()))",
                "name": "process_weather_fetch_request"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import List\nfrom dataclasses import dataclass\nimport uuid\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass WeatherFetchRequest:\n    latitude: float\n    longitude: float\n    parameters: List[str]\n    start_date: str\n    end_date: str\n\nasync def fetch_weather_data(latitude: float, longitude: float, parameters: List[str], start_date: str, end_date: str):\n    url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"hourly\": \",\".join(parameters),\n        \"timezone\": \"UTC\",\n    }\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return response.json()\n\nasync def process_entity(job_id: str, data: dict):\n    try:\n        raw_data = await fetch_weather_data(\n            latitude=data[\"latitude\"],\n            longitude=data[\"longitude\"],\n            parameters=data[\"parameters\"],\n            start_date=data[\"start_date\"],\n            end_date=data[\"end_date\"],\n        )\n        hourly = raw_data.get(\"hourly\", {})\n        processed = {\"dates\": hourly.get(\"time\", [])}\n        for param in data[\"parameters\"]:\n            processed[param] = hourly.get(param, [])\n\n        update_data = {\n            \"status\": \"completed\",\n            \"data\": processed,\n            \"completedAt\": datetime.utcnow().isoformat()\n        }\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_request\",\n            entity_version=ENTITY_VERSION,\n            entity=update_data,\n            technical_id=job_id,\n            meta={}\n        )\n        logger.info(f\"Job {job_id} completed successfully.\")\n    except Exception as e:\n        error_data = {\n            \"status\": \"failed\",\n            \"error\": str(e),\n        }\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=\"weather_fetch_request\",\n                entity_version=ENTITY_VERSION,\n                entity=error_data,\n                technical_id=job_id,\n                meta={}\n            )\n        except Exception:\n            # If update fails, log and continue to avoid crashing\n            logger.exception(f\"Failed to update failed status for job {job_id}\")\n        logger.exception(f\"Job {job_id} failed.\")\n\n@app.route(\"/weather/fetch\", methods=[\"POST\"])\n@validate_request(WeatherFetchRequest)\nasync def weather_fetch(data: WeatherFetchRequest):\n    try:\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_request\",\n            entity_version=ENTITY_VERSION,\n            entity=data.__dict__\n        )\n        return jsonify({\"request_id\": entity_id}), 202\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add item\"}), 500\n\n@app.route(\"/weather/result/<string:request_id>\", methods=[\"GET\"])\nasync def weather_result(request_id):\n    try:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_request\",\n            entity_version=ENTITY_VERSION,\n            technical_id=request_id\n        )\n        if not job:\n            return jsonify({\"error\": \"Request ID not found\"}), 404\n\n        status = job.get(\"status\", \"processing\")\n        if status == \"processing\":\n            return jsonify({\"request_id\": request_id, \"status\": \"processing\"}), 200\n        elif status == \"completed\":\n            return jsonify({\n                \"request_id\": request_id,\n                \"status\": \"completed\",\n                \"data\": job.get(\"data\", {})\n            }), 200\n        elif status == \"failed\":\n            return jsonify({\n                \"request_id\": request_id,\n                \"status\": \"failed\",\n                \"error\": job.get(\"error\", \"Unknown error\")\n            }), 500\n        else:\n            return jsonify({\"error\": \"Unknown job status\"}), 500\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve item\"}), 500\n\nif __name__ == \"__main__\":\n    app.run(use_reloader=False, debug=True, host=\"0.0.0.0\", port=8000, threaded=True)\n"
    }
}