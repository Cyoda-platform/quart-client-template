{
    "entity_models": [
        {
            "entity_model_name": "process_data",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\nimport httpx\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nEXTERNAL_API_URL = \"https://api.agify.io\"\n\nasync def fetch_external_data(name: str) -> dict:\n    async with httpx.AsyncClient(timeout=10.0) as client:  # set reasonable timeout\n        try:\n            response = await client.get(EXTERNAL_API_URL, params={\"name\": name})\n            response.raise_for_status()\n            data = response.json()\n            logger.info(f\"Fetched external data for '{name}': {data}\")\n            return data\n        except (httpx.HTTPError, httpx.RequestError) as e:\n            logger.error(f\"Failed to fetch external data for '{name}': {e}\")\n            return {\"error\": \"Failed to fetch external data\"}",
                "content": "async def process_process_data(entity: dict):\n    # Set initial status and timestamp\n    entity['status'] = 'processing'\n    entity['requestedAt'] = datetime.utcnow().isoformat()\n\n    name = entity.get('name')\n    if not name or not isinstance(name, str) or not name.strip():\n        entity['status'] = 'failed'\n        entity['result'] = {'error': 'Missing or invalid \"name\" attribute'}\n        logger.error(\"process_process_data: Missing or invalid 'name' attribute in entity\")\n        return\n\n    # Fetch and enrich entity with external data\n    external_data = await fetch_external_data(name.strip())\n\n    if 'error' in external_data:\n        entity['status'] = 'failed'\n        entity['result'] = external_data\n        logger.error(f\"process_process_data: External API error for '{name}': {external_data['error']}\")\n    else:\n        entity['result'] = {\n            \"inputName\": name.strip(),\n            \"predictedAge\": external_data.get(\"age\"),\n            \"count\": external_data.get(\"count\"),\n            \"source\": \"agify.io\"\n        }\n        entity['status'] = 'completed'",
                "name": "process_process_data"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport logging\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass ProcessData:\n    name: str\n\nEXTERNAL_API_URL = \"https://api.agify.io\"\n\nasync def fetch_external_data(name: str) -> dict:\n    async with httpx.AsyncClient(timeout=10.0) as client:  # set reasonable timeout\n        try:\n            response = await client.get(EXTERNAL_API_URL, params={\"name\": name})\n            response.raise_for_status()\n            data = response.json()\n            logger.info(f\"Fetched external data for '{name}': {data}\")\n            return data\n        except (httpx.HTTPError, httpx.RequestError) as e:\n            logger.error(f\"Failed to fetch external data for '{name}': {e}\")\n            return {\"error\": \"Failed to fetch external data\"}\n\nasync def process_process_data(entity: dict):\n    # Set initial status and timestamp\n    entity['status'] = 'processing'\n    entity['requestedAt'] = datetime.utcnow().isoformat()\n\n    name = entity.get('name')\n    if not name or not isinstance(name, str) or not name.strip():\n        entity['status'] = 'failed'\n        entity['result'] = {'error': 'Missing or invalid \"name\" attribute'}\n        logger.error(\"process_process_data: Missing or invalid 'name' attribute in entity\")\n        return\n\n    # Fetch and enrich entity with external data\n    external_data = await fetch_external_data(name.strip())\n\n    if 'error' in external_data:\n        entity['status'] = 'failed'\n        entity['result'] = external_data\n        logger.error(f\"process_process_data: External API error for '{name}': {external_data['error']}\")\n    else:\n        entity['result'] = {\n            \"inputName\": name.strip(),\n            \"predictedAge\": external_data.get(\"age\"),\n            \"count\": external_data.get(\"count\"),\n            \"source\": \"agify.io\"\n        }\n        entity['status'] = 'completed'\n\n@app.route(\"/process-data\", methods=[\"POST\"])\n@validate_request(ProcessData)\nasync def process_data(data: ProcessData):\n    try:\n        entity_dict = data.__dict__\n        # Defensive copy to avoid side effects outside workflow\n        entity_to_add = dict(entity_dict)\n\n        entity_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"process_data\",\n            entity_version=ENTITY_VERSION,\n            entity=entity_to_add\n        )\n        return jsonify({\"id\": str(entity_id)}), 202\n\n    except Exception as e:\n        logger.exception(f\"Failed to start processing: {e}\")\n        return jsonify({\"error\": \"Failed to start processing\"}), 500\n\n@app.route(\"/results/<string:workflow_id>\", methods=[\"GET\"])\nasync def get_results(workflow_id: str):\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"process_data\",\n            entity_version=ENTITY_VERSION,\n            technical_id=workflow_id\n        )\n        if not item:\n            return jsonify({\"error\": \"Workflow ID not found\"}), 404\n\n        # Defensive access with defaults\n        status = item.get(\"status\", \"unknown\")\n        result = item.get(\"result\", None)\n\n        response = {\n            \"workflowId\": workflow_id,\n            \"status\": status,\n            \"result\": result,\n        }\n        return jsonify(response), 200\n\n    except Exception as e:\n        logger.exception(f\"Error retrieving results for workflow {workflow_id}: {e}\")\n        return jsonify({\"error\": \"Error retrieving results\"}), 500\n\nif __name__ == '__main__':\n    # Run app with threaded=True for better concurrency\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}