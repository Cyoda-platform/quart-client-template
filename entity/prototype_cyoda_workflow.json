{
    "entity_models": [
        {
            "entity_model_name": "weather_fetch_job",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_weather_fetch_job(entity: dict):\n    \"\"\"\n    Workflow function for 'weather_fetch_job' entity.\n    Runs asynchronously before the entity is persisted.\n    Modifies entity in-place to set status and results.\n    \"\"\"\n    entity.setdefault(\"created_at\", datetime.utcnow().isoformat() + \"Z\")\n    entity[\"status\"] = \"processing\"\n    try:\n        entity[\"status\"] = \"fetching\"\n        weather_data = await fetch_weather_data(\n            entity[\"latitude\"],\n            entity[\"longitude\"],\n            entity[\"parameters\"],\n            entity[\"start_date\"],\n            entity[\"end_date\"],\n        )\n        result_data = {\n            \"latitude\": entity[\"latitude\"],\n            \"longitude\": entity[\"longitude\"],\n            \"parameters\": weather_data.get(\"hourly\", {}),\n            \"start_date\": entity[\"start_date\"],\n            \"end_date\": entity[\"end_date\"],\n            \"fetched_at\": datetime.utcnow().isoformat() + \"Z\",\n        }\n        entity[\"result\"] = result_data\n        entity[\"status\"] = \"completed\"\n        # Clear error if previously set\n        entity.pop(\"error\", None)\n    except Exception as e:\n        logger.exception(\"Weather fetch failed in workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n        # Clear result if previously set\n        entity.pop(\"result\", None)\n    return entity",
                "name": "process_weather_fetch_job"
            }
        }
    ],
    "file_without_workflow": {
        "code": " from dataclasses import dataclass\nfrom typing import List\nimport logging\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass WeatherFetch:\n    latitude: float\n    longitude: float\n    parameters: List[str]\n    start_date: str\n    end_date: str\n\nasync def fetch_weather_data(latitude, longitude, parameters, start_date, end_date):\n    base_url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"timezone\": \"UTC\",\n        \"hourly\": \",\".join(parameters),\n    }\n    async with httpx.AsyncClient() as client:\n        response = await client.get(base_url, params=params)\n        response.raise_for_status()\n        return response.json()\n\nasync def process_weather_fetch_job(entity: dict):\n    \"\"\"\n    Workflow function for 'weather_fetch_job' entity.\n    Runs asynchronously before the entity is persisted.\n    Modifies entity in-place to set status and results.\n    \"\"\"\n    entity.setdefault(\"created_at\", datetime.utcnow().isoformat() + \"Z\")\n    entity[\"status\"] = \"processing\"\n    try:\n        entity[\"status\"] = \"fetching\"\n        weather_data = await fetch_weather_data(\n            entity[\"latitude\"],\n            entity[\"longitude\"],\n            entity[\"parameters\"],\n            entity[\"start_date\"],\n            entity[\"end_date\"],\n        )\n        result_data = {\n            \"latitude\": entity[\"latitude\"],\n            \"longitude\": entity[\"longitude\"],\n            \"parameters\": weather_data.get(\"hourly\", {}),\n            \"start_date\": entity[\"start_date\"],\n            \"end_date\": entity[\"end_date\"],\n            \"fetched_at\": datetime.utcnow().isoformat() + \"Z\",\n        }\n        entity[\"result\"] = result_data\n        entity[\"status\"] = \"completed\"\n        # Clear error if previously set\n        entity.pop(\"error\", None)\n    except Exception as e:\n        logger.exception(\"Weather fetch failed in workflow\")\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = str(e)\n        # Clear result if previously set\n        entity.pop(\"result\", None)\n    return entity\n\n@app.route(\"/weather/fetch\", methods=[\"POST\"])\n@validate_request(WeatherFetch)\nasync def weather_fetch(data: WeatherFetch):\n    # Prepare entity data dict\n    data_dict = data.__dict__.copy()\n    # Workflow sets status and timestamps\n    try:\n        job_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_job\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n    except Exception as e:\n        logger.exception(\"Failed to add weather_fetch_job entity\")\n        return jsonify({\"status\": \"error\", \"message\": \"Failed to initiate weather fetch\"}), 500\n\n    return jsonify({\n        \"status\": \"success\",\n        \"message\": \"Weather data fetch completed or failed, see status\",\n        \"request_id\": job_id,\n    })\n\n@app.route(\"/weather/result/<string:job_id>\", methods=[\"GET\"])\nasync def weather_result(job_id: str):\n    try:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_job\",\n            entity_version=ENTITY_VERSION,\n            technical_id=job_id\n        )\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"status\": \"error\", \"message\": \"Request ID not found\"}), 404\n\n    if not job:\n        return jsonify({\"status\": \"error\", \"message\": \"Request ID not found\"}), 404\n\n    status = job.get(\"status\")\n    if status in (\"processing\", \"fetching\"):\n        return jsonify({\"status\": \"processing\", \"message\": \"Data is still being fetched\"}), 202\n    if status == \"failed\":\n        return jsonify({\"status\": \"failed\", \"error\": job.get(\"error\", \"Unknown error\")}), 500\n    return jsonify({\"status\": \"success\", \"data\": job.get(\"result\")})\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}