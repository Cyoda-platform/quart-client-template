{
    "entity_models": [
        {
            "entity_model_name": "pet_search_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from typing import Dict, Any\nimport logging\nimport httpx\n\nlogger = logging.getLogger(__name__)\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"",
                "content": "async def process_pet_search_request(entity: Dict[str, Any]) -> Dict[str, Any]:\n    pet_type = entity.get(\"type\")\n    status = entity.get(\"status\", \"available\")\n\n    params = {\"status\": status}\n    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            r = await client.get(url, params=params)\n            r.raise_for_status()\n            pets = r.json()\n        except Exception as e:\n            logger.error(f\"Failed to fetch pets in search workflow: {e}\")\n            pets = []\n\n    if pet_type:\n        pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == pet_type.lower()]\n\n    entity[\"results\"] = [\n        {\n            \"id\": p.get(\"id\"),\n            \"name\": p.get(\"name\"),\n            \"type\": p.get(\"category\", {}).get(\"name\", \"\"),\n            \"status\": p.get(\"status\"),\n            \"photoUrls\": p.get(\"photoUrls\", []),\n        }\n        for p in pets\n    ]\n\n    return entity",
                "name": "process_pet_search_request"
            }
        },
        {
            "entity_model_name": "favorite_entity",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from typing import Dict, Any\nimport logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n# entity_service and cyoda_auth_service are used from outer scope\n# ENTITY_VERSION constant is used\n",
                "content": "async def process_favorite_entity(entity: Dict[str, Any]) -> Dict[str, Any]:\n    user_id = entity.get(\"user_id\")\n    pet_id = entity.get(\"pet_id\")\n    action = entity.get(\"action\")\n\n    if not user_id or not pet_id or action not in {\"add\", \"remove\"}:\n        logger.warning(\"Invalid favorite_entity data, skipping processing\")\n        return entity\n\n    favorite_entity_model = \"favorite_record\"\n    favorite_entity_id = f\"{user_id}_{pet_id}\"\n\n    if action == \"add\":\n        try:\n            existing = await entity_service.get_item(\n                token=cyoda_auth_service,\n                entity_model=favorite_entity_model,\n                entity_id=favorite_entity_id,\n                entity_version=ENTITY_VERSION,\n            )\n        except Exception as e:\n            logger.error(f\"Failed to get favorite record: {e}\")\n            existing = None\n\n        if not existing:\n            fav_entity = {\n                \"id\": favorite_entity_id,\n                \"user_id\": user_id,\n                \"pet_id\": pet_id,\n                \"added_at\": datetime.utcnow().isoformat() + \"Z\",\n            }\n            try:\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=favorite_entity_model,\n                    entity_version=ENTITY_VERSION,\n                    entity=fav_entity,\n                    workflow=None,\n                )\n            except Exception as e:\n                logger.error(f\"Failed to add favorite record: {e}\")\n    elif action == \"remove\":\n        try:\n            await entity_service.delete_item(\n                token=cyoda_auth_service,\n                entity_model=favorite_entity_model,\n                entity_id=favorite_entity_id,\n                entity_version=ENTITY_VERSION,\n            )\n        except Exception as e:\n            logger.warning(f\"Failed to delete favorite record {favorite_entity_id}: {e}\")\n\n    try:\n        favorites_list = await entity_service.search_items(\n            token=cyoda_auth_service,\n            entity_model=favorite_entity_model,\n            entity_version=ENTITY_VERSION,\n            filters={\"user_id\": user_id},\n        )\n        favorite_count = len(favorites_list)\n    except Exception as e:\n        logger.error(f\"Failed to count favorites for user {user_id}: {e}\")\n        favorite_count = 0\n\n    entity[\"favoriteCount\"] = favorite_count\n\n    return entity",
                "name": "process_favorite_entity"
            }
        },
        {
            "entity_model_name": "pet_entity",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from typing import Dict, Any\nimport logging\nfrom datetime import datetime\nimport httpx\n\nlogger = logging.getLogger(__name__)\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"",
                "content": "async def process_pet_entity(entity: Dict[str, Any]) -> Dict[str, Any]:\n    pet_id = entity.get(\"id\")\n    if pet_id is None:\n        logger.warning(\"Pet entity missing 'id', skipping enrichment\")\n        return entity\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            r = await client.get(f\"{PETSTORE_BASE_URL}/pet/{pet_id}\")\n            r.raise_for_status()\n            pet_data = r.json()\n        except Exception as e:\n            logger.error(f\"Failed to fetch pet data for id {pet_id}: {e}\")\n            pet_data = None\n\n    if pet_data:\n        entity[\"name\"] = pet_data.get(\"name\", entity.get(\"name\"))\n        entity[\"type\"] = pet_data.get(\"category\", {}).get(\"name\", entity.get(\"type\"))\n        entity[\"status\"] = pet_data.get(\"status\", entity.get(\"status\"))\n        entity[\"photoUrls\"] = pet_data.get(\"photoUrls\", entity.get(\"photoUrls\", []))\n        entity[\"last_enriched_at\"] = datetime.utcnow().isoformat() + \"Z\"\n    else:\n        logger.info(f\"No enrichment data for pet id {pet_id}\")\n\n    return entity",
                "name": "process_pet_entity"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nfrom typing import Dict, Any, List, Optional\nimport asyncio\nimport logging\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\nPETSTORE_BASE_URL = \"https://petstore3.swagger.io/api/v3\"\n\n@dataclass\nclass SearchRequest:\n    type: Optional[str] = None\n    status: Optional[str] = None\n\n@dataclass\nclass PetIdRequest:\n    petId: int\n\n# Workflow function for pet_entity\nasync def process_pet_entity(entity: Dict[str, Any]) -> Dict[str, Any]:\n    pet_id = entity.get(\"id\")\n    if pet_id is None:\n        logger.warning(\"Pet entity missing 'id', skipping enrichment\")\n        return entity\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            r = await client.get(f\"{PETSTORE_BASE_URL}/pet/{pet_id}\")\n            r.raise_for_status()\n            pet_data = r.json()\n        except Exception as e:\n            logger.error(f\"Failed to fetch pet data for id {pet_id}: {e}\")\n            pet_data = None\n\n    if pet_data:\n        entity[\"name\"] = pet_data.get(\"name\", entity.get(\"name\"))\n        entity[\"type\"] = pet_data.get(\"category\", {}).get(\"name\", entity.get(\"type\"))\n        entity[\"status\"] = pet_data.get(\"status\", entity.get(\"status\"))\n        entity[\"photoUrls\"] = pet_data.get(\"photoUrls\", entity.get(\"photoUrls\", []))\n        entity[\"last_enriched_at\"] = datetime.utcnow().isoformat() + \"Z\"\n    else:\n        logger.info(f\"No enrichment data for pet id {pet_id}\")\n\n    return entity\n\n# Workflow function for favorite_entity\nasync def process_favorite_entity(entity: Dict[str, Any]) -> Dict[str, Any]:\n    user_id = entity.get(\"user_id\")\n    pet_id = entity.get(\"pet_id\")\n    action = entity.get(\"action\")\n\n    if not user_id or not pet_id or action not in {\"add\", \"remove\"}:\n        logger.warning(\"Invalid favorite_entity data, skipping processing\")\n        return entity\n\n    favorite_entity_model = \"favorite_record\"\n    favorite_entity_id = f\"{user_id}_{pet_id}\"\n\n    if action == \"add\":\n        try:\n            existing = await entity_service.get_item(\n                token=cyoda_auth_service,\n                entity_model=favorite_entity_model,\n                entity_id=favorite_entity_id,\n                entity_version=ENTITY_VERSION,\n            )\n        except Exception as e:\n            logger.error(f\"Failed to get favorite record: {e}\")\n            existing = None\n\n        if not existing:\n            fav_entity = {\n                \"id\": favorite_entity_id,\n                \"user_id\": user_id,\n                \"pet_id\": pet_id,\n                \"added_at\": datetime.utcnow().isoformat() + \"Z\",\n            }\n            try:\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=favorite_entity_model,\n                    entity_version=ENTITY_VERSION,\n                    entity=fav_entity,\n                    workflow=None,\n                )\n            except Exception as e:\n                logger.error(f\"Failed to add favorite record: {e}\")\n    elif action == \"remove\":\n        try:\n            await entity_service.delete_item(\n                token=cyoda_auth_service,\n                entity_model=favorite_entity_model,\n                entity_id=favorite_entity_id,\n                entity_version=ENTITY_VERSION,\n            )\n        except Exception as e:\n            logger.warning(f\"Failed to delete favorite record {favorite_entity_id}: {e}\")\n\n    try:\n        favorites_list = await entity_service.search_items(\n            token=cyoda_auth_service,\n            entity_model=favorite_entity_model,\n            entity_version=ENTITY_VERSION,\n            filters={\"user_id\": user_id},\n        )\n        favorite_count = len(favorites_list)\n    except Exception as e:\n        logger.error(f\"Failed to count favorites for user {user_id}: {e}\")\n        favorite_count = 0\n\n    entity[\"favoriteCount\"] = favorite_count\n\n    return entity\n\n# Workflow function for pet_search_request entity\nasync def process_pet_search_request(entity: Dict[str, Any]) -> Dict[str, Any]:\n    pet_type = entity.get(\"type\")\n    status = entity.get(\"status\", \"available\")\n\n    params = {\"status\": status}\n    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            r = await client.get(url, params=params)\n            r.raise_for_status()\n            pets = r.json()\n        except Exception as e:\n            logger.error(f\"Failed to fetch pets in search workflow: {e}\")\n            pets = []\n\n    if pet_type:\n        pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == pet_type.lower()]\n\n    entity[\"results\"] = [\n        {\n            \"id\": p.get(\"id\"),\n            \"name\": p.get(\"name\"),\n            \"type\": p.get(\"category\", {}).get(\"name\", \"\"),\n            \"status\": p.get(\"status\"),\n            \"photoUrls\": p.get(\"photoUrls\", []),\n        }\n        for p in pets\n    ]\n\n    return entity\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchRequest)\nasync def pets_search(data: SearchRequest):\n    entity_data = {\n        \"type\": data.type,\n        \"status\": data.status or \"available\",\n        \"requested_at\": datetime.utcnow().isoformat() + \"Z\",\n    }\n\n    entity_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"pet_search_request\",\n        entity_version=ENTITY_VERSION,\n        entity=entity_data\n    )\n\n    return jsonify({\"searchRequestId\": entity_id})\n\n@app.route(\"/favorites/add\", methods=[\"POST\"])\n@validate_request(PetIdRequest)\nasync def favorites_add(data: PetIdRequest):\n    user_id = \"dummy_user\"\n\n    entity_data = {\n        \"user_id\": user_id,\n        \"pet_id\": data.petId,\n        \"action\": \"add\",\n        \"requested_at\": datetime.utcnow().isoformat() + \"Z\",\n    }\n\n    entity_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"favorite_entity\",\n        entity_version=ENTITY_VERSION,\n        entity=entity_data\n    )\n\n    return jsonify({\"message\": \"Pet added to favorites\", \"favoriteCount\": entity_data.get(\"favoriteCount\", 0)})\n\n@app.route(\"/favorites/remove\", methods=[\"POST\"])\n@validate_request(PetIdRequest)\nasync def favorites_remove(data: PetIdRequest):\n    user_id = \"dummy_user\"\n\n    entity_data = {\n        \"user_id\": user_id,\n        \"pet_id\": data.petId,\n        \"action\": \"remove\",\n        \"requested_at\": datetime.utcnow().isoformat() + \"Z\",\n    }\n\n    entity_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"favorite_entity\",\n        entity_version=ENTITY_VERSION,\n        entity=entity_data\n    )\n\n    return jsonify({\"message\": \"Pet removed from favorites\", \"favoriteCount\": entity_data.get(\"favoriteCount\", 0)})\n\n@app.route(\"/favorites\", methods=[\"GET\"])\nasync def favorites_get():\n    user_id = \"dummy_user\"\n    favorite_entity_model = \"favorite_record\"\n\n    try:\n        favorites_list = await entity_service.search_items(\n            token=cyoda_auth_service,\n            entity_model=favorite_entity_model,\n            entity_version=ENTITY_VERSION,\n            filters={\"user_id\": user_id},\n        )\n    except Exception as e:\n        logger.error(f\"Failed to fetch favorites for user {user_id}: {e}\")\n        favorites_list = []\n\n    pet_ids = {fav.get(\"pet_id\") for fav in favorites_list if fav.get(\"pet_id\")}\n\n    pets = []\n    async with httpx.AsyncClient(timeout=10) as client:\n        tasks = []\n        for pet_id in pet_ids:\n            tasks.append(client.get(f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"))\n        responses = await asyncio.gather(*tasks, return_exceptions=True)\n        for resp in responses:\n            if isinstance(resp, Exception):\n                logger.warning(f\"Error fetching pet in favorites_get: {resp}\")\n                continue\n            if resp.status_code == 200:\n                pets.append(resp.json())\n\n    def pet_to_response_obj(pet: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            \"id\": pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\", \"\"),\n            \"status\": pet.get(\"status\", \"\"),\n            \"photoUrls\": pet.get(\"photoUrls\", []),\n        }\n\n    return jsonify({\"favorites\": [pet_to_response_obj(p) for p in pets]})\n\n@app.route(\"/pet\", methods=[\"POST\"])\nasync def add_pet():\n    data = await request.get_json()\n    if not data:\n        return jsonify({\"error\": \"Missing pet data\"}), 400\n    # Assume validation done elsewhere or here if needed\n\n    entity_id = await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=\"pet_entity\",\n        entity_version=ENTITY_VERSION,\n        entity=data\n    )\n    return jsonify({\"message\": \"Pet entity added\", \"entityId\": entity_id})\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}