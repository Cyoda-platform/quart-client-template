{
    "entity_models": [
        {
            "entity_model_name": "weather_fetch_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_weather_fetch_request(entity: dict) -> dict:\n    # Set initial processing state and timestamp\n    entity['status'] = 'processing'\n    entity['requestedAt'] = datetime.utcnow().isoformat() + \"Z\"\n\n    # Validate required keys to prevent KeyError\n    try:\n        latitude = entity[\"latitude\"]\n        longitude = entity[\"longitude\"]\n        parameters = entity[\"parameters\"]\n    except KeyError as e:\n        entity['status'] = 'failed'\n        entity['error'] = f\"Missing required field: {e.args[0]}\"\n        entity['completedAt'] = datetime.utcnow().isoformat() + \"Z\"\n        return entity\n\n    # Defensive validation of parameters type\n    if not isinstance(parameters, list) or not all(isinstance(p, str) for p in parameters):\n        entity['status'] = 'failed'\n        entity['error'] = \"Parameter 'parameters' must be a list of strings.\"\n        entity['completedAt'] = datetime.utcnow().isoformat() + \"Z\"\n        return entity\n\n    # Optional dates validation if present\n    start_date = entity.get(\"start_date\")\n    end_date = entity.get(\"end_date\")\n    # Could add date format validation here if needed\n\n    try:\n        weather_data = await fetch_weather_from_api(\n            latitude=latitude,\n            longitude=longitude,\n            parameters=parameters,\n            start_date=start_date,\n            end_date=end_date\n        )\n        entity['status'] = 'completed'\n        entity['data'] = weather_data\n        entity['location'] = {\"latitude\": latitude, \"longitude\": longitude}\n        entity['completedAt'] = datetime.utcnow().isoformat() + \"Z\"\n    except Exception as e:\n        entity['status'] = 'failed'\n        entity['error'] = str(e)\n        entity['completedAt'] = datetime.utcnow().isoformat() + \"Z\"\n        logger.exception(\"Failed to fetch weather data in workflow\")\n\n    return entity",
                "name": "process_weather_fetch_request"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport logging\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass WeatherFetchRequest:\n    latitude: float\n    longitude: float\n    parameters: List[str]\n    start_date: Optional[str] = None\n    end_date: Optional[str] = None\n\nasync def fetch_weather_from_api(latitude: float, longitude: float, parameters: list, start_date: str = None, end_date: str = None) -> Dict[str, Any]:\n    base_url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"hourly\": \",\".join(parameters)\n    }\n    if start_date:\n        params[\"start_date\"] = start_date\n    if end_date:\n        params[\"end_date\"] = end_date\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            resp = await client.get(base_url, params=params)\n            resp.raise_for_status()\n            return resp.json()\n        except Exception as e:\n            logger.exception(f\"Error fetching weather data from external API: {e}\")\n            raise\n\n@app.route(\"/weather/fetch\", methods=[\"POST\"])\n@validate_request(WeatherFetchRequest)\nasync def weather_fetch(data: WeatherFetchRequest):\n    data_dict = data.__dict__\n    try:\n        job_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_request\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to add new weather fetch request: {e}\")\n        return jsonify({\"error\": \"Failed to create request\"}), 500\n\n    return jsonify({\"request_id\": job_id, \"status\": \"processing\"}), 202\n\n@app.route(\"/weather/result/<string:request_id>\", methods=[\"GET\"])\nasync def weather_result(request_id):\n    try:\n        job = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"weather_fetch_request\",\n            entity_version=ENTITY_VERSION,\n            technical_id=request_id\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to get job {request_id}: {e}\")\n        return jsonify({\"error\": \"Request ID not found\"}), 404\n\n    if not job:\n        return jsonify({\"error\": \"Request ID not found\"}), 404\n\n    response = {\n        \"request_id\": request_id,\n        \"status\": job.get(\"status\"),\n        \"requestedAt\": job.get(\"requestedAt\"),\n    }\n    if job.get(\"status\") == \"completed\":\n        response.update({\n            \"location\": job.get(\"location\"),\n            \"parameters\": job.get(\"parameters\"),\n            \"data\": job.get(\"data\"),\n            \"completedAt\": job.get(\"completedAt\"),\n        })\n    elif job.get(\"status\") == \"failed\":\n        response.update({\n            \"error\": job.get(\"error\"),\n            \"completedAt\": job.get(\"completedAt\"),\n        })\n\n    return jsonify(response)\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}