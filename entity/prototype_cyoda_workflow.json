{
    "entity_models": [
        {
            "entity_model_name": "petsearchrequest",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport httpx\nimport logging\nlogger = logging.getLogger(__name__)\n\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"",
                "content": "async def process_petsearchrequest(entity: dict) -> dict:\n    pets = await query_pets(entity.get(\"type\"), entity.get(\"status\"), entity.get(\"tags\"))\n    entity[\"pets\"] = pets\n    return entity",
                "name": "process_petsearchrequest"
            }
        },
        {
            "entity_model_name": "adoptpetrequest",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport httpx\nimport logging\nlogger = logging.getLogger(__name__)\n\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"\n\n# cache is instance of AsyncCache defined in the module",
                "content": "async def process_adoptpetrequest(entity: dict) -> dict:\n    pet_id = entity.get(\"petId\")\n    adopter_name = entity.get(\"adopterName\")\n    pet_info = None\n\n    try:\n        all_searches = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"petsearchrequest\",\n            entity_version=ENTITY_VERSION,\n        )\n        for search in all_searches:\n            pets = search.get(\"pets\")\n            if pets is None:\n                pets = await query_pets(search.get(\"type\"), search.get(\"status\"), search.get(\"tags\"))\n            for pet in pets:\n                if str(pet.get(\"id\")) == str(pet_id):\n                    pet_info = {\n                        \"id\": str(pet.get(\"id\")),\n                        \"name\": pet.get(\"name\"),\n                        \"type\": pet.get(\"category\", {}).get(\"name\"),\n                        \"status\": pet.get(\"status\")\n                    }\n                    break\n            if pet_info:\n                break\n    except Exception as e:\n        logger.exception(\"Failed to find pet info from petsearchrequest entities: %s\", e)\n\n    if pet_info is None:\n        try:\n            async with httpx.AsyncClient() as client:\n                resp = await client.get(f\"{PETSTORE_API_BASE}/pet/{pet_id}\")\n                resp.raise_for_status()\n                pet = resp.json()\n                pet_info = {\n                    \"id\": str(pet.get(\"id\")),\n                    \"name\": pet.get(\"name\"),\n                    \"type\": pet.get(\"category\", {}).get(\"name\"),\n                    \"status\": pet.get(\"status\")\n                }\n        except Exception as e:\n            logger.warning(\"Failed to fetch pet info from external API: %s\", e)\n            pet_info = {\"id\": str(pet_id), \"name\": None, \"type\": None, \"status\": None}\n\n    await cache.add_adoption(adopter_name, pet_info)\n\n    entity[\"adoptionStatus\"] = \"confirmed\"\n    entity[\"petInfo\"] = pet_info\n\n    return entity",
                "name": "process_adoptpetrequest"
            }
        }
    ],
    "file_without_workflow": {
        "code": " from dataclasses import dataclass\nimport asyncio\nimport logging\nimport uuid\nfrom datetime import datetime\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass PetSearchRequest:\n    type: str = None\n    status: str = None\n    tags: list[str] = None\n\n@dataclass\nclass AdoptPetRequest:\n    petId: str  # changed to string id\n    adopterName: str\n\nclass AsyncCache:\n    def __init__(self):\n        self._adoptions = {}\n        self._lock = asyncio.Lock()\n\n    async def add_adoption(self, adopter_name: str, pet: dict):\n        async with self._lock:\n            if adopter_name not in self._adoptions:\n                self._adoptions[adopter_name] = []\n            self._adoptions[adopter_name].append(pet)\n\n    async def get_adoptions(self, adopter_name: str):\n        async with self._lock:\n            return self._adoptions.get(adopter_name, [])\n\ncache = AsyncCache()\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"\n\nasync def query_pets(type_: str = None, status: str = None, tags: list[str] = None) -> list[dict]:\n    params = {}\n    if status:\n        params[\"status\"] = status\n    url = f\"{PETSTORE_API_BASE}/pet/findByStatus\"\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.get(url, params=params)\n            resp.raise_for_status()\n            pets = resp.json()\n        except Exception as e:\n            logger.exception(f\"Failed to fetch pets from external API: {e}\")\n            return []\n    def pet_matches(pet: dict) -> bool:\n        if type_ and pet.get(\"category\", {}).get(\"name\", \"\").lower() != type_.lower():\n            return False\n        if tags:\n            pet_tags = [t.get(\"name\", \"\").lower() for t in pet.get(\"tags\", [])]\n            if not all(t.lower() in pet_tags for t in tags):\n                return False\n        return True\n    return [p for p in pets if pet_matches(p)]\n\n# Workflow function for petsearchrequest entity\nasync def process_petsearchrequest(entity: dict) -> dict:\n    pets = await query_pets(entity.get(\"type\"), entity.get(\"status\"), entity.get(\"tags\"))\n    entity[\"pets\"] = pets\n    return entity\n\n# Workflow function for adoptpetrequest entity\nasync def process_adoptpetrequest(entity: dict) -> dict:\n    pet_id = entity.get(\"petId\")\n    adopter_name = entity.get(\"adopterName\")\n    pet_info = None\n\n    try:\n        all_searches = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"petsearchrequest\",\n            entity_version=ENTITY_VERSION,\n        )\n        for search in all_searches:\n            pets = search.get(\"pets\")\n            if pets is None:\n                pets = await query_pets(search.get(\"type\"), search.get(\"status\"), search.get(\"tags\"))\n            for pet in pets:\n                if str(pet.get(\"id\")) == str(pet_id):\n                    pet_info = {\n                        \"id\": str(pet.get(\"id\")),\n                        \"name\": pet.get(\"name\"),\n                        \"type\": pet.get(\"category\", {}).get(\"name\"),\n                        \"status\": pet.get(\"status\")\n                    }\n                    break\n            if pet_info:\n                break\n    except Exception as e:\n        logger.exception(\"Failed to find pet info from petsearchrequest entities: %s\", e)\n\n    if pet_info is None:\n        try:\n            async with httpx.AsyncClient() as client:\n                resp = await client.get(f\"{PETSTORE_API_BASE}/pet/{pet_id}\")\n                resp.raise_for_status()\n                pet = resp.json()\n                pet_info = {\n                    \"id\": str(pet.get(\"id\")),\n                    \"name\": pet.get(\"name\"),\n                    \"type\": pet.get(\"category\", {}).get(\"name\"),\n                    \"status\": pet.get(\"status\")\n                }\n        except Exception as e:\n            logger.warning(\"Failed to fetch pet info from external API: %s\", e)\n            pet_info = {\"id\": str(pet_id), \"name\": None, \"type\": None, \"status\": None}\n\n    await cache.add_adoption(adopter_name, pet_info)\n\n    entity[\"adoptionStatus\"] = \"confirmed\"\n    entity[\"petInfo\"] = pet_info\n\n    return entity\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(PetSearchRequest)\nasync def pets_search(data: PetSearchRequest):\n    data_dict = {\n        \"type\": data.type,\n        \"status\": data.status,\n        \"tags\": data.tags,\n    }\n    try:\n        id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"petsearchrequest\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"searchId\": id})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add pet search request\"}), 500\n\n@app.route(\"/pets/search/<search_id>\", methods=[\"GET\"])\nasync def get_search_results(search_id):\n    try:\n        result = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"petsearchrequest\",\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id\n        )\n        if not result:\n            return jsonify({\"error\": \"Search ID not found or results not ready\"}), 404\n        pets = result.get(\"pets\")\n        if pets is None:\n            pets = await query_pets(result.get(\"type\"), result.get(\"status\"), result.get(\"tags\"))\n        simplified = []\n        for p in pets:\n            simplified.append({\n                \"id\": str(p.get(\"id\")),\n                \"name\": p.get(\"name\"),\n                \"type\": p.get(\"category\", {}).get(\"name\"),\n                \"status\": p.get(\"status\"),\n                \"tags\": [t.get(\"name\") for t in p.get(\"tags\", []) if t.get(\"name\")]\n            })\n        return jsonify({\"searchId\": search_id, \"pets\": simplified})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve search results\"}), 500\n\n@app.route(\"/pets/adopt\", methods=[\"POST\"])\n@validate_request(AdoptPetRequest)\nasync def adopt_pet(data: AdoptPetRequest):\n    data_dict = {\n        \"petId\": data.petId,\n        \"adopterName\": data.adopterName,\n    }\n    try:\n        id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"adoptpetrequest\",\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\n            \"adoptionId\": id,\n            \"petId\": data.petId,\n            \"adopterName\": data.adopterName,\n            \"adoptionStatus\": \"confirmed\"\n        })\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to process adoption request\"}), 500\n\n@app.route(\"/pets/adoptions/<adopter_name>\", methods=[\"GET\"])\nasync def get_adoptions(adopter_name):\n    adopted_pets = await cache.get_adoptions(adopter_name)\n    return jsonify({\n        \"adopterName\": adopter_name,\n        \"adoptedPets\": adopted_pets\n    })\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}