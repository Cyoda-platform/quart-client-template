{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport asyncio\nimport uuid\n\nPET_CACHE_MODEL = \"pet_cache\"\nENTITY_VERSION = ENTITY_VERSION  # imported from common.config.config\n\n# generate_id function\ndef generate_id() -> str:\n    return str(uuid.uuid4())",
                "content": "async def process_pet(entity: dict):\n    # Generate searchId if missing\n    search_id = entity.get(\"searchId\") or generate_id()\n    entity[\"searchId\"] = search_id\n    entity[\"status\"] = \"pending\"\n    entity[\"createdAt\"] = datetime.utcnow().isoformat()\n    entity[\"updatedAt\"] = entity[\"createdAt\"]\n    # Create cache entity for search results\n    cache_entity = {\n        \"searchId\": search_id,\n        \"status\": \"pending\",\n        \"results\": [],\n        \"createdAt\": entity[\"createdAt\"],\n        \"updatedAt\": entity[\"createdAt\"]\n    }\n    # Add cache entity (different model)\n    await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=PET_CACHE_MODEL,\n        entity_version=ENTITY_VERSION,\n        entity=cache_entity\n    )\n    # Fire and forget async task to process search and update cache\n    asyncio.create_task(_process_pet_search_task(search_id, entity.get(\"type\"), entity.get(\"status\")))",
                "name": "process_pet"
            }
        },
        {
            "entity_model_name": "pet_detail",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport asyncio\nimport uuid\n\nPET_DETAIL_CACHE_MODEL = \"pet_detail_cache\"\nENTITY_VERSION = ENTITY_VERSION  # imported from common.config.config\n\ndef generate_id() -> str:\n    return str(uuid.uuid4())",
                "content": "async def process_pet_detail(entity: dict):\n    detail_id = entity.get(\"detailId\") or generate_id()\n    entity[\"detailId\"] = detail_id\n    entity[\"status\"] = \"pending\"\n    entity[\"createdAt\"] = datetime.utcnow().isoformat()\n    entity[\"updatedAt\"] = entity[\"createdAt\"]\n    cache_entity = {\n        \"detailId\": detail_id,\n        \"status\": \"pending\",\n        \"detail\": {},\n        \"createdAt\": entity[\"createdAt\"],\n        \"updatedAt\": entity[\"createdAt\"]\n    }\n    await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=PET_DETAIL_CACHE_MODEL,\n        entity_version=ENTITY_VERSION,\n        entity=cache_entity\n    )\n    asyncio.create_task(_process_pet_detail_task(detail_id, entity.get(\"petId\")))",
                "name": "process_pet_detail"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nimport uuid\n\nfrom quart import Quart, request, jsonify\nfrom quart_schema import QuartSchema, validate_request, validate_querystring\nimport httpx\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SearchRequest:\n    type: str = None\n    status: str = None\n\n@dataclass\nclass DetailRequest:\n    petId: int\n\n# Entity models for caching processed results\nPET_CACHE_MODEL = \"pet_cache\"\nPET_DETAIL_CACHE_MODEL = \"pet_detail_cache\"\n\nPETSTORE_BASE_URL = \"https://petstore.swagger.io/v2\"\n\ndef generate_id() -> str:\n    return str(uuid.uuid4())\n\nasync def fetch_pets_from_petstore(type_: str = None, status: str = None) -> list:\n    query_params = {}\n    # Always default to 'available' if no status provided\n    query_params[\"status\"] = status if status else \"available\"\n    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, params=query_params, timeout=10)\n            response.raise_for_status()\n            pets = response.json()\n            if type_:\n                return [pet for pet in pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == type_.lower()]\n            return pets\n        except Exception as e:\n            logger.exception(f\"Failed fetching pets from Petstore: {e}\")\n            return []\n\nasync def fetch_pet_detail_from_petstore(pet_id: int) -> dict:\n    url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, timeout=10)\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            logger.exception(f\"Failed fetching pet detail for id {pet_id}: {e}\")\n            return {}\n\n# Workflow function for 'pet' entity\nasync def process_pet(entity: dict):\n    # Generate searchId if missing\n    search_id = entity.get(\"searchId\") or generate_id()\n    entity[\"searchId\"] = search_id\n    entity[\"status\"] = \"pending\"\n    entity[\"createdAt\"] = datetime.utcnow().isoformat()\n    entity[\"updatedAt\"] = entity[\"createdAt\"]\n    # Create cache entity for search results\n    cache_entity = {\n        \"searchId\": search_id,\n        \"status\": \"pending\",\n        \"results\": [],\n        \"createdAt\": entity[\"createdAt\"],\n        \"updatedAt\": entity[\"createdAt\"]\n    }\n    # Add cache entity (different model)\n    await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=PET_CACHE_MODEL,\n        entity_version=ENTITY_VERSION,\n        entity=cache_entity\n    )\n    # Fire and forget async task to process search and update cache\n    asyncio.create_task(_process_pet_search_task(search_id, entity.get(\"type\"), entity.get(\"status\")))\n\nasync def _process_pet_search_task(search_id: str, type_: str, status: str):\n    # Defensive: wait a tiny bit to avoid race conditions during persistence (optional)\n    await asyncio.sleep(0.1)\n    try:\n        # Update cache status to processing\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_CACHE_MODEL,\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id,\n            entity={\n                \"status\": \"processing\",\n                \"updatedAt\": datetime.utcnow().isoformat()\n            }\n        )\n        pets = await fetch_pets_from_petstore(type_, status)\n        results = []\n        for pet in pets:\n            results.append({\n                \"id\": pet.get(\"id\"),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n                \"status\": pet.get(\"status\")\n            })\n        # Update cache with results and done status\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_CACHE_MODEL,\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id,\n            entity={\n                \"results\": results,\n                \"status\": \"done\",\n                \"updatedAt\": datetime.utcnow().isoformat()\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Error processing pet search {search_id}: {e}\")\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=PET_CACHE_MODEL,\n                entity_version=ENTITY_VERSION,\n                technical_id=search_id,\n                entity={\"status\": \"error\", \"updatedAt\": datetime.utcnow().isoformat()}\n            )\n        except Exception:\n            logger.error(f\"Failed to update error status for pet search {search_id}\")\n\n# Workflow function for 'pet_detail' entity\nasync def process_pet_detail(entity: dict):\n    detail_id = entity.get(\"detailId\") or generate_id()\n    entity[\"detailId\"] = detail_id\n    entity[\"status\"] = \"pending\"\n    entity[\"createdAt\"] = datetime.utcnow().isoformat()\n    entity[\"updatedAt\"] = entity[\"createdAt\"]\n    cache_entity = {\n        \"detailId\": detail_id,\n        \"status\": \"pending\",\n        \"detail\": {},\n        \"createdAt\": entity[\"createdAt\"],\n        \"updatedAt\": entity[\"createdAt\"]\n    }\n    await entity_service.add_item(\n        token=cyoda_auth_service,\n        entity_model=PET_DETAIL_CACHE_MODEL,\n        entity_version=ENTITY_VERSION,\n        entity=cache_entity\n    )\n    asyncio.create_task(_process_pet_detail_task(detail_id, entity.get(\"petId\")))\n\nasync def _process_pet_detail_task(detail_id: str, pet_id: int):\n    await asyncio.sleep(0.1)\n    try:\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_DETAIL_CACHE_MODEL,\n            entity_version=ENTITY_VERSION,\n            technical_id=detail_id,\n            entity={\n                \"status\": \"processing\",\n                \"updatedAt\": datetime.utcnow().isoformat()\n            }\n        )\n        pet = await fetch_pet_detail_from_petstore(pet_id)\n        description = pet.get(\"description\") or \"No description available.\"\n        pet_processed = {\n            \"id\": pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n            \"status\": pet.get(\"status\"),\n            \"description\": description,\n        }\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=PET_DETAIL_CACHE_MODEL,\n            entity_version=ENTITY_VERSION,\n            technical_id=detail_id,\n            entity={\n                \"detail\": pet_processed,\n                \"status\": \"done\",\n                \"updatedAt\": datetime.utcnow().isoformat()\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Error processing pet detail {detail_id}: {e}\")\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=PET_DETAIL_CACHE_MODEL,\n                entity_version=ENTITY_VERSION,\n                technical_id=detail_id,\n                entity={\"status\": \"error\", \"updatedAt\": datetime.utcnow().isoformat()}\n            )\n        except Exception:\n            logger.error(f\"Failed to update error status for pet detail {detail_id}\")\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchRequest)\nasync def pets_search(data: SearchRequest):\n    entity_name = \"pet\"\n    data_dict = data.__dict__\n    try:\n        id_ = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"searchId\": str(id_)})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add search item\"}), 500\n\n@app.route(\"/pets/search/<string:search_id>\", methods=[\"GET\"])\nasync def get_search_results(search_id):\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=PET_CACHE_MODEL,\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id\n        )\n        if not item:\n            return jsonify({\"error\": \"searchId not found\"}), 404\n        return jsonify({\"searchId\": search_id, **item})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve search results\"}), 500\n\n@app.route(\"/pets/details\", methods=[\"POST\"])\n@validate_request(DetailRequest)\nasync def pets_details(data: DetailRequest):\n    entity_name = \"pet_detail\"\n    data_dict = data.__dict__\n    try:\n        id_ = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"detailId\": str(id_)})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add detail item\"}), 500\n\n@app.route(\"/pets/details/<string:detail_id>\", methods=[\"GET\"])\nasync def get_pet_detail(detail_id):\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=PET_DETAIL_CACHE_MODEL,\n            entity_version=ENTITY_VERSION,\n            technical_id=detail_id\n        )\n        if not item:\n            return jsonify({\"error\": \"detailId not found\"}), 404\n        return jsonify({\"detailId\": detail_id, **item})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve pet detail\"}), 500\n\nif __name__ == '__main__':\n    import logging as _logging\n    _logging.basicConfig(level=_logging.INFO)\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}