{
    "entity_models": [
        {
            "entity_model_name": "pet_search_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nimport httpx",
                "content": "async def process_pet_search_request(entity):\n    \"\"\"\n    Workflow for pet_search_request entity.\n    Set initial status if missing.\n    \"\"\"\n    if \"status\" not in entity:\n        entity[\"status\"] = \"processing\"\n    # Placeholder for async processing tasks related to search\n    return entity",
                "name": "process_pet_search_request"
            }
        },
        {
            "entity_model_name": "pet_detail",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nimport httpx",
                "content": "async def process_pet_detail(entity):\n    \"\"\"\n    Workflow for pet_detail entity.\n    Enrich pet detail by fetching data from external API.\n    \"\"\"\n    if entity.get(\"status\") == \"completed\" or entity.get(\"status\") == \"failed\":\n        return entity\n\n    pet_id = entity.get(\"id\")\n    if not pet_id:\n        logger.warning(\"pet_detail entity missing 'id'\")\n        entity[\"status\"] = \"failed\"\n        entity[\"data\"] = None\n        return entity\n\n    entity[\"status\"] = \"processing\"  # mark as processing\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(f\"https://petstore.swagger.io/v2/pet/{pet_id}\")\n            resp.raise_for_status()\n            pet = resp.json()\n\n        name = pet.get(\"name\", \"Mysterious Pet\")\n        category = pet.get(\"category\", {}).get(\"name\", \"Unknown Category\")\n        status = pet.get(\"status\", \"unknown\")\n        fun_description = f\"{name} is a wonderful {category.lower()} currently {status} and waiting for a loving home! \u001f63b\"\n\n        enriched = {\n            \"id\": pet_id,\n            \"name\": name,\n            \"category\": category,\n            \"status\": status,\n            \"funDescription\": fun_description,\n        }\n\n        entity[\"status\"] = \"completed\"\n        entity[\"data\"] = enriched\n\n    except (httpx.RequestError, httpx.HTTPStatusError) as e:\n        logger.warning(f\"HTTP error fetching pet_detail for id {pet_id}: {e}\")\n        entity[\"status\"] = \"failed\"\n        entity[\"data\"] = None\n    except Exception as e:\n        logger.exception(f\"Unexpected error enriching pet_detail entity with id {pet_id}: {e}\")\n        entity[\"status\"] = \"failed\"\n        entity[\"data\"] = None\n\n    return entity",
                "name": "process_pet_detail"
            }
        }
    ],
    "file_without_workflow": {
        "code": "import asyncio\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n# --- Workflow functions ---\n\nasync def process_pet_search_request(entity):\n    \"\"\"\n    Workflow for pet_search_request entity.\n    Set initial status if missing.\n    \"\"\"\n    if \"status\" not in entity:\n        entity[\"status\"] = \"processing\"\n    # Placeholder for async processing tasks related to search\n    return entity\n\n\nasync def process_pet_detail(entity):\n    \"\"\"\n    Workflow for pet_detail entity.\n    Enrich pet detail by fetching data from external API.\n    \"\"\"\n    if entity.get(\"status\") == \"completed\" or entity.get(\"status\") == \"failed\":\n        return entity\n\n    pet_id = entity.get(\"id\")\n    if not pet_id:\n        logger.warning(\"pet_detail entity missing 'id'\")\n        entity[\"status\"] = \"failed\"\n        entity[\"data\"] = None\n        return entity\n\n    entity[\"status\"] = \"processing\"  # mark as processing\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(f\"https://petstore.swagger.io/v2/pet/{pet_id}\")\n            resp.raise_for_status()\n            pet = resp.json()\n\n        name = pet.get(\"name\", \"Mysterious Pet\")\n        category = pet.get(\"category\", {}).get(\"name\", \"Unknown Category\")\n        status = pet.get(\"status\", \"unknown\")\n        fun_description = f\"{name} is a wonderful {category.lower()} currently {status} and waiting for a loving home! \u001f63b\"\n\n        enriched = {\n            \"id\": pet_id,\n            \"name\": name,\n            \"category\": category,\n            \"status\": status,\n            \"funDescription\": fun_description,\n        }\n\n        entity[\"status\"] = \"completed\"\n        entity[\"data\"] = enriched\n\n    except (httpx.RequestError, httpx.HTTPStatusError) as e:\n        logger.warning(f\"HTTP error fetching pet_detail for id {pet_id}: {e}\")\n        entity[\"status\"] = \"failed\"\n        entity[\"data\"] = None\n    except Exception as e:\n        logger.exception(f\"Unexpected error enriching pet_detail entity with id {pet_id}: {e}\")\n        entity[\"status\"] = \"failed\"\n        entity[\"data\"] = None\n\n    return entity\n\n\n@dataclass\nclass PetSearchRequest:\n    status: str\n    category: Optional[str] = None\n\n@dataclass\nclass PetDetailsRequest:\n    petIds: List[str]\n\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(PetSearchRequest)\nasync def pets_search(data: PetSearchRequest):\n    search_data = {\n        \"status\": data.status,\n        \"category\": data.category\n    }\n    try:\n        search_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_search_request\",\n            entity_version=ENTITY_VERSION,\n            entity=search_data\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to add pet_search_request item: {e}\")\n        return jsonify({\"error\": \"Failed to process search request\"}), 500\n\n    return jsonify({\"searchId\": search_id})\n\n\n@app.route(\"/pets/search/<string:search_id>\", methods=[\"GET\"])\nasync def get_search_results(search_id):\n    try:\n        entry = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_search_request\",\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id\n        )\n    except Exception as e:\n        logger.exception(f\"Error retrieving pet_search_request with id {search_id}: {e}\")\n        return jsonify({\"error\": \"searchId not found\"}), 404\n\n    if not entry:\n        return jsonify({\"error\": \"searchId not found\"}), 404\n\n    status = entry.get(\"status\")\n    if status == \"processing\":\n        return jsonify({\"searchId\": search_id, \"status\": \"processing\", \"results\": None}), 202\n    if status == \"failed\":\n        return jsonify({\"searchId\": search_id, \"status\": \"failed\", \"results\": None}), 500\n\n    results = entry.get(\"results\")\n    return jsonify({\"searchId\": search_id, \"results\": results})\n\n\n@app.route(\"/pets/details\", methods=[\"POST\"])\n@validate_request(PetDetailsRequest)\nasync def pets_details(data: PetDetailsRequest):\n    pet_ids = data.petIds\n    pets_response = []\n\n    async def get_pet_detail_entity(pet_id: str):\n        try:\n            entity = await entity_service.get_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet_detail\",\n                entity_version=ENTITY_VERSION,\n                technical_id=pet_id\n            )\n            if entity is None:\n                new_entity = {\"id\": pet_id}\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet_detail\",\n                    entity_version=ENTITY_VERSION,\n                    entity=new_entity\n                )\n                entity = await entity_service.get_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet_detail\",\n                    entity_version=ENTITY_VERSION,\n                    technical_id=pet_id\n                )\n            elif entity.get(\"status\") not in (\"completed\", \"failed\"):\n                # Trigger re-processing if status is neither completed nor failed\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet_detail\",\n                    entity_version=ENTITY_VERSION,\n                    entity=entity\n                )\n                entity = await entity_service.get_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet_detail\",\n                    entity_version=ENTITY_VERSION,\n                    technical_id=pet_id\n                )\n            return entity\n        except Exception as e:\n            logger.exception(f\"Failed to get or create pet_detail for id {pet_id}: {e}\")\n            return None\n\n    tasks = [get_pet_detail_entity(pid) for pid in pet_ids]\n    entities = await asyncio.gather(*tasks)\n\n    for ent in entities:\n        if ent and ent.get(\"status\") == \"completed\" and ent.get(\"data\"):\n            pets_response.append(ent[\"data\"])\n        else:\n            logger.warning(f\"Pet detail entity incomplete or failed: {ent}\")\n\n    return jsonify({\"pets\": pets_response})\n\n\n@app.route(\"/pets/details/<string:pet_id>\", methods=[\"GET\"])\nasync def get_pet_details(pet_id):\n    try:\n        entry = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_detail\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id\n        )\n    except Exception as e:\n        logger.exception(f\"Error retrieving pet_detail with id {pet_id}: {e}\")\n        return jsonify({\"error\": \"petId not found\"}), 404\n\n    if not entry:\n        return jsonify({\"error\": \"petId not found\"}), 404\n\n    status = entry.get(\"status\")\n    if status == \"processing\":\n        return jsonify({\"petId\": pet_id, \"status\": \"processing\", \"data\": None}), 202\n    if status == \"failed\":\n        return jsonify({\"petId\": pet_id, \"status\": \"failed\", \"data\": None}), 500\n\n    return jsonify(entry.get(\"data\"))\n\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}