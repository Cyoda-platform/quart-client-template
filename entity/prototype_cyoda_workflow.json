{
    "entity_models": [
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport asyncio\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nasync def _background_process_pet_search(search_id: str, type_: str = None, status: str = None):\n    try:\n        status_query = status if status else \"available\"\n        pets = await fetch_pets_from_petstore(status_query)\n\n        if type_:\n            pets = [pet for pet in pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == type_.lower()]\n\n        results = []\n        for pet in pets:\n            results.append({\n                \"id\": pet.get(\"id\"),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n                \"status\": pet.get(\"status\")\n            })\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_search_result\",\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id,\n            entity={\n                \"status\": \"done\",\n                \"results\": results,\n                \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Error in background pet search processing for searchId={search_id}: {e}\")\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet_search_result\",\n                entity_version=ENTITY_VERSION,\n                technical_id=search_id,\n                entity={\"status\": \"error\", \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"}\n            )\n        except Exception:\n            pass\n\nasync def fetch_pets_from_petstore(status: str):\n    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n    params = {\"status\": status}\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return response.json()",
                "content": "async def process_pet(entity: dict):\n    \"\"\"\n    Workflow for pet search entity:\n    - Generate searchId\n    - Store it in entity to persist\n    - Add a secondary entity 'pet_search_result' to hold results & status\n    - Fire off background search task that updates this secondary entity\n    \"\"\"\n    search_id = generate_id()\n    entity[\"searchId\"] = search_id\n\n    search_result_entity = {\n        \"searchId\": search_id,\n        \"status\": \"queued\",\n        \"results\": [],\n        \"createdAt\": datetime.utcnow().isoformat() + \"Z\"\n    }\n\n    # Add 'pet_search_result' entity (different entity_model)\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_search_result\",\n            entity_version=ENTITY_VERSION,\n            entity=search_result_entity,\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to add pet_search_result entity for searchId={search_id}: {e}\")\n\n    # Fire and forget background task to fetch pets and update pet_search_result entity\n    asyncio.create_task(_background_process_pet_search(search_id, entity.get(\"type\"), entity.get(\"status\")))\n\n    return entity",
                "name": "process_pet"
            }
        },
        {
            "entity_model_name": "pet_detail",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def _background_process_pet_detail(detail_id: str, pet_id: int):\n    try:\n        pet = await fetch_pet_detail_from_petstore(pet_id)\n        description = pet.get(\"description\") or \"No description available.\"\n\n        pet_processed = {\n            \"id\": pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n            \"status\": pet.get(\"status\"),\n            \"description\": description,\n        }\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_detail_result\",\n            entity_version=ENTITY_VERSION,\n            technical_id=detail_id,\n            entity={\n                \"status\": \"done\",\n                \"detail\": pet_processed,\n                \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Error in background pet detail processing for detailId={detail_id}: {e}\")\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet_detail_result\",\n                entity_version=ENTITY_VERSION,\n                technical_id=detail_id,\n                entity={\"status\": \"error\", \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"}\n            )\n        except Exception:\n            pass\n\nasync def fetch_pet_detail_from_petstore(pet_id: int):\n    url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url, timeout=10)\n        response.raise_for_status()\n        return response.json()",
                "content": "async def process_pet_detail(entity: dict):\n    \"\"\"\n    Workflow for pet detail entity:\n    - Generate detailId\n    - Store in entity to persist\n    - Add secondary entity 'pet_detail_result' to hold detail & status\n    - Fire off background detail fetch task that updates the secondary entity\n    \"\"\"\n    detail_id = generate_id()\n    entity[\"detailId\"] = detail_id\n    pet_id = entity.get(\"petId\")\n\n    detail_result_entity = {\n        \"detailId\": detail_id,\n        \"status\": \"queued\",\n        \"detail\": {},\n        \"createdAt\": datetime.utcnow().isoformat() + \"Z\"\n    }\n\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_detail_result\",\n            entity_version=ENTITY_VERSION,\n            entity=detail_result_entity,\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to add pet_detail_result entity for detailId={detail_id}: {e}\")\n\n    asyncio.create_task(_background_process_pet_detail(detail_id, pet_id))\n\n    return entity",
                "name": "process_pet_detail"
            }
        }
    ],
    "file_without_workflow": {
        "code": " from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nimport uuid\n\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\nimport httpx\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass SearchRequest:\n    type: str = None\n    status: str = None\n\n@dataclass\nclass DetailRequest:\n    petId: int\n\nPETSTORE_BASE_URL = \"https://petstore.swagger.io/v2\"\n\ndef generate_id() -> str:\n    return str(uuid.uuid4())\n\nasync def fetch_pets_from_petstore(status: str):\n    url = f\"{PETSTORE_BASE_URL}/pet/findByStatus\"\n    params = {\"status\": status}\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return response.json()\n\nasync def fetch_pet_detail_from_petstore(pet_id: int):\n    url = f\"{PETSTORE_BASE_URL}/pet/{pet_id}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url, timeout=10)\n        response.raise_for_status()\n        return response.json()\n\nasync def process_pet(entity: dict):\n    \"\"\"\n    Workflow for pet search entity:\n    - Generate searchId\n    - Store it in entity to persist\n    - Add a secondary entity 'pet_search_result' to hold results & status\n    - Fire off background search task that updates this secondary entity\n    \"\"\"\n    search_id = generate_id()\n    entity[\"searchId\"] = search_id\n\n    search_result_entity = {\n        \"searchId\": search_id,\n        \"status\": \"queued\",\n        \"results\": [],\n        \"createdAt\": datetime.utcnow().isoformat() + \"Z\"\n    }\n\n    # Add 'pet_search_result' entity (different entity_model)\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_search_result\",\n            entity_version=ENTITY_VERSION,\n            entity=search_result_entity,\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to add pet_search_result entity for searchId={search_id}: {e}\")\n\n    # Fire and forget background task to fetch pets and update pet_search_result entity\n    asyncio.create_task(_background_process_pet_search(search_id, entity.get(\"type\"), entity.get(\"status\")))\n\n    return entity\n\nasync def _background_process_pet_search(search_id: str, type_: str = None, status: str = None):\n    try:\n        status_query = status if status else \"available\"\n        pets = await fetch_pets_from_petstore(status_query)\n\n        if type_:\n            pets = [pet for pet in pets if pet.get(\"category\", {}).get(\"name\", \"\").lower() == type_.lower()]\n\n        results = []\n        for pet in pets:\n            results.append({\n                \"id\": pet.get(\"id\"),\n                \"name\": pet.get(\"name\"),\n                \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n                \"status\": pet.get(\"status\")\n            })\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_search_result\",\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id,\n            entity={\n                \"status\": \"done\",\n                \"results\": results,\n                \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Error in background pet search processing for searchId={search_id}: {e}\")\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet_search_result\",\n                entity_version=ENTITY_VERSION,\n                technical_id=search_id,\n                entity={\"status\": \"error\", \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"}\n            )\n        except Exception:\n            pass\n\nasync def process_pet_detail(entity: dict):\n    \"\"\"\n    Workflow for pet detail entity:\n    - Generate detailId\n    - Store in entity to persist\n    - Add secondary entity 'pet_detail_result' to hold detail & status\n    - Fire off background detail fetch task that updates the secondary entity\n    \"\"\"\n    detail_id = generate_id()\n    entity[\"detailId\"] = detail_id\n    pet_id = entity.get(\"petId\")\n\n    detail_result_entity = {\n        \"detailId\": detail_id,\n        \"status\": \"queued\",\n        \"detail\": {},\n        \"createdAt\": datetime.utcnow().isoformat() + \"Z\"\n    }\n\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_detail_result\",\n            entity_version=ENTITY_VERSION,\n            entity=detail_result_entity,\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to add pet_detail_result entity for detailId={detail_id}: {e}\")\n\n    asyncio.create_task(_background_process_pet_detail(detail_id, pet_id))\n\n    return entity\n\nasync def _background_process_pet_detail(detail_id: str, pet_id: int):\n    try:\n        pet = await fetch_pet_detail_from_petstore(pet_id)\n        description = pet.get(\"description\") or \"No description available.\"\n\n        pet_processed = {\n            \"id\": pet.get(\"id\"),\n            \"name\": pet.get(\"name\"),\n            \"type\": pet.get(\"category\", {}).get(\"name\") if pet.get(\"category\") else None,\n            \"status\": pet.get(\"status\"),\n            \"description\": description,\n        }\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet_detail_result\",\n            entity_version=ENTITY_VERSION,\n            technical_id=detail_id,\n            entity={\n                \"status\": \"done\",\n                \"detail\": pet_processed,\n                \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"\n            }\n        )\n    except Exception as e:\n        logger.exception(f\"Error in background pet detail processing for detailId={detail_id}: {e}\")\n        try:\n            await entity_service.update_item(\n                token=cyoda_auth_service,\n                entity_model=\"pet_detail_result\",\n                entity_version=ENTITY_VERSION,\n                technical_id=detail_id,\n                entity={\"status\": \"error\", \"updatedAt\": datetime.utcnow().isoformat() + \"Z\"}\n            )\n        except Exception:\n            pass\n\n@app.route(\"/pets/search\", methods=[\"POST\"])\n@validate_request(SearchRequest)\nasync def pets_search(data: SearchRequest):\n    entity_name = \"pet\"\n    data_dict = data.__dict__\n    try:\n        # add_item returns technical_id but searchId is inside entity dict\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"searchId\": str(data_dict.get(\"searchId\"))})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add search item\"}), 500\n\n@app.route(\"/pets/search/<string:search_id>\", methods=[\"GET\"])\nasync def get_search_results(search_id):\n    entity_name = \"pet_search_result\"\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            technical_id=search_id,\n        )\n        if not item:\n            return jsonify({\"error\": \"searchId not found\"}), 404\n        return jsonify({\"searchId\": search_id, **item})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve search results\"}), 500\n\n@app.route(\"/pets/details\", methods=[\"POST\"])\n@validate_request(DetailRequest)\nasync def pets_details(data: DetailRequest):\n    entity_name = \"pet_detail\"\n    data_dict = data.__dict__\n    try:\n        await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=data_dict\n        )\n        return jsonify({\"detailId\": str(data_dict.get(\"detailId\"))})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to add detail item\"}), 500\n\n@app.route(\"/pets/details/<string:detail_id>\", methods=[\"GET\"])\nasync def get_pet_detail(detail_id):\n    entity_name = \"pet_detail_result\"\n    try:\n        item = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            technical_id=detail_id,\n        )\n        if not item:\n            return jsonify({\"error\": \"detailId not found\"}), 404\n        return jsonify({\"detailId\": detail_id, **item})\n    except Exception as e:\n        logger.exception(e)\n        return jsonify({\"error\": \"Failed to retrieve pet detail\"}), 500\n\nif __name__ == '__main__':\n    import logging as _logging\n    _logging.basicConfig(level=_logging.INFO)\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}