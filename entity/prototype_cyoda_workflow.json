{
    "entity_models": [
        {
            "entity_model_name": "weather_fetch_request",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport httpx\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_weather_fetch_request(entity: Dict[str, Any]) -> None:\n    \"\"\"\n    Workflow function applied to the weather_fetch_request entity before persistence.\n    This asynchronously fetches weather data and modifies the entity state accordingly.\n    \"\"\"\n\n    entity[\"status\"] = \"processing\"\n    entity[\"requestedAt\"] = entity.get(\"requestedAt\") or datetime.utcnow().isoformat() + \"Z\"\n\n    latitude = entity.get(\"latitude\")\n    longitude = entity.get(\"longitude\")\n    parameters = entity.get(\"parameters\", [])\n\n    # Validate coordinates and parameters early to prevent unnecessary requests\n    if not isinstance(latitude, (int, float)) or not isinstance(longitude, (int, float)):\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = \"Invalid latitude or longitude\"\n        logger.error(\"Invalid latitude or longitude in entity\")\n        return\n\n    if not parameters or not all(isinstance(p, str) for p in parameters):\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = \"Parameters must be a non-empty list of strings\"\n        logger.error(\"Invalid parameters in entity\")\n        return\n\n    url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"hourly\": \",\".join(parameters),\n        \"timezone\": \"UTC\",\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            response = await client.get(url, params=params)\n            response.raise_for_status()\n            data = response.json()\n\n        entity[\"data\"] = data\n        entity[\"timestamp\"] = datetime.utcnow().isoformat() + \"Z\"\n        entity[\"status\"] = \"completed\"\n        if \"error\" in entity:\n            del entity[\"error\"]\n        logger.info(f\"Weather data fetched successfully for entity at {entity['timestamp']}\")\n\n    except httpx.RequestError as e:\n        error_message = f\"Network error while fetching weather data: {str(e)}\"\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = error_message\n        logger.error(error_message)\n\n    except httpx.HTTPStatusError as e:\n        error_message = f\"HTTP error while fetching weather data: {str(e)}\"\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = error_message\n        logger.error(error_message)\n\n    except Exception as e:\n        error_message = f\"Unexpected error while fetching weather data: {str(e)}\"\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = error_message\n        logger.error(error_message)",
                "name": "process_weather_fetch_request"
            }
        }
    ],
    "file_without_workflow": {
        "code": " from dataclasses import dataclass\nimport asyncio\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, List\n\nimport httpx\nfrom quart import Quart, jsonify\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\n@dataclass\nclass WeatherFetchRequest:\n    latitude: float\n    longitude: float\n    parameters: List[str]\n\nasync def process_weather_fetch_request(entity: Dict[str, Any]) -> None:\n    \"\"\"\n    Workflow function applied to the weather_fetch_request entity before persistence.\n    This asynchronously fetches weather data and modifies the entity state accordingly.\n    \"\"\"\n\n    entity[\"status\"] = \"processing\"\n    entity[\"requestedAt\"] = entity.get(\"requestedAt\") or datetime.utcnow().isoformat() + \"Z\"\n\n    latitude = entity.get(\"latitude\")\n    longitude = entity.get(\"longitude\")\n    parameters = entity.get(\"parameters\", [])\n\n    # Validate coordinates and parameters early to prevent unnecessary requests\n    if not isinstance(latitude, (int, float)) or not isinstance(longitude, (int, float)):\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = \"Invalid latitude or longitude\"\n        logger.error(\"Invalid latitude or longitude in entity\")\n        return\n\n    if not parameters or not all(isinstance(p, str) for p in parameters):\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = \"Parameters must be a non-empty list of strings\"\n        logger.error(\"Invalid parameters in entity\")\n        return\n\n    url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"hourly\": \",\".join(parameters),\n        \"timezone\": \"UTC\",\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            response = await client.get(url, params=params)\n            response.raise_for_status()\n            data = response.json()\n\n        entity[\"data\"] = data\n        entity[\"timestamp\"] = datetime.utcnow().isoformat() + \"Z\"\n        entity[\"status\"] = \"completed\"\n        if \"error\" in entity:\n            del entity[\"error\"]\n        logger.info(f\"Weather data fetched successfully for entity at {entity['timestamp']}\")\n\n    except httpx.RequestError as e:\n        error_message = f\"Network error while fetching weather data: {str(e)}\"\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = error_message\n        logger.error(error_message)\n\n    except httpx.HTTPStatusError as e:\n        error_message = f\"HTTP error while fetching weather data: {str(e)}\"\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = error_message\n        logger.error(error_message)\n\n    except Exception as e:\n        error_message = f\"Unexpected error while fetching weather data: {str(e)}\"\n        entity[\"status\"] = \"failed\"\n        entity[\"error\"] = error_message\n        logger.error(error_message)\n\n@app.route(\"/weather/fetch\", methods=[\"POST\"])\n@validate_request(WeatherFetchRequest)\nasync def fetch_weather(data: WeatherFetchRequest):\n    entity_name = \"weather_fetch_request\"\n    entity_data = {\n        \"latitude\": data.latitude,\n        \"longitude\": data.longitude,\n        \"parameters\": data.parameters,\n    }\n\n    try:\n        id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            entity=entity_data\n        )\n    except Exception as e:\n        logger.exception(\"Failed to add weather_fetch_request entity\")\n        return jsonify({\"status\": \"error\", \"message\": \"Failed to start weather data fetching\"}), 500\n\n    return jsonify({\n        \"status\": \"success\",\n        \"message\": \"Weather data fetching started\",\n        \"dataId\": str(id)\n    })\n\n@app.route(\"/weather/result/<string:data_id>\", methods=[\"GET\"])\nasync def get_weather_result(data_id):\n    entity_name = \"weather_fetch_request\"\n    try:\n        entry = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=entity_name,\n            entity_version=ENTITY_VERSION,\n            technical_id=data_id\n        )\n    except Exception as e:\n        logger.exception(\"Failed to retrieve weather data\")\n        return jsonify({\"status\": \"error\", \"message\": \"Failed to retrieve data\"}), 500\n\n    if not entry:\n        return jsonify({\"status\": \"error\", \"message\": \"dataId not found\"}), 404\n\n    status = entry.get(\"status\")\n    if status == \"processing\":\n        return jsonify({\"status\": \"processing\", \"message\": \"Data is still being fetched\"}), 202\n    if status == \"failed\":\n        return jsonify({\"status\": \"error\", \"message\": entry.get(\"error\", \"Unknown error\")}), 500\n    if status != \"completed\":\n        return jsonify({\"status\": \"error\", \"message\": f\"Unexpected status: {status}\"}), 500\n\n    response = {\n        \"dataId\": data_id,\n        \"latitude\": entry.get(\"latitude\"),\n        \"longitude\": entry.get(\"longitude\"),\n        \"parameters\": {},\n        \"timestamp\": entry.get(\"timestamp\"),\n    }\n\n    data = entry.get(\"data\", {})\n    hourly = data.get(\"hourly\", {})\n    for param in entry.get(\"parameters\", []):\n        values = hourly.get(param)\n        response[\"parameters\"][param] = values[-1] if isinstance(values, list) else values\n\n    return jsonify(response)\n\nif __name__ == '__main__':\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)"
    }
}