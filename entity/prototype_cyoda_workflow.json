{
    "entity_models": [
        {
            "entity_model_name": "fetch_pets_job",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "import asyncio\nimport logging\nfrom datetime import datetime\n\nimport httpx\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"\n\nasync def fetch_pets_from_petstore(filter_status, filter_category):\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            url = f\"{PETSTORE_API_BASE}/pet/findByStatus\"\n            params = {\"status\": filter_status or \"available\"}\n            resp = await client.get(url, params=params)\n            resp.raise_for_status()\n            pets = resp.json()\n            if filter_category:\n                pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == filter_category.lower()]\n            return pets\n        except Exception:\n            logger.exception(\"Failed to fetch pets from Petstore API\")\n            return []",
                "content": "async def process_fetch_pets_job_entity(entity: dict) -> dict:\n    status = None\n    category = None\n    # Defensive extraction\n    if isinstance(entity.get(\"filter\"), dict):\n        status = entity[\"filter\"].get(\"status\")\n        category = entity[\"filter\"].get(\"category\")\n\n    async def fetch_and_add():\n        pets = await fetch_pets_from_petstore(status, category)\n        for pet in pets:\n            try:\n                pet_data = {\n                    \"name\": pet.get(\"name\"),\n                    \"category\": pet.get(\"category\", {}).get(\"name\"),\n                    \"status\": pet.get(\"status\"),\n                    \"tags\": [t.get(\"name\") for t in pet.get(\"tags\", []) if t.get(\"name\")]\n                }\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet\",\n                    entity_version=ENTITY_VERSION,\n                    entity=pet_data,\n                    workflow=process_pet\n                )\n            except Exception:\n                logger.exception(\"Failed to add pet in fetch job workflow\")\n\n    asyncio.create_task(fetch_and_add())\n\n    # Update job entity status fields\n    entity[\"status\"] = \"processing\"\n    entity[\"requestedAt\"] = datetime.utcnow().isoformat()\n    entity[\"updatedAt\"] = datetime.utcnow().isoformat()\n\n    return entity",
                "name": "process_fetch_pets_job_entity"
            }
        },
        {
            "entity_model_name": "pet",
            "workflow_function": {
                "code_with_necessary_imports_and_constants": "from datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)",
                "content": "async def process_pet(entity: dict) -> dict:\n    # Normalize tags to a list of strings\n    if \"tags\" not in entity or not isinstance(entity[\"tags\"], list):\n        entity[\"tags\"] = []\n    else:\n        entity[\"tags\"] = [str(t) for t in entity[\"tags\"] if isinstance(t, (str, int, float)) and str(t).strip()]\n\n    # Add createdAt timestamp if missing\n    if \"createdAt\" not in entity:\n        entity[\"createdAt\"] = datetime.utcnow().isoformat()\n\n    # Always update updatedAt timestamp\n    entity[\"updatedAt\"] = datetime.utcnow().isoformat()\n\n    # Placeholder for adding supplementary entities of different model if needed\n    # This is commented out, enable only if required and ensure no infinite recursion\n    # for tag_name in entity[\"tags\"]:\n    #     try:\n    #         await entity_service.add_item(\n    #             token=cyoda_auth_service,\n    #             entity_model=\"tag\",\n    #             entity_version=ENTITY_VERSION,\n    #             entity={\"name\": tag_name},\n    #             workflow=None\n    #         )\n    #     except Exception:\n    #         logger.exception(f\"Failed to add tag entity for tag {tag_name}\")\n\n    return entity",
                "name": "process_pet"
            }
        }
    ],
    "file_without_workflow": {
        "code": "from dataclasses import dataclass\nfrom typing import Optional, List\n\nimport asyncio\nimport logging\nfrom datetime import datetime\n\nimport httpx\nfrom quart import Quart, jsonify, request\nfrom quart_schema import QuartSchema, validate_request\n\nfrom app_init.app_init import BeanFactory\nfrom common.config.config import ENTITY_VERSION\n\nfactory = BeanFactory(config={'CHAT_REPOSITORY': 'cyoda'})\nentity_service = factory.get_services()['entity_service']\ncyoda_auth_service = factory.get_services()[\"cyoda_auth_service\"]\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\napp = Quart(__name__)\nQuartSchema(app)\n\nPETSTORE_API_BASE = \"https://petstore.swagger.io/v2\"\n\nasync def fetch_pets_from_petstore(filter_status, filter_category):\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            url = f\"{PETSTORE_API_BASE}/pet/findByStatus\"\n            params = {\"status\": filter_status or \"available\"}\n            resp = await client.get(url, params=params)\n            resp.raise_for_status()\n            pets = resp.json()\n            if filter_category:\n                pets = [p for p in pets if p.get(\"category\", {}).get(\"name\", \"\").lower() == filter_category.lower()]\n            return pets\n        except Exception:\n            logger.exception(\"Failed to fetch pets from Petstore API\")\n            return []\n\n# Workflow function for 'pet' entity\nasync def process_pet(entity: dict) -> dict:\n    # Normalize tags to a list of strings\n    if \"tags\" not in entity or not isinstance(entity[\"tags\"], list):\n        entity[\"tags\"] = []\n    else:\n        entity[\"tags\"] = [str(t) for t in entity[\"tags\"] if isinstance(t, (str, int, float)) and str(t).strip()]\n\n    # Add createdAt timestamp if missing\n    if \"createdAt\" not in entity:\n        entity[\"createdAt\"] = datetime.utcnow().isoformat()\n\n    # Always update updatedAt timestamp\n    entity[\"updatedAt\"] = datetime.utcnow().isoformat()\n\n    # Placeholder for adding supplementary entities of different model if needed\n    # This is commented out, enable only if required and ensure no infinite recursion\n    # for tag_name in entity[\"tags\"]:\n    #     try:\n    #         await entity_service.add_item(\n    #             token=cyoda_auth_service,\n    #             entity_model=\"tag\",\n    #             entity_version=ENTITY_VERSION,\n    #             entity={\"name\": tag_name},\n    #             workflow=None\n    #         )\n    #     except Exception:\n    #         logger.exception(f\"Failed to add tag entity for tag {tag_name}\")\n\n    return entity\n\n# Workflow function for 'fetch_pets_job' entity to start asynchronous fetch and add pets\nasync def process_fetch_pets_job_entity(entity: dict) -> dict:\n    status = None\n    category = None\n    # Defensive extraction\n    if isinstance(entity.get(\"filter\"), dict):\n        status = entity[\"filter\"].get(\"status\")\n        category = entity[\"filter\"].get(\"category\")\n\n    async def fetch_and_add():\n        pets = await fetch_pets_from_petstore(status, category)\n        for pet in pets:\n            try:\n                pet_data = {\n                    \"name\": pet.get(\"name\"),\n                    \"category\": pet.get(\"category\", {}).get(\"name\"),\n                    \"status\": pet.get(\"status\"),\n                    \"tags\": [t.get(\"name\") for t in pet.get(\"tags\", []) if t.get(\"name\")]\n                }\n                await entity_service.add_item(\n                    token=cyoda_auth_service,\n                    entity_model=\"pet\",\n                    entity_version=ENTITY_VERSION,\n                    entity=pet_data\n                )\n            except Exception:\n                logger.exception(\"Failed to add pet in fetch job workflow\")\n\n    asyncio.create_task(fetch_and_add())\n\n    # Update job entity status fields\n    entity[\"status\"] = \"processing\"\n    entity[\"requestedAt\"] = datetime.utcnow().isoformat()\n    entity[\"updatedAt\"] = datetime.utcnow().isoformat()\n\n    return entity\n\n@dataclass\nclass Filter:\n    status: str\n    category: Optional[str] = None\n\n@dataclass\nclass FetchPetsRequest:\n    filter: Filter\n\n@dataclass\nclass AddPetRequest:\n    name: str\n    category: str\n    status: str\n    tags: List[str]\n\n@dataclass\nclass UpdatePetRequest:\n    name: Optional[str] = None\n    category: Optional[str] = None\n    status: Optional[str] = None\n    tags: Optional[List[str]] = None\n\n@app.route(\"/pets/fetch\", methods=[\"POST\"])\n@validate_request(FetchPetsRequest)\nasync def pets_fetch(data: FetchPetsRequest):\n    job_entity = {\n        \"filter\": {\n            \"status\": data.filter.status,\n            \"category\": data.filter.category,\n        }\n    }\n    try:\n        job_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"fetch_pets_job\",\n            entity_version=ENTITY_VERSION,\n            entity=job_entity\n        )\n        return jsonify({\"message\": \"Data fetch initiated\", \"job_id\": str(job_id)})\n    except Exception:\n        logger.exception(\"Failed to create fetch pets job entity\")\n        return jsonify({\"message\": \"Failed to initiate data fetch\"}), 500\n\n@app.route(\"/pets\", methods=[\"GET\"])\nasync def list_pets():\n    try:\n        pets = await entity_service.get_items(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n        )\n        return jsonify(pets)\n    except Exception:\n        logger.exception(\"Failed to list pets\")\n        return jsonify({\"message\": \"Failed to list pets\"}), 500\n\n@app.route(\"/pets/add\", methods=[\"POST\"])\n@validate_request(AddPetRequest)\nasync def add_pet(data: AddPetRequest):\n    pet_data = {\n        \"name\": data.name,\n        \"category\": data.category,\n        \"status\": data.status,\n        \"tags\": data.tags,\n    }\n    try:\n        pet_id = await entity_service.add_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=pet_data\n        )\n        logger.info(f\"Added pet {pet_id}\")\n        return jsonify({\"message\": \"Pet added successfully\", \"pet_id\": str(pet_id)})\n    except Exception:\n        logger.exception(\"Failed to add pet\")\n        return jsonify({\"message\": \"Failed to add pet\"}), 500\n\n@app.route(\"/pets/<string:pet_id>\", methods=[\"GET\"])\nasync def get_pet(pet_id):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id,\n        )\n        if not pet:\n            return jsonify({\"message\": \"Pet not found\"}), 404\n        return jsonify(pet)\n    except Exception:\n        logger.exception(f\"Failed to get pet {pet_id}\")\n        return jsonify({\"message\": \"Failed to get pet\"}), 500\n\n@app.route(\"/pets/update/<string:pet_id>\", methods=[\"POST\"])\n@validate_request(UpdatePetRequest)\nasync def update_pet(data: UpdatePetRequest, pet_id):\n    try:\n        pet = await entity_service.get_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            technical_id=pet_id,\n        )\n        if not pet:\n            return jsonify({\"message\": \"Pet not found\"}), 404\n\n        if data.name is not None:\n            pet[\"name\"] = data.name\n        if data.category is not None:\n            pet[\"category\"] = data.category\n        if data.status is not None:\n            pet[\"status\"] = data.status\n        if data.tags is not None:\n            pet[\"tags\"] = data.tags\n\n        # Manually apply the workflow logic before updating, since update_item doesn't accept workflow\n        pet = await process_pet(pet)\n\n        await entity_service.update_item(\n            token=cyoda_auth_service,\n            entity_model=\"pet\",\n            entity_version=ENTITY_VERSION,\n            entity=pet,\n            technical_id=pet_id,\n            meta={}\n        )\n        logger.info(f\"Updated pet {pet_id}\")\n        return jsonify({\"message\": \"Pet updated successfully\"})\n    except Exception:\n        logger.exception(f\"Failed to update pet {pet_id}\")\n        return jsonify({\"message\": \"Failed to update pet\"}), 500\n\nif __name__ == '__main__':\n    import sys\n    logging.basicConfig(stream=sys.stdout, format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)\n    app.run(use_reloader=False, debug=True, host='0.0.0.0', port=8000, threaded=True)\n"
    }
}